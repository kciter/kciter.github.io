{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-01-19-using-kotlin-script-mdx","path":"/posts/using-kotlin-script/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n현대적인 언어 중 하나인 Kotlin은 JetBrains에서 만든 언어로, Java와 100% 호환되는 언어이다. 그렇기 때문에 Kotlin은 Android 개발에서도 사용되고 있으며, 서버 개발에서도 사용되고 있다. JVM 생태계 뿐만 아니라 다양한 곳에서 점유율을 높이고 싶은지 JetBrains는 KMP(Kotlin Multiplatform)를 통해 iOS, JS, 웹 어셈블리 등 다양한 플랫폼에서 Kotlin을 사용할 수 있도록 밀어주고 있다.\n\n재밌는 점은 Kotlin 커뮤니티에서 잘 언급되지는 않지만 Kotlin은 Python이나 Ruby, JavaScript와 같이 스크립트 언어로도 사용할 수 있다. 그런데 언급하지 않는 이유가 있다.\n\n<Image src=\"/images/2025-01-19-using-kotlin-script/experimental.png\" />\n\n바로 2025년 1월 19일 현재 기준으로 출시된지 7년 정도된 기술임에도 불구하고 아직까지 실험적인 기능으로 분류되어 있다. 그렇기 때문에 안정성이나 성능에 대한 보장이 없다. 하지만 우리는 이미 Kotlin Script를 잘 사용하고 있다.\n\n<Image src=\"/images/2025-01-19-using-kotlin-script/kotlin-gradle-dsl.png\" />\n\nSpring 서버 개발, 안드로이드 앱 개발 등을 해봤다면 높은 확률로 Gradle Kotlin DSL을 사용해봤을 것이다. Gradle Kotlin DSL은 Kotlin Script를 사용한다. 자세히보면 확장자가 `.kts`로 이는 Kotlin Script를 의미한다. 빌드 스크립트로 널리 사용되고 있음에도 불구하고 실험적인 기능으로 분류하는 것이 황당하지만 이미 정착된 기술이라고 할 수는 있을 것 같다. 이번 글에서는 Gradle Kotlin DSL을 제외하고 Kotlin Script를 어떻게 활용할 수 있을지 알아보자.\n\n# Kotlin Script 개념\n\n일단 Kotlin Script에 대해 아주 간단히 알아보자. Script가 붙은 것처럼 Kotlin Script는 Kotlin을 마치 스크립트 언어처럼 사용할 수 있게 해준다. 즉, 컴파일이나 패키징 없이 바로 실행할 수 있다.\n\n```kotlin\n// hello.kts\nfun say() {\n  println(\"Hello, Kotlin!\")\n}\n\nsay()\n```\n\n위 코드를 쉘에서 실행하면 따로 빌드하지 않아도 `Hello, Kotlin!`이 출력된다. 로컬에 Kotlin이 설치되어 있다면 다음과 같이 실행할 수 있다.\n\n```shell\n$ kotlinc -script hello.kts\nHello, Kotlin!\n```\n\n# 어디에 쓸 수 있을까?\n\n간단하게 실행할 수 있다는 것은 좋은데 어디에 쓸 수 있을까? 그전에 써야할 필요가 있을까? 오히려 쓰지 말아야 할 이유가 더 많아보인다.\n\n* 베타도 아니고 실험 단계\n* 현재 JVM 환경에서만 가능\n* **솔직히 대안이 많다**\n\n사실 써야할 이유는 전혀 없다고 볼 수 있다. 그럼에도 불구하고 이 글을 쓰는 이유는 두 가지로 재밌어 보이고 없어질 것 같지는 않기 때문이다. 이 글을 보는 여러분은 굳이 직접 설치해서 사용할 필요는 없다. 이 글을 보면서 재밌게 보고 가면 된다. 그럼 이번엔 어디에 쓸 수 있을지 알아보자.\n\n* 빌드를 위한 스크립트\n  * 이미 Gradle Kotlin DSL에서 잘 사용되고 있음\n* CLI 환경에서 스크립트 실행\n* Kotlin 프로그램 런타임에서 스크립트 실행\n\n빌드 스크립트를 제외하고 두 가지 사용 사례가 있을 수 있다. CLI 환경에서 스크립트를 실행할 때는 다른 스크립트 언어를 사용하거나 Shell Script를 사용할 수 있지만 Kotlin Script를 사용할 수도 있다. 또한 Kotlin 프로그램 런타임에서 스크립트를 실행할 때도 Kotlin Script를 사용할 수 있다.\n\n# CLI 환경에서 스크립트 실행\n\n앞서 말한 것 처럼 다른 스크립트 언어나 Shell Script 대신 Kotlin Script를 사용할 수 있다. 그렇다면 Kotlin Script를 사용하면 어떤 이점이 있을까?\n\n* Shell Script 보다는 쉬움\n* 타입 안정성\n* 외부 라이브러리 사용 가능\n* JVM 생태계와의 호환성\n* Kotlin 언어만 익숙한 경우\n\n이중에서 가장 큰 이점이 될 수 있는 것은 **Kotlin 언어만 익숙한 경우**일 것이다. 다른 언어도 생태계가 충분히 큰 경우가 많고 타입 안정성 또한 보장해줄 수 있기 때문이다. 복잡하고 큰 연산의 경우 Kotlin Script를 사용하는 것이 좋을 수 있지만 보통 스크립트는 간단한 작업을 위해 사용되기 때문에 큰 이점이 되지는 못한다. 오히려 JVM 워밍업 시간이 필요하므로 간단한 스크립트라면 워밍업 시간이 0에 가까운 Python이나 Node.js에 비해 느리다.\n\n그렇지만 어차피 로컬에서 돌리는 스크립트라면 그 약간의 시간 차이가 크게 중요하지는 않을 것이다. 만약 코틀린을 사용하는 조직이라면 다양한 언어로 툴을 만드는 것보다 언어를 통일하는게 비용이나 유지보수 측면에서 더 좋을 가능성이 있다.\n\n## 설치 및 실행\n\n[SDKMAN](https://sdkman.io/)을 이용하여 Kotlin을 설치할 수 있다. 설치는 다음과 같이 가능하다.\n\n```shell\n# Install sdkman\n$ curl -s https://get.sdkman.io | bash\n$ source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n\n# Install kotlin\n$ sdk install kotlin\n```\n\n이후엔 다음과 같이 작성한 `hello.kts`를 실행해볼 수 있다.\n\n```kotlin\n// hello.kts\nprintln(\"Hello, Kotlin!\")\n```\n\n```shell\n$ kotlinc -script hello.kts\nHello, Kotlin!\n```\n\n다른 스크립트처럼 shebang을 사용하면 더 간단하게 실행할 수 있다.\n\n```kotlin\n#!/usr/bin/env kotlinc -script\n\nprintln(\"Hello, Kotlin!\")\n```\n\n```shell\n$ chmod +x hello.kts\n$ ./hello.kts\nHello, Kotlin!\n```\n\n## KScript\n\n`kotlinc`는 기본 기능만 있기 때문에 다른 언어를 대체하기는 역부족하다는 평가를 받는다. 그래서 [KScript](https://github.com/kscripting/kscript)라는 것이 오픈소스로 개발되었다. KScript는 `kotlinc`에 비해 스크립트 캐싱, 의존성 관리, 바이너리 패키징 등 다양한 기능을 추가로 제공한다. 설치는 마찬가지로 SDKMAN을 통해 가능하다.\n\n```shell\n# Install kscript using sdkman\n$ sdk install kscript\n```\n\n주의할 점으로 아직 Kotlin 2.0에선 실행이 안되기 때문에 1.9 버전대를 사용해야한다.\n\n### 외부 라이브러리 사용\n\nKScript를 이용하면 외부 라이브러리를 편하게 사용할 수 있다. 다음은 `fuel` 라이브러리를 사용한 예시이다.\n\n노드의 package.json이나 파이썬의 requirements.txt 처럼 외부로 빼지 않고 스크립트 내부에 기술한다는 점이 좀 색다르긴 합니다.\n\n```kotlin {2,4}\n// main.kts\n@file:DependsOn(\"com.github.kittinunf.fuel:fuel:2.3.1\")\n\nimport com.github.kittinunf.fuel.httpGet\n\nval (request, response, result) = \n  \"https://httpbin.org/get\"\n    .httpGet()\n    .responseString()\nprintln(result.get())\n```\n\n코드를 보면 `DependsOn`을 통해 의존성을 설정할 수 있고 그 후에 스크립트를 실행하면 알아서 설치하고 실행하는 것을 볼 수 있다. Node.js의 package.json이나 Python의 requirements.txt처럼 외부로 빼지 않고 스크립트 내부에 기술한다는 점이 좀 색다르다. 실행 결과는 다음과 같다.\n\n```shell {2}\n$ kscript main.kts\n[kscript] Resolving com.github.kittinunf.fuel:fuel:2.3.1...\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\",\n    \"Host\": \"httpbin.org\",\n...\n```\n\n### 바이너리 패키징\n\nKScript를 이용하면 바이너리 패키징을 할 수 있다. 이를 통해 Kotlin이나 KScript가 없더라도 Java가 설치된 환경이라면 실행할 수 있게 배포할 수 있다. 바이너리 패키징을 하기 위해선 Gradle이 필요하다.\n\n```shell\n$ kscript --package main.kts # Need Gradle\n[kscript] Packaging script 'main' into standalone executable...\n[kscript] Packaged script 'main' available at path:\n[kscript] /Users/kciter/Library/Caches/kscript/package_07f1f85044b41284dee18d4f8c159650/build/libs/main\n$ /Users/kciter/Library/Caches/kscript/package_07f1f85044b41284dee18d4f8c159650/build/libs\n$ ./main # Need Java\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"Java/17.0.3\",\n    \"X-Amzn-Trace-Id\": \"Root=1-6676a491-5935eb22586d7aa550e76b8d\"\n  },\n  \"origin\": \"1.225.3.207\",\n  \"url\": \"https://httpbin.org/get\"\n}\n```\n\n단순히 `--package`라는 옵션 하나만 추가하면 알아서 바이너리로 만들어준다. 바이너리로 만들면 자바 실행 환경만 갖추면 되기 때문에 만약 내가 내부 툴을 조직에 배포하고 싶다면 거쳐야할 허들이 줄어든다고 볼 수 있다.\n\n### IntelliJ와 함께 사용하기\n\n`kscript --idea`를 사용하면 자동으로 IntelliJ에서 편집할 수 있게 구성해준다.\n\n<Image src=\"/images/2025-01-19-using-kotlin-script/autocomplete.png\" />\n\n이를 통해 자동 완성이나 오류를 IDE에서 볼 수 있다.\n\n### args 사용\n\nKScript를 이용하면 자동으로 args를 받아올 수 있다\n\n```kotlin\nprintln(args.joinToString(\", \"))\n```\n\n```bash\n$ kotlinc --script args.kts hi hello bye\n\n$ kscript args.kts hi hello bye\nhi, hello, bye\n```\n\n별도 라이브러리를 사용하고나 구현하지 않아도되니 간단한 스크립트를 만들때 편리하게 이용할 수 있다.\n\n## 사용 사례\n\n뭔가 본격적으로 터미널 애플리케이션을 만든다면 여러 오픈소스 라이브러리를 이용할 수 있다. 대표적으로 다음과 같은 라이브러리가 있다.\n\n* Clikt : https://github.com/ajalt/clikt\n* Mordant : https://github.com/ajalt/mordant\n\n먼저 Clikt는 사용자가 전달하는 옵션이나 입력을 쉽게 처리할 수 있게 해준다.\n\n```kotlin\n// ...\n\nclass Hello : CliktCommand() {\n  val count: Int by option(help=\"Number of greetings\").int().default(1)\n  val name: String by option(help=\"The person to greet\").prompt(\"Your name\")\n\n  override fun run() {\n    repeat(count) {\n      echo(\"Hello $name!\")\n    }\n  }\n}\n\nHello().main(args)\n```\n\n```bash\n$ kscript clikt.kts --count 3       \nYour name: kciter\nHello kciter!\nHello kciter!\nHello kciter!\n```\n\n코드를 보시다시피 입력 타입이나 사용자 입력인지, 옵션으로 전달되는지 디폴트 값이 있는지를 정의할 수 있다. 이 외에도 다양한 기능을 제공한다.\n\n다음으로 Mordant는 터미널에서 UI를 쉽게 그릴 수 있게 도와준다. DSL을 이용하므로 편리하다.\n\n```kotlin\nval table = table {\n  tableBorders = NONE\n  borderType = SQUARE_DOUBLE_SECTION_SEPARATOR\n  align = RIGHT\n  column(0) {\n    align = LEFT\n    style = magenta\n  }\n  column(3) {\n    style = magenta\n  }\n  header {\n    style = magenta\n    row(\"\", \"Projected Cost\", \"Actual Cost\", \"Difference\")\n  }\n  ...\n```\n\n```bash\n$ kscript ./table.kts \n\n          │ Projected Cost │ Actual Cost │ Difference \n══════════╪════════════════╧═════════════╪════════════\n Food     │           $400          $200 │       $200 \n──────────┼──────────────────────────────┼────────────\n Data     │           $100          $150 │       $-50 \n──────────┼──────────────────────────────┼────────────\n Rent     │           $800          $800 │         $0 \n──────────┼──────────────────────────────┼────────────\n Candles  │             $0        $3,600 │    $-3,600 \n──────────┼──────────────────────────────┼────────────\n Utility  │           $154          $150 │        $-5 \n══════════╪══════════════════════════════╧════════════\n Subtotal │                                  $-3,455  \n```\n\n백오피스를 개발한다면 CSV나 엑셀 파일을 자주 건들게 되는데, 이럴 때 데이터를 파싱해서 취합하거나 확인하는 용도로 사용할 수도 있다.\n\n## 결론은?\n\n일단 해볼 수 있는건 생각보다 많다.\n\n* 배포 자동화\n* 온보딩 툴\n* 데이터 전처리\n* 시드 데이터 추가\n* ...\n\n이외에도 요즘은 GPT와 연동하여 다양한걸 만들어 볼 수도 있을 것이다. 필자가 몇 가지 예제를 더 만들어 두었다 만약 궁금하다면 다음 링크를 살펴보자. https://github.com/kciter/kotlin-script-examples\n\n# 런타임 환경에서 스크립트 실행\n\n런타임 환경에서 Kotlin Script를 실행할 수 있는 방법은 **Java Scripting API**나 **Embeddable Host**를 사용하는 방법 두 가지가 있다. 그렇지만 사실 Java Scripting API가 내부적으론 Embeddable Host를 이용하기 때문에 같다고 볼 수 있다.\n\n런타임 환경에서 스크립트를 실행할 수 있으면 유용할 것 같지만 문제는 자료가 거의 없다! 그나마 튜토리얼과 예제 저장소가 유용하다.\n\n* https://kotlinlang.org/docs/custom-script-deps-tutorial.html\n* https://github.com/Kotlin/kotlin-script-examples\n\n## Java Scripting API (JSR-223)\n\nJava Scripting API는 스크립트 코드를 JVM 위에 동작하는 프로그램에서 실행할 수 있게 해준다. 인터페이스 API기 때문에 구현체만 있다면 어떠한 스크립트 언어라도 실행이 가능하다. 물론 Kotlin Script 구현체가 있기 때문에 Kotlin Script도 실행할 수 있다. 이를 위해 다음과 같이 의존성을 추가해야 한다.\n\n* `org.jetbrains.kotlin:kotlin-scripting-jsr223` 의존성 필수\n  * 라이브러리 이용이나 다른 스크립트 불러오기는 직접 구현해야함\n* `kotlin-main-kts`를 사용하는 경우 extension을 `main.kts`로 지정하면 알아서 다 해준다\n  * `org.jetbrains.kotlin:kotlin-main-kts` 추가 필요\n  * 의존성 관리, 다른 스크립트 불러오기 등 필요한 것들을 미리 다 구현해둠\n\n이후에 스크립트 실행은 다음과 같이 코드를 작성하여 실행할 수 있다.\n\n```kotlin\nimport javax.script.ScriptEngineManager\n\nfun main() {\n  val engine = ScriptEngineManager().getEngineByExtension(\"main.kts\")!!\n  engine.eval(\n    \"\"\"\n      val a = 2\n      val b = 3\n      println(\"a + b = ${'$'}{a + b}\")\n    \"\"\".trimIndent() // Output: a + b = 5\n  )\n}\n```\n\n코드가 생각보다 간단하다. 단순히 라이브러리 의존성만 추가해도 별도 설정없이 바로 사용이 가능하다. 물론 `kotlin-main-kts` 라이브러리까지 추가해서 총 2개 의존성을 추가해야 알아서 다 해준다고 볼 수 있다. \n\n스크립트 시작 전 미리 값을 넣어두는 것도 가능하다. 키-벨류로 값을 넣어주면 스크립트 실행시 변수로 사용 가능하다.\n\n```kotlin {5,6,9}\nimport javax.script.ScriptEngineManager\n\nfun main() {\n  val engine = ScriptEngineManager().getEngineByExtension(\"main.kts\")!!\n  engine.put(\"a\", 2)\n  engine.put(\"b\", 3)\n  engine.eval(\n    \"\"\"\n      println(\"a + b = ${'$'}{a + b}\")\n    \"\"\".trimIndent()\n  )\n}\n```\n\n## Embeddable Host\n\nEmbeddable Host는 Kotlin에서 직접 제공하는 내장 컴파일러를 이용하는 방식이다. 앞서 Java Scripting API도 사실 이걸 이용하고 있다고 말한 것처럼 결국 내부는 다 같다. 그런데 왜 굳이 둘로 분리하고 공식 홈페이지는 이 방식만 설명하는지는 잘 모르겠지만 추측해보면 추후 멀티플랫폼을 위함이 아닐까라고 생각한다.\n\n해당 방식은 구현하기 위해 Script Definition과 Scripting Host를 만들어야 한다. 코드가 좀 길어져서 이 글에서는 생략하고 넘어가겠다. 만약 궁금하다면 다음 공식 홈페이지 문서를 읽어보기를 바란다. https://kotlinlang.org/docs/custom-script-deps-tutorial.html\n\n## 무엇을 할 수 있을까?\n\n안타깝지만 Kotlin Script는 실험 단계이므로 프로덕션 환경에서 사용하기에는 무리가 있다. 그래도 몇 가지 실험적인 것을 해보는 것은 재미있을 수 있다. 다음으로 필자가 생각한 사용 사례 예시 두 가지를 살펴보자.\n\n### HTML Template\n\n`kotlinx.html` 라이브러리를 사용하면 HTML을 Kotlin DSL로 작성 가능하다. [ktor](https://ktor.io/)에선 이를 이용하여 템플릿을 만든다. 물론 결국 Kotlin DSL이므로 변경할 떄마다 다시 빌드를 해야한다는 단점이 있다. Auto Reload가 있긴하지만 그래도 약간의 시간이 필요하다.\n\n그런데 만약 Kotlin Script에서 해당 라이브러리를 사용한다면 별도 컴파일 타임 없이 템플릿 작성이 가능하지 않을까? 그런 마음으로 다음과 같이 코드를 작성해보았다.\n\n```kotlin\nimport javax.script.ScriptEngineManager\n\ndata class Params(val name: String)\n\nfun main() {\n  val engine = ScriptEngineManager().getEngineByExtension(\"main.kts\")!!\n  engine.put(\"params\", Params(\"Kotlin\"))\n  engine.eval(\"\"\"\n    @file:DependsOn(\"org.jetbrains.kotlinx:kotlinx-html-jvm:0.8.0\")\n    import kotlinx.html.*; import kotlinx.html.stream.*; import kotlinx.html.attributes.*\n    \n    createHTML().html {\n      body {\n        h1 { +\"Hello, ${\"$\"}{params.name}!\" }\n      }\n    }\"\"\".trimIndent()\n  )\n}\n```\n\n일단은 테스트했을 때 잘돌아간다. 만약 이를 외부 파일로 분리한다면 빌드 없이도 바로 반영할 수 있을 것이다. 그리고 HTML이 아니라 JSON, XML 등 다양한 포맷로도 사용할 수 있을 것이다. 이 정도면 Kotlin Script가 Stable 상태가 됐을 때 고도화 시키는 것도 괜찮지 않을까?\n\n## Ruby Warrior\n\n이전에 유명했던 오픈소스 게임으로 Ruby Warrior라는 것이 있다. Ruby Warrior는 게임을 하는 사람이 Ruby 코드를 넣어 캐릭터를 조작하고 퍼즐을 클리어하는 게임이다.\n\n<Image src=\"/images/2025-01-19-using-kotlin-script/ruby-warrior.webp\" />\n\nRuby나 Python, Node.js같은 여러 언어에서 구현이 됐지만 스크립트가 아닌 언어는 구현체가 거의 없다. 왜냐하면 스크립트 언어는 eval이 가능하니 구현이 편리하지만 컴파일을 하는 언어는 별도로 컴파일하고 결과를 출력하는 복잡한 과정이 필요하다. 하지만 Kotlin은 Kotlin Script가 있으므로 상대적으로 쉽게 구현이 가능할 것이다.\n\n이처럼 런타임 중 사용자에게 직접 코드를 받아 실행하는 경우 Kotlin Script를 사용하면 편리할 것이다. 물론 이런 경우는 거의 없고 보안 문제가 있을 수 있으니 주의할 필요는 있다.\n\n필자는 이를 구현해보려 했으나 시간이 부족하여 아직 완성하지 못했다. 빠른 시일 내에 완성해서 공개해보려고 한다.\n\n# 마치며\n\n결론적으로 실험 단계지만 쓰려면 잘 쓸 수 있을 것 같다는 생각이 들었다. 하지만 여러모로 아직 부족하다. 특별하게 우위에 있는 부분이 없기 때문에 다른 스크립트 언어를 대체할 수 있냐고하면 확실하게 그렇다고는 말할 수 없다.\n\n그럼에도 불구하고 Spring 서버 팀이나 안드로이드 팀 등 Kotlin을 주력으로 쓰는 팀이라면 이용해 볼만한 가치는 있다고 생각한다. 다만 Embedded Scripting은 실제 제품에 이용하기엔 위험하므로 사용하지 않는 것이 좋다. 추후 빌드 시간이 너무 오래걸리는 경우 스크립트로 외부화하는 경우도 있을수는 있겠지만 아직은 좀 먼 이야기 같다.\n\n그래서 결론은 **팀 내부에서 쓰는 스크립트를 만들 때 이용해보면 어떨까?** 정도로 생각하면 좋을 것 같다.","tableOfContents":{"items":[{"url":"#kotlin-script-개념","title":"Kotlin Script 개념"},{"url":"#어디에-쓸-수-있을까","title":"어디에 쓸 수 있을까?"},{"url":"#cli-환경에서-스크립트-실행","title":"CLI 환경에서 스크립트 실행","items":[{"url":"#설치-및-실행","title":"설치 및 실행"},{"url":"#kscript","title":"KScript","items":[{"url":"#외부-라이브러리-사용","title":"외부 라이브러리 사용"},{"url":"#바이너리-패키징","title":"바이너리 패키징"},{"url":"#intellij와-함께-사용하기","title":"IntelliJ와 함께 사용하기"},{"url":"#args-사용","title":"args 사용"}]},{"url":"#사용-사례","title":"사용 사례"},{"url":"#결론은","title":"결론은?"}]},{"url":"#런타임-환경에서-스크립트-실행","title":"런타임 환경에서 스크립트 실행","items":[{"url":"#java-scripting-api-jsr-223","title":"Java Scripting API (JSR-223)"},{"url":"#embeddable-host","title":"Embeddable Host"},{"url":"#무엇을-할-수-있을까","title":"무엇을 할 수 있을까?","items":[{"url":"#html-template","title":"HTML Template"}]},{"url":"#ruby-warrior","title":"Ruby Warrior"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"현대적인 언어 중 하나인 Kotlin은 JetBrains에서 만든 언어로, Java와 100% 호환되는 언어이다. 그렇기 때문에 Kotlin은 Android 개발에서도 사용되고 있으며, 서버 개발에서도 사용되고 있다. JVM 생태계 뿐만 아니라…","fields":{"slug":"/posts/using-kotlin-script","date":"2025-01-19"},"frontmatter":{"title":"Kotlin Script 활용하기","categories":"article","tags":["kotlin","script"],"image":"/images/2025-01-19-using-kotlin-script/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-26","slug":"/posts/how-to-build-an-agent"},"frontmatter":{"title":"AI 에이전트를 만드는 방법","image":"/images/2025-04-26-how-to-build-an-agent/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-06","slug":"/posts/modeling-series-temporal"},"frontmatter":{"title":"모델링 시리즈: 시간","image":"/images/2025-05-06-modeling-series-temporal/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-02","slug":"/posts/modeling-series-measure"},"frontmatter":{"title":"모델링 시리즈: 측도","image":"/images/2025-05-02-modeling-series-measure/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/using-kotlin-script","frontmatter":{"title":"Kotlin Script 활용하기","categories":"article","tags":["kotlin","script"],"image":"/images/2025-01-19-using-kotlin-script/thumbnail.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}