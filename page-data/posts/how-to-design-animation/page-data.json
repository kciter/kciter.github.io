{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2026-02-18-how-to-design-animation-mdx","path":"/posts/how-to-design-animation/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\nimport { FadeInGraphDemo, BounceGraphDemo, EasingVisualizer, EasingPracticeDemo, Atan2Demo, CardTiltDemo, TrigWaveDemo, PulseBadgeDemo, FloatingHeroDemo, LoadingIndicatorDemo, ExponentialApproachDemo, ExpApproachGraphDemo, CounterDemo, ProgressBarDemo, SpringPlayground, SpringLikeDemo, ConfettiDemo, FireworkDemo, PipelineDemo, PropertySplitDemo, RandomComparisonDemo, BidirectionalDemo, PipelineTimelineDemo, FireworkStateDiagram, PropertySplitTimelineDemo, BidirectionalCompareDemo } from '@materials/how-to-design-animation';\n\n# 들어가며\n\n웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 버튼을 누르면 부드럽게 전환되는 화면, 스크롤에 반응하며 나타나는 요소들, 로딩을 기다리는 동안의 재치 있는 움직임과 같은 애니메이션은 재미를 더할 뿐 아니라, 사용자의 이해를 돕고, 인터랙션의 결과를 명확히 전달하며, 브랜드의 개성을 표현하는 중요한 역할을 한다.\n\n그런데 이런 애니메이션을 직접 만들어야 하는 순간이 오면 이야기가 달라진다. 디자이너가 건네준 프로토타입 영상을 보며 \"이걸 어떻게 구현하지?\"라고 막막해한 경험이 한 번쯤은 있을 것이다. 혹은 머릿속에 그려지는 움직임은 있지만 코드로 옮기려니 어디서부터 손을 대야 할지 모를 때도 있다.\n\n핵심은 애니메이션도 **설계**할 수 있다는 것이다. 복잡해 보이는 움직임도 잘게 쪼개면 단순한 상태 변화의 조합이고, 각각의 상태 변화는 수학적으로 표현할 수 있다. 이 글에서는 애니메이션을 체계적으로 분해하고 설계하는 방법을 다룰 것이다.\n\n# 애니메이션은 그래프다\n\n무언가를 \"설계\"하려면 두 가지 필요한 조건이 있다. **재현할 수 있어야** 하고, **조합할 수 있어야** 한다. 머릿속의 감각에 의존하면 같은 움직임을 다시 만들기 어렵고, 여러 움직임을 체계적으로 엮기도 어렵다. 따라서 움직임을 공학적으로 나타내는 방법이 필요하며, 이를 위해 **그래프**를 이용할 수 있다. 모든 애니메이션은 그래프로 표현할 수 있다. 이 관점을 갖게 되면 복잡한 움직임도 체계적으로 분석하고 만들어낼 수 있게 된다.\n\n요소의 투명도가 0에서 1로 변하는 페이드인 애니메이션을 생각해보자. 이것을 그래프로 그리면 가로축은 시간, 세로축은 투명도가 된다. 예를 들면, 0초에서 시작해 2초에 끝나는 동안 투명도 값이 0에서 1로 올라가는 그래프를 그려 볼 수 있다.\n\n<FadeInGraphDemo />\n\n이동 애니메이션도 마찬가지다. 왼쪽에서 오른쪽으로 움직이는 요소는 시간-위치 그래프로 나타낼 수 있고, 크기가 커지는 애니메이션은 시간-스케일 그래프가 된다. 가로축이 꼭 시간일 필요도 없다. 스크롤 위치에 따라 요소가 나타나는 패럴랙스 효과는 스크롤 오프셋이 가로축이 된다. 어떤 애니메이션이든 결국 **어떤 입력에 따라 값이 변하는 것**이고, 이 변화를 그래프로 그릴 수 있다.\n\n여기서 중요한 것은 그래프의 **모양**이 곧 움직임의 **느낌**을 결정한다는 점이다. 같은 시작점과 끝점이라도 곡선의 형태에 따라 전혀 다른 인상을 줄 수 있다. 이 곡선을 원하는 대로 만들어내는 것이 애니메이션 설계의 핵심이며, 그 도구가 되는 것이 수학이다.\n\n# 애니메이션을 위한 도구, 수학\n\n그렇다면 원하는 모양의 그래프를 어떻게 만들 수 있을까? 여기서 수학이 등장한다. 이 섹션에서는 애니메이션에서 자주 쓰이는 수학적 도구들을 살펴보고 그것들이 어떻게 그래프의 형태를 조절하는지 알아볼 것이다. 수학이 낯설게 느껴질 수도 있지만 걱정할 필요 없다. 핵심은 수학적 개념을 이해하는 것이 아니라 애니메이션의 느낌에 어떤 영향을 주는지 파악하는 것이다.\n\n## 이징과 베지어 커브\n\n가장 단순한 애니메이션은 선형<sup>linear</sup>이다. 시작점에서 끝점까지 일정한 속도로 변한다. 하지만 현실 세계의 움직임은 선형이 아니다. 공을 던지면 처음에 빠르다가 점점 느려지고, 자동차는 출발할 때 천천히 시작해서 속도를 높인다. 이런 자연스러운 가감속을 표현하는 것이 **이징**<sup>easing</sup> 함수다.\n\n이징 함수는 0에서 1 사이의 진행률을 입력받아, 변환된 진행률을 출력한다. `ease-in`은 느리게 시작해서 빠르게 끝나고, `ease-out`은 빠르게 시작해서 느리게 끝난다. 이것을 수학적으로 표현하는 가장 널리 쓰이는 방법이 **큐빅 베지어 커브**<sup>cubic bezier curve</sup>다.\n\n큐빅 베지어 커브는 네 개의 제어점으로 곡선을 정의한다. 이징에서는 시작점 (0, 0)과 끝점 (1, 1)이 고정이므로, 실질적으로 두 개의 제어점 (x1, y1)과 (x2, y2)만 조절하면 된다. 제어점은 곡선이 지나가는 점이 아니라, 곡선을 **끌어당기는** 점이다. 마치 자석처럼 곡선의 경로에 영향을 준다.\n\n그렇다면 제어점으로부터 곡선이 어떻게 만들어질까? 핵심은 **선형 보간**<sup>linear interpolation</sup>**의 재귀적 적용**이다. 두 점 사이의 선형 보간은 단순하다. 진행률 `t`가 0이면 시작점, 1이면 끝점, 0.5면 정확히 중간점이다.\n\n```js\nfunction lerp(a, b, t) {\n  return a + (b - a) * t;\n}\n```\n\n베지어 커브는 이 보간을 여러 단계에 걸쳐 반복한다. 네 개의 제어점 P0, P1, P2, P3이 있다고 하자.\n\n1. P0-P1, P1-P2, P2-P3 사이를 각각 `t`만큼 보간하여 세 개의 중간점을 얻는다\n2. 그 세 중간점 사이를 다시 `t`만큼 보간하여 두 개의 점을 얻는다\n3. 마지막 두 점 사이를 `t`만큼 보간하면 최종 곡선 위의 한 점이 나온다\n\n이것을 드 카스텔조<sup>De Casteljau</sup> 알고리즘이라 부른다. `t`를 0에서 1까지 변화시키며 이 과정을 반복하면 부드러운 곡선이 그려진다. 결국 베지어 커브는 \"직선 보간을 반복하면 곡선이 된다\"는 단순한 아이디어 위에 세워져 있다.\n\n이 방식은 꽤나 강력한데 두 개의 제어점만으로 매우 다양한 움직임을 만들어낼 수 있기 때문이다. 그 중에서 대표적으로 많이 사용되는 제어점 조합 몇 가지를 살펴보자.\n\n- (0.25, 0.1), (0.25, 1.0) — 부드럽게 시작하고 끝남. 가장 범용적인 이징\n- (0.42, 0), (1, 1) — ease-in. 느리게 시작해서 빠르게 끝남\n- (0, 0), (0.58, 1) — ease-out. 빠르게 시작해서 느리게 끝남\n- (0.68, -0.55), (0.27, 1.55) — y값이 0~1 범위를 벗어나면 overshoot 효과. 목표를 지나쳤다 돌아옴\n\n실제 움직임을 예제로 살펴보면 다음과 같다.\n\n<EasingVisualizer />\n\n이징을 실전에서 어떻게 선택할까? 토스트 알림이 화면 아래에서 올라오는 애니메이션을 예로 들어보자.\n\n`ease-out`을 적용하면 토스트가 빠르게 나타나 사용자의 주의를 끌고, 최종 위치에서 부드럽게 감속하며 안착한다. 반면 `ease-in`을 적용하면 천천히 시작해서 점점 빨라지는데, 등장이 느긋해서 덜 눈에 띈다. `linear`는 일정한 속도로 올라오다 갑자기 멈추기 때문에 기계적인 느낌을 준다.\n\n같은 요소, 같은 움직임이지만 이징에 따라 전달하는 인상이 완전히 달라진다. 어떤 이징이 \"정답\"인 것은 아니다. 중요한 것은 **그 움직임이 어떤 목적을 가지는가**다. 사용자의 시선을 빠르게 끌어야 한다면 초반이 빠른 커브를, 조용히 사라져야 한다면 후반이 빠른 커브를 선택할 수 있다. 아래 데모에서 같은 토스트에 서로 다른 이징을 적용했을 때 인상이 어떻게 달라지는지 비교해보자.\n\n<EasingPracticeDemo />\n\n베지어 커브의 원리를 이해하면 도구에 의존하지 않고도 원하는 움직임을 직접 설계할 수 있다. \"처음에 빠르게 튀어나왔다가 천천히 안착하는 느낌\"이 필요하면 첫 번째 제어점의 y값을 크게, 두 번째 제어점을 (1, 1) 근처에 두면 된다. 그래프의 모양을 먼저 그린 뒤, 그에 맞는 제어점을 찾아가는 것이다.\n\n## 지수적 접근\n\n이징은 시작과 끝이 정해진 곡선이다. 하지만 목표값이 도중에 바뀔 수 있는 상황에서는 어떨까? 커서를 따라다니는 요소처럼 목표가 매 프레임 달라진다면, 미리 정해진 곡선으로는 대응하기 어렵다. 이때 유용한 패턴이 **지수적 접근**<sup>exponential approach</sup>이다.\n\n```js\nvalue += (target - value) * factor; // factor: 0~1\n```\n\n코드는 놀라울 정도로 단순하다. 매 프레임마다 현재 값과 목표 값의 **차이에 비례하는 만큼**만 이동한다. 목표에서 멀면 크게 움직이고, 가까우면 조금 움직인다. 그 결과 빠르게 접근하다가 점점 느려지는, 자연스러운 감속 곡선이 만들어진다.\n\n<ExpApproachGraphDemo />\n\n`factor`가 작으면 천천히 다가가고, 크면 빠르게 다가간다. 수학적으로 이것은 **지수 감쇠**<sup>exponential decay</sup>다. 차이가 매 프레임 `(1 - factor)` 비율로 줄어들기 때문에, 남은 거리가 지수적으로 감소한다.\n\n<ExponentialApproachDemo />\n\n위치뿐 아니라 모든 종류의 값에 동일하게 적용할 수 있다. 대시보드의 카운터가 목표 수치를 향해 빠르게 올라가다 점점 느려지며 안착하는 효과도 같은 원리다.\n\n<CounterDemo />\n\n프로그레스 바도 마찬가지다. 실제 진행률은 네트워크 상황에 따라 뚝뚝 끊기지만, 표시되는 바가 지수적 접근으로 목표를 쫓아가면 사용자에게는 부드러운 진행으로 보인다.\n\n<ProgressBarDemo />\n\n지수적 접근의 장점은 **목표가 바뀌어도 자연스럽다**는 것이다. 커서가 갑자기 반대편으로 이동해도, 현재 위치에서부터 새 목표를 향해 부드럽게 방향을 전환한다. 별도의 전환 로직이 필요 없다.\n\n## 스프링 애니메이션\n\n이징과 지수적 접근은 목표에 단조롭게 수렴한다. 하지만 현실의 물체에는 관성이 있다. 목표를 살짝 지나쳤다가 되돌아오고, 그 탄성이 움직임에 생동감을 더한다. 버튼을 눌렀을 때의 탄력적인 피드백, 드래그한 요소가 원래 자리로 튕겨 돌아오는 느낌을 주고 싶다면 **스프링 애니메이션**을 사용할 수 있다.\n\n스프링 애니메이션은 물리의 **감쇠 진동**<sup>damped harmonic oscillation</sup>을 기반으로 한다. 용수철에 매달린 물체를 생각하면 된다. 물체를 잡아당겼다 놓으면 원래 위치를 중심으로 진동하고 마찰에 의해 점점 진폭이 줄어들면서 결국 멈춘다.\n\n기반이 되는 원리는 두 가지 힘이다.\n\n- **복원력**: 현재 위치가 목표에서 멀수록 강하게 잡아당긴다. `F = -k × (현재 - 목표)`. 여기서 `k`는 **강성**<sup>stiffness</sup>이다.\n- **감쇠력**: 속도에 비례하여 움직임을 억제한다. `F = -c × 속도`. 여기서 `c`는 **감쇠 계수**<sup>damping</sup>이다.\n\n매 프레임마다 이 두 힘을 합산해 가속도를 구하고, 가속도로 속도를 갱신하고, 속도로 위치를 갱신한다. 코드로 표현하면 다음과 같다.\n\n```js\nconst force = -stiffness * (current - target) - damping * velocity;\nvelocity += force * dt;\ncurrent += velocity * dt;\n```\n\n<SpringPlayground />\n\n스프링의 느낌은 `stiffness`와 `damping` 두 값으로 결정된다. 강성이 높으면 팽팽하고 빠르게 반응하며, 감쇠가 낮으면 더 오래 진동한다. 이 두 파라미터를 조절하는 것만으로 \"톡 튕기는 버튼\"부터 \"부드럽게 안착하는 카드\"까지 다양한 느낌을 만들어낼 수 있다.\n\n좋아요 버튼을 예로 들어보자. 하트를 누르는 순간 스케일이 순간적으로 작아졌다가 목표(원래 크기)를 향해 튕겨 올라온다. 이때 스프링의 오버슛 덕분에 목표를 살짝 넘었다 돌아오며 \"눌렀다\"는 촉각적 피드백을 만든다.\n\n<SpringLikeDemo />\n\n스프링 애니메이션이 이징 기반 애니메이션과 근본적으로 다른 점은 **duration이 없다**는 것이다. 이징은 \"0.3초 동안\" 같은 고정 시간이 있지만, 스프링은 물리 시뮬레이션이 수렴할 때까지 계속된다. 그리고 또 다른 점은 목표값이 중간에 바뀌면 현재 속도를 유지한 채 새 목표를 향해 자연스럽게 전환된다는 점이다.\n\n## 물리 시뮬레이션\n\n스프링은 하나의 값이 목표를 향해 진동하는 시스템이었다. 하지만 물리를 더 넓게 적용할 수 있다. 중력, 충돌, 마찰, 관성과 같은 물리 법칙들을 조합하면 직접 설계하기 어려운 복잡한 움직임을 자연스럽게 만들어낼 수 있다.\n\n물리 시뮬레이션의 기본 구조는 단순하다. 매 프레임마다 세 단계를 반복한다.\n\n1. **힘 계산**: 각 오브젝트에 작용하는 힘들을 합산한다 (중력, 스프링, 마찰, 사용자 입력 등)\n2. **적분**: 힘으로부터 가속도를, 가속도로부터 속도를, 속도로부터 위치를 갱신한다\n3. **제약 처리**: 충돌 감지, 경계 제한, 연결 관계 등의 제약 조건을 적용한다\n\n```js\nfor (const obj of objects) {\n  // 1. 힘 계산\n  const gravity = { x: 0, y: 9.8 * obj.mass };\n  const friction = { x: -obj.vx * drag, y: -obj.vy * drag };\n  const fx = gravity.x + friction.x;\n  const fy = gravity.y + friction.y;\n\n  // 2. 적분\n  obj.vx += (fx / obj.mass) * dt;\n  obj.vy += (fy / obj.mass) * dt;\n  obj.x += obj.vx * dt;\n  obj.y += obj.vy * dt;\n\n  // 3. 제약 처리 (바닥 충돌)\n  if (obj.y > floorY) {\n    obj.y = floorY;\n    obj.vy *= -restitution; // 반발 계수만큼 튕김\n  }\n}\n```\n\n이 구조가 강력한 이유는 **규칙만 정의하면 움직임은 알아서 만들어진다**는 점이다. 컨페티를 예로 들어보자. 각 조각의 궤적을 이징 함수로 일일이 설계하려면 비현실적이다. 하지만 중력과 공기 저항, 회전만 설정하면 수십 개의 조각이 각자 다른 궤적을 그리며 떨어진다. 개별 궤적을 신경 쓸 필요가 없다.\n\n<ConfettiDemo />\n\n이런 점에서 물리 시뮬레이션은 **다수의 오브젝트가 상호작용**하거나, **사용자 입력에 따라 결과가 달라지는** 상황에서 유용하다. 드래그한 세기에 따라 날아가는 거리가 달라지거나, 터치 속도에 따라 스크롤 관성이 달라지는 것처럼 입력에 비례하는 물리적 반응이 필요할 때, 규칙 기반 접근이 빛을 발한다.\n\n다만 물리 시뮬레이션은 **예측 가능성이 떨어진다**는 단점이 있다. 이징 기반 애니메이션은 언제 어떤 위치에 있을지 정확히 알 수 있지만, 물리 시뮬레이션은 초기 조건에 따라 결과가 달라진다. 따라서 UI의 핵심 전환 애니메이션보다는 보조적인 효과나 인터랙티브 요소에 더 적합한 경우가 많다.\n\n## 자연스러운 방향 전환\n\n지금까지는 값이 목표를 향해 **얼마나** 변하는지를 다뤘다. 이번에는 **어느 방향으로** 변하는지를 다룰 것이다. 화면 위에서 요소가 커서를 따라다니는 애니메이션을 만든다고 하자. 위치를 따라가는 것은 어렵지 않다. 하지만 요소가 이동 방향을 바라보도록 **회전**까지 시키려면 어떻게 해야 할까?\n\n이때 필요한 것이 `atan2` 함수다. `atan2(dy, dx)`는 두 점 사이의 각도를 라디안으로 반환한다. 현재 위치와 목표 위치의 차이 `(dx, dy)`를 넣으면, 요소가 바라봐야 할 방향이 나온다.\n\n```js\nconst dx = targetX - currentX;\nconst dy = targetY - currentY;\nconst angle = Math.atan2(dy, dx);\nelement.style.transform = `rotate(${angle}rad)`;\n```\n\n단순하지만 이것만으로도 움직임의 자연스러움이 크게 달라진다. 화살표가 이동 방향을 바라보거나, 캐릭터가 목적지를 향해 고개를 돌리거나, 파티클이 퍼져나가는 방향으로 늘어나는 효과 모두 `atan2`가 핵심이다.\n\n<Atan2Demo />\n\n`atan2`의 실전 활용 사례를 하나 보자. 카드 UI 위에서 마우스를 움직이면 카드가 커서 방향으로 기우는 3D 틸트 효과다. `atan2`로 커서의 **방향**을, 중심으로부터의 거리로 기울기의 **강도**를 구한다.\n\n<CardTiltDemo />\n\n이처럼 두 점 사이의 방향을 구할 수 있으면 표현할 수 있는 애니메이션의 폭이 크게 넓어진다.\n\n## 삼각함수로 만드는 주기적 움직임\n\n우리가 중학교 때 배운 삼각함수는 애니메이션에서 매우 넓은 쓰임새를 가진다. 핵심 특성은 **주기성**이다. 값이 -1에서 1 사이를 끝없이 반복하기 때문에, 반복되는 움직임을 만드는 데 최적의 도구다.\n\n하나의 `sin` 함수와 위상 오프셋만으로 수십 개 요소의 협응적인 움직임이 만들어진다. 로딩 인디케이터, 이퀄라이저 바, 물결 효과 등 주기적이면서 군무처럼 보이는 애니메이션 대부분이 이 원리 위에 있다.\n\n```js\nconst y = amplitude * Math.sin(time * frequency);\n```\n\n`sin`이나 `cos` 함수에 세 개의 파라미터를 조절하면 원하는 모양의 반복을 만들 수 있다.\n\n- **진폭**<sup>amplitude</sup>: 움직임의 크기. 값이 클수록 넓게 흔들린다\n- **주파수**<sup>frequency</sup>: 움직임의 빠르기. 값이 클수록 빠르게 반복한다\n- **위상**<sup>phase</sup>: 시작 지점의 오프셋. 여러 요소에 서로 다른 위상을 주면 파동 효과가 만들어진다\n\n삼각함수가 특히 강력한 순간은 **여러 요소에 위상 차이를 줄 때**다. 예를 들어, 리스트의 각 아이템에 인덱스에 비례하는 위상을 주면 파도처럼 차례로 움직이는 효과가 된다.\n\n```js\nitems.forEach((item, i) => {\n  const y = amplitude * Math.sin(time * frequency + i * phaseOffset);\n  item.style.transform = `translateY(${y}px)`;\n});\n```\n\n<TrigWaveDemo />\n\n실전에서는 메신저의 타이핑 인디케이터가 대표적이다. 세 개의 점이 차례로 튀어오르는 이 효과는 동일한 `sin`에 위상만 다르게 준 것이다.\n\n<LoadingIndicatorDemo />\n\n랜딩 페이지에서 흔히 보이는 플로팅 효과도 삼각함수를 이용해 만들 수 있다. 각 요소마다 서로 다른 진폭, 주파수, 위상을 주면 동일한 `sin` 함수 하나로 자연스러운 배경이 만들어진다.\n\n<FloatingHeroDemo />\n\n## 톱니파\n\n`sin`은 값이 올라갔다 내려오는 **왕복** 운동에 적합하다. 하지만 모든 반복이 왕복인 것은 아니다. 알림 배지의 펄스 링처럼 값이 0에서 1로 **한 방향**으로 진행한 뒤 처음으로 돌아가 다시 시작하는 패턴도 있다. 이것을 **톱니파**<sup>sawtooth wave</sup>라고 부른다.\n\n```js\nconst p = (t % period) / period; // 항상 0~1, 주기마다 리셋\n```\n\n`t`를 `period`로 나눈 나머지를 구하면, 값은 0에서 1까지 선형으로 올라갔다가 즉시 0으로 떨어진다. 이 `p`를 스케일이나 투명도에 매핑하면 \"퍼지면서 사라지는\" 반복 효과가 만들어진다.\n\n```js\nconst scale = 1 + p * 0.8;   // 1 → 1.8로 커짐\nconst opacity = 1 - p;        // 1 → 0으로 사라짐\n```\n\n<PulseBadgeDemo />\n\n톱니파는 \"시작 → 끝 → 즉시 리셋\"이라는 단순한 구조 덕분에 펄스, 핑, 반복 프로그레스 같은 패턴에 널리 쓰인다. `sin`의 부드러운 왕복과 톱니파의 단방향 리셋 두 가지만으로도 대부분의 주기적 애니메이션을 표현할 수 있다.\n\n# 애니메이션 설계하기\n\n지금까지 이징, 스프링, 삼각함수 같은 수학 도구를 살펴봤다. 하나의 도구로 해결되는 경우도 있지만, 현실의 애니메이션은 대부분 더 복잡하다. 예를 들어, 알림이 나타날 때 배경이 어두워지면서 카드가 올라오고, 내용이 드러나도록 만들고 싶다면 어떻게 해야할까?\n\n복잡한 애니메이션을 설계하려면 먼저 두 가지를 이해해야 한다. 그래프를 어떻게 쪼개는지, 그리고 애니메이션의 상태가 무엇에 의존하는지다.\n\n## 그래프를 나눠라\n\n복잡한 움직임은 하나의 수식으로 표현하기 어렵다. 이럴 때는 그래프를 **구간별로 쪼개는** 방법을 사용할 수 있다.\n\n예를 들어, 지도 앱에서 핀이 제자리에서 통통 튀다 안착하는 애니메이션을 생각해보자. 물리 시뮬레이션으로도 비슷한 결과를 낼 수 있지만 자연스러운 움직임이 항상 좋은 애니메이션은 아니다. 두 번째 바운스의 높이를 의도적으로 줄이거나, 마지막 안착을 더 부드럽게 만들고 싶을 수 있다. 이럴 때 구간을 나누면 이런 세밀한 조정이 가능해진다. 각 구간은 단순한 그래프 조각이고 이들을 이어 붙이면 전체 애니메이션이 완성된다.\n\n<BounceGraphDemo />\n\n이러한 그래프는 수학에서 구간별 함수<sup>piecewise function</sup>라 부르는 것과 같은 원리다. **복잡한 움직임을 단순한 조각으로 나누고 각 조각을 개별적으로 설계한 뒤 다시 이어 붙이는 것**이다.\n\n## 무엇에 의존하는가\n\n그래프의 가로축이 꼭 시간일 필요는 없다. 이 부분을 좀 더 구체적으로 살펴보자. 애니메이션의 값이 **무엇에 의존하는가**를 파악하는 것은 설계의 출발점이다. 대표적으로 세 가지 유형이 있다.\n\n**시간 기반** 애니메이션은 가장 흔한 형태다. 시작 시점부터 시간이 흘러감에 따라 값이 변한다. 이전 상태에 시간 변화를 적용해 다음 상태를 만들어내는 것으로, `f(state, Δt) → nextState` 형태로 표현할 수 있다. 매 프레임마다 이 함수를 반복 적용하면 애니메이션이 진행된다.\n\n**값 기반** 애니메이션은 시간이 아닌 특정 값이 입력이 된다. 대표적인 예가 스크롤 기반 패럴랙스 효과다. 사용자가 스크롤을 내리는 만큼 요소의 위치나 투명도가 변한다. 스크롤 오프셋이 그래프의 가로축이 되는 셈이다. 마우스 위치, 센서 데이터 등 다양한 값이 가로축이 될 수 있다.\n\n**이벤트 기반** 애니메이션은 특정 트리거에 의해 값이 전환된다. 호버, 클릭, 데이터 로딩 완료 같은 이벤트가 발생하면 현재 값에서 다음 값으로의 전환 애니메이션이 시작된다. 이 경우 애니메이션은 이벤트에 의해 **촉발**되고, 전환 과정 자체는 시간 기반으로 동작하는 혼합 형태가 많다.\n\n어떤 애니메이션을 설계할 때 가장 먼저 물어야 할 질문은 \"이 애니메이션의 값은 무엇에 의존하는가?\"이다. 이 질문에 답하면 그래프의 가로축이 정해지고 거기에 맞는 구현 방식을 선택할 수 있다.\n\n그래프를 쪼개는 법과 값의 의존성을 파악했다면 이제 조각들을 **조립**할 차례다. 조립 방식에 따라 세 가지 패턴이 있다.\n\n## 파이프라이닝\n\n가장 직관적인 조립 방법은 조각들을 **순서대로 나란히 놓는** 것이다. 이를 **파이프라이닝**이라 한다. 예를 들어, 알림이 나타나는 애니메이션을 설계한다면 다음과 같이 세 조각이 나온다.\n\n1. 배경 어두워짐 — opacity 0 → 0.5, 200ms\n2. 카드 올라옴 — 위치 아래 → 제자리, 300ms, ease-out\n3. 내용 드러남 — opacity 0 → 1, 200ms\n\n각 조각은 독립적인 그래프지만 시간축 위에 순서대로 배치하면 파이프라인이 된다.\n\n<PipelineTimelineDemo />\n\n배치 전략은 다양하다. 반드시 이전 조각이 끝난 뒤에 시작할 필요는 없다.\n\n- **순차**: A가 끝나면 B 시작\n- **겹침**: A의 80% 지점에서 B 시작. 조각 사이 끊김이 줄어든다\n- **동시**: A와 B가 동시에 시작하되, 서로 다른 속성을 변화시킨다\n- **스태거**: 같은 애니메이션을 여러 요소에 시간차를 두고 적용한다. 리스트 아이템이 하나씩 나타나는 것이 대표적이다\n\n파이프라이닝의 장점은 **각 조각을 독립적으로 수정할 수 있다**는 것이다. 카드가 올라오는 속도가 너무 빠르면 그 조각만 수정하면 된다. 전체 애니메이션을 처음부터 다시 설계할 필요가 없다.\n\n<PipelineDemo />\n\n## 상태 전환으로 설계하기\n\n파이프라이닝이 어떠한 축을 기준으로 순서대로 배치하는 것이라면, **상태 전환은 조건에 따라 다음 단계로 넘어가는 방식**이다. 하나의 요소가 중간에 성격이 완전히 달라지는 여러 단계를 거칠 때 적합하다.\n\n폭죽 애니메이션을 설계해보자. 하나의 파티클이 다음 상태를 거친다.\n\n| 상태 | 변하는 것 | 그래프 | 전환 조건 |\n|------|----------|--------|---------|\n| 발사 | 높이 ↑ | 가속 (ease-in) | 속도 = 0 → 폭발 |\n| 폭발 | 파티클 분리 | 순간 전환 | 즉시 → 확산 |\n| 확산 | 반경 ↑, 속도 ↓ | 감속 + 중력 | 시간 경과 → 소멸 |\n| 소멸 | opacity ↓ | 선형 감소 | opacity = 0 → 제거 |\n\n각 상태는 서로 다른 그래프를 가진다. 발사는 시간-높이, 확산은 시간-반경, 소멸은 시간-투명도다. 하나의 수식으로 표현하기는 어렵지만 상태별로 끊으면 각 조각은 단순하다.\n\n핵심은 **전환 조건을 명확히 정의하는 것**이다. \"속도가 0이 되면 폭발\", \"투명도가 0이 되면 제거\"처럼 다음 상태로 넘어가는 트리거를 명시하면 복잡한 애니메이션도 상태 머신처럼 관리할 수 있다. 따라서 다음과 같이 다이어그램으로 표현할 수도 있다.\n\n<FireworkStateDiagram />\n\n파이프라이닝과의 차이는 <strong>언제가 아니라 어떤 조건에서</strong>가 중심이라는 점이다. 시간이 아닌 상태 값에 의해 전환이 결정되므로, 물리 시뮬레이션이나 사용자 인터랙션처럼 결과를 미리 예측하기 어려운 상황에서 자연스럽게 들어맞는다.\n\n<FireworkDemo />\n\n## 속성 분리\n\n간혹 여러 속성이 동시에 변화해야 할 때도 있다. 이런 경우에는 **여러 속성을 독립적인 트랙으로 분리**하는 것이 좋다.\n\n요금제 카드를 클릭해서 선택하는 UI를 예로 들어보자. 카드를 클릭하면 선택했음을 알리기 위해 테두리가 파란색으로 바꿀 필요가 있다. 그리고 강조를 위해 카드를 살짝 커지게 만들 필요도 있다. 더불어 사용자가 관심을 가지는 상세 내용이 드러나도록 묘사할 필요도 있다. 세 가지 변화가 동시에 일어나지만 각각 필요로 하는 움직임의 성격은 다를 것이다.\n\n이들을 하나의 수식으로 묶으면 각각의 요구를 충족할 수 없다. 대신 각 속성을 독립적인 트랙으로 분리하면 된다. 다음 예제를 확인해보자.\n\n<PropertySplitDemo />\n\n속성 분리의 핵심은 **각 트랙이 서로를 몰라도 된다는 것**이다. 테두리 트랙을 수정해도 크기나 상세 내용에 영향이 없다. 이 독립성 덕분에 하나의 속성만 미세 조정하거나 새 속성을 추가하는 것이 쉬워진다.\n\n## 랜덤성\n\n앞서 상태 전환 부분에서 폭죽 예제를 살펴보았다. 만약 모든 파티클이 정확히 같은 속도, 같은 각도 간격으로 퍼진다면 어떨까? 기하학적으로는 정확하지만 자연스럽지는 않다. 현실의 폭죽은 조금씩 불규칙하다. 이 불규칙함이 오히려 자연스러움을 만든다.\n\n애니메이션에 **랜덤성**을 더하면 기계적인 느낌을 벗어날 수 있다. 파티클의 속도에 ±20% 편차를 주거나, 각도에 약간의 흔들림을 추가하거나, 시작 타이밍을 미세하게 어긋나게 하는 것이다.\n\n하지만 여기서 중요한 원칙이 있다. **랜덤은 진짜 랜덤이면 안 된다.** 완전한 무작위는 예측 불가능하고 의도하지 않은 결과를 만든다. 예를 들어, 파티클이 전부 한쪽으로 쏠리거나 크기가 너무 극단적으로 나올 수 있다.\n\n통제된 랜덤성을 만드는 방법은 여러 가지다.\n\n- **범위 제한**: `baseValue + random(-range, +range)` 형태로, 기본값을 중심으로 일정 범위 안에서만 변동을 준다\n- **시드 기반 랜덤**: 같은 시드를 넣으면 같은 결과가 나오는 의사 난수를 사용한다. 애니메이션을 재현할 수 있어 디버깅에도 유리하다\n- **노이즈 함수**: Perlin noise나 simplex noise처럼 부드럽게 연결되는 랜덤 값을 사용한다. 순수 랜덤과 달리 인접한 값끼리 급격한 차이가 없어 자연스러운 흔들림을 만든다\n\n<RandomComparisonDemo />\n\n애니메이션을 **의도한 것**과 **의도하지 않은 것**으로 나눠 생각하면 도움이 된다. 파티클이 위로 올라가는 것은 의도한 움직임이고, 각 파티클의 미세한 속도 차이는 의도적으로 넣은 비의도적 요소다. 설계자는 \"어디까지를 통제하고, 어디부터를 랜덤에 맡길 것인가\"를 결정해야 한다. 이 경계를 잘 설정하면 질서와 자연스러움이 공존하는 애니메이션을 만들 수 있다.\n\n## 양방향성 고려\n\n지금까지 살펴본 애니메이션은 대부분 **한 방향**으로 흘렀다. 시작에서 끝으로, 0에서 1로. 하지만 스크롤에 반응하는 애니메이션이나 드래그 인터랙션처럼 **사용자가 진행 방향을 바꿀 수 있는** 경우가 있다. 스크롤을 내리면 요소가 나타나고, 다시 올리면 사라진다. 이런 애니메이션은 설계할 때 역재생을 고려해야 한다.\n\n다음 예제를 살펴보면 스크롤에 반응하는 패럴랙스 효과가 어떻게 양방향으로 설계되는지 볼 수 있다. 요소가 스크롤에 따라 나타나고 사라지는 애니메이션이지만, 스크롤 방향이 바뀌어도 자연스럽게 이어진다.\n\n<BidirectionalDemo />\n\n패럴랙스와 같은 값 기반 애니메이션은 양방향성을 고려하기가 상대적으로 쉽다. 그래프의 가로축이 스크롤 오프셋이기 때문에, 방향이 바뀌어도 같은 그래프를 역방향으로 따라가면 된다. 하지만 이벤트 기반 애니메이션처럼 버튼 클릭으로 나타나고 사라지는 경우는 좀 더 신경 써야 한다. 양방향성을 고려하지 않으면 다음과 같은 문제가 생긴다.\n\n- **점프**: 나타나는 도중에 숨기기를 누르면, 현재 위치를 무시하고 처음부터 사라지는 애니메이션이 시작된다. 위치가 순간이동하면서 뚝 끊긴다\n- **동일한 곡선**: 나타날 때와 사라질 때 같은 이징을 쓰면 단조롭다. 진입은 탄성 있게, 퇴장은 빠르게 — 이런 비대칭이 자연스럽다\n\n양방향성을 제대로 고려하면 방향이 바뀌는 순간 **현재 상태에서 이어서** 반전된다. 아래 예제에서 나타나는 도중에 빠르게 토글해보면 차이를 느낄 수 있다.\n\n<BidirectionalCompareDemo />\n\n# 정말 복잡한 애니메이션은?\n\n지금까지 다룬 기법으로 꽤 많은 애니메이션을 설계할 수 있지만 한계는 분명히 존재한다. 캐릭터가 걷고 뛰는 동작, 손으로 그린 듯한 모핑, 수십 개의 레이어가 정교하게 맞물리는 인트로와 같은 애니메이션을 코드만으로 표현하는 것은 현실적이지 않다.\n\n이런 경우에는 **전문 도구**를 사용하는 것이 맞다. After Effects로 만든 애니메이션을 [Lottie](https://airbnb.io/lottie/)로 내보내거나, [Rive](https://rive.app/)처럼 인터랙티브 애니메이션에 특화된 도구를 쓰는 방식이다. 혹은 아예 **영상**으로 제작해서 재생하는 것도 방법이다. 코드로 모든 것을 해결하려는 것보다 적절한 도구를 선택하는 것이 더 나은 결과를 만든다.\n\n반대로 말하면 코드로 작성하는 애니메이션의 강점은 **실시간 인터랙션**에 있다. 사용자의 입력에 즉각 반응하고 상태에 따라 동적으로 변하는 움직임은 미리 만들어 둔 영상으로는 구현하기 어렵다. 이 글에서 다룬 기법들이 빛을 발하는 지점이 바로 여기다.\n\n# 마치며\n\n애니메이션을 구현할 때 막막했던 경험이 있다면, 이 글이 \"어디서부터 시작할지\"를 찾는 데 도움이 되었기를 바란다. 결국 애니메이션 설계의 핵심은 **분해**다. 어떤 움직임이든 쪼개면 단순해지고 단순한 조각은 그래프로 그릴 수 있다. 이 과정을 의식적으로 연습하면 머릿속의 움직임을 코드로 옮기는 거리가 점점 가까워질 것이다.\n","tableOfContents":{"items":[{"url":"#들어가며","title":"들어가며"},{"url":"#애니메이션은-그래프다","title":"애니메이션은 그래프다"},{"url":"#애니메이션을-위한-도구-수학","title":"애니메이션을 위한 도구, 수학","items":[{"url":"#이징과-베지어-커브","title":"이징과 베지어 커브"},{"url":"#지수적-접근","title":"지수적 접근"},{"url":"#스프링-애니메이션","title":"스프링 애니메이션"},{"url":"#물리-시뮬레이션","title":"물리 시뮬레이션"},{"url":"#자연스러운-방향-전환","title":"자연스러운 방향 전환"},{"url":"#삼각함수로-만드는-주기적-움직임","title":"삼각함수로 만드는 주기적 움직임"},{"url":"#톱니파","title":"톱니파"}]},{"url":"#애니메이션-설계하기","title":"애니메이션 설계하기","items":[{"url":"#그래프를-나눠라","title":"그래프를 나눠라"},{"url":"#무엇에-의존하는가","title":"무엇에 의존하는가"},{"url":"#파이프라이닝","title":"파이프라이닝"},{"url":"#상태-전환으로-설계하기","title":"상태 전환으로 설계하기"},{"url":"#속성-분리","title":"속성 분리"},{"url":"#랜덤성","title":"랜덤성"},{"url":"#양방향성-고려","title":"양방향성 고려"}]},{"url":"#정말-복잡한-애니메이션은","title":"정말 복잡한 애니메이션은?"},{"url":"#마치며","title":"마치며"}]},"excerpt":"웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 버튼을 누르면 부드럽게 전환되는 화면, 스크롤에 반응하며 나타나는 요소들, 로딩을 기다리는 동안의 재치 있는 움직임과 같은 애니메이션은 재미를 더할 뿐 아니라…","fields":{"slug":"/posts/how-to-design-animation","date":"2026-02-18"},"frontmatter":{"title":"애니메이션을 설계하는 방법","categories":"article","tags":["animation","design","math"],"image":"/images/2026-02-18-how-to-design-animation/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-26","slug":"/posts/how-to-build-an-agent"},"frontmatter":{"title":"AI 에이전트를 만드는 방법","image":"/images/2025-04-26-how-to-build-an-agent/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-06","slug":"/posts/modeling-series-temporal"},"frontmatter":{"title":"모델링 시리즈: 시간","image":"/images/2025-05-06-modeling-series-temporal/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-02","slug":"/posts/modeling-series-measure"},"frontmatter":{"title":"모델링 시리즈: 측도","image":"/images/2025-05-02-modeling-series-measure/thumbnail.png"}}},{"node":{"fields":{"date":"2026-02-18","slug":"/posts/how-to-design-animation"},"frontmatter":{"title":"애니메이션을 설계하는 방법","image":"/images/2026-02-18-how-to-design-animation/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/how-to-design-animation","frontmatter":{"title":"애니메이션을 설계하는 방법","categories":"article","tags":["animation","design","math"],"image":"/images/2026-02-18-how-to-design-animation/thumbnail.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}