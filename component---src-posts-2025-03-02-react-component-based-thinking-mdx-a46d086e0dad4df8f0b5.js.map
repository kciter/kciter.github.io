{"version":3,"file":"component---src-posts-2025-03-02-react-component-based-thinking-mdx-a46d086e0dad4df8f0b5.js","mappings":"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","sources":["webpack://kciter.so/./src/posts/2025-03-02-react-component-based-thinking.mdx","webpack://kciter.so/./src/components/Image/index.tsx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport Image from '@components/Image';\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    h1: \"h1\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"컴포넌트는 React를 이용하여 프론트엔드 개발을 한다면 가장 중요한 개념이라 할 수 있다. 컴포넌트를 단순히 UI를 구성하는 단위라고 생각할 수 있지만, 사실 UI를 포함하여 이벤트 처리, 상태 관리, 통신 등 많은 부분을 컴포넌트가 담당한다. 로직을 컴포넌트로부터 아무리 잘 분리하더라도 결국 최종적으로 사용자는 컴포넌트를 통하기 때문에 좋은 제품을 만들고 싶다면 컴포넌트에 대한 이해가 필수적이다.\"), \"\\n\", React.createElement(Image, {\n    src: \"/images/2025-03-02-react-component-based-thinking/user-meets-components.png\",\n    caption: \"사용자는 반드시 컴포넌트를 통한다\"\n  }), \"\\n\", React.createElement(_components.p, null, \"앞서 말한 것처럼 \", React.createElement(_components.strong, null, \"React의 컴포넌트는 UI 뿐만 아닌 사용자가 시스템과 상호작용하는 모든 부분을 담당\"), \"한다. 이번 글에서는 React 컴포넌트를 어떻게 바라보고 어떤 것이 중요한지에 대해 알아볼 것이다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"컴포넌트를-바라보는-시각\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트를-바라보는-시각\"\n  }, \"컴포넌트를 바라보는 시각\")), \"\\n\", React.createElement(_components.p, null, \"흔히 React에서 컴포넌트는 UI를 구성하는 단위로 생각되지만 본래 프로그래밍에서 컴포넌트라는 개념은 조합과 재사용이 가능한 객체를 의미한다. 사실 React 컴포넌트는 UI를 빼고 생각하는 것이 더 중요하다. UI는 단지 컴포넌트가 하는 일 중 하나일 뿐이다. 그런 측면에서 생각했을 때 컴포넌트는 다양한 관점으로 바라볼 수 있고 그에 따라 구현이 달라질 수 있다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 로직과 뷰의 조합이다.\"), \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 요소와 스타일의 조합이다.\"), \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 서버 상태를 반영하는 뷰다.\"), \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 사용자 이벤트를 처리하는 통로다.\"), \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 상태를 직접 제어할 수 있는 것과 아닌 것으로 나뉜다.\"), \"\\n\", React.createElement(_components.li, null, \"컴포넌트는 유한 상태 머신이다.\"), \"\\n\", React.createElement(_components.li, null, \"...\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"위처럼 컴포넌트는 관점에 따라 다르게 묘사할 수 있다. 왜 관점이 달라질까? 그 이유는 목적이 다르기 때문이다. 즉, 컴포넌트는 \", React.createElement(_components.strong, null, \"목적에 따라 추성화\"), \"가 가능하다.\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트-분해하기\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트-분해하기\"\n  }, \"컴포넌트 분해하기\")), \"\\n\", React.createElement(_components.p, null, \"추상화를 잘하기 위해선 목적에 따라 필요한 것을 조합할 수 있어야 한다. 그러기 위해선 무엇을 조합할 수 있는지 알아야 한다. 컴포넌트를 분해하는 것은 이러한 관점에서 시작된다. 일단 분해하여 무엇이 있는지 알면 목적에 따라 필요한 것을 조합할 수 있게 된다.\"), \"\\n\", React.createElement(_components.p, null, \"[컴포넌트 구성 요소 이미지]\"), \"\\n\", React.createElement(_components.p, null, \"뷰                              데이터                       로직\\n요소 속성 텍스트 이벤트 토큰        Props 상태                 이벤트핸들러 라이프사이클 사이드이펙트\"), \"\\n\", React.createElement(_components.p, null, \"생각보다 컴포넌트를 구성하는 것은 많다.\"), \"\\n\", React.createElement(_components.p, null, \"컴포넌트는 크게 이름, UI, 데이터, 상태, 이벤트 핸들러, 라이프사이클, 사이드 이펙트로 구성된다. 각 구성 요소는 또 세세하게 나누는 것이 가능하다.\"), \"\\n\", React.createElement(_components.p, null, \"이렇게 나뉜 구성 요소 중 목적에 따라 필요한 것을 조합하여 원하는 컴포넌트를 만들 수 있다. 예를 들어보면 Headless 컴포넌트는 스타일 요소를 완전히 배제한 컴포넌트라고 할 수 있다. 또 다른 예로 고차\"), \"\\n\", React.createElement(_components.p, null, \"위 이미지를 보았을 때 컴포넌트는 다음과 같은 요소로 구성되어 있다.\"), \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"UI\", \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"요소 (DOM Element)\", \"\\n\", React.createElement(_components.ul, null, \"\\n\", React.createElement(_components.li, null, \"속성 (Attribute)\"), \"\\n\", React.createElement(_components.li, null, \"텍스트\"), \"\\n\", React.createElement(_components.li, null, \"이벤트\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"토큰 (CSS)\"), \"\\n\"), \"\\n\"), \"\\n\", React.createElement(_components.li, null, \"상태\"), \"\\n\", React.createElement(_components.li, null, \"이벤트 핸들러\"), \"\\n\", React.createElement(_components.li, null, \"라이프사이클\"), \"\\n\", React.createElement(_components.li, null, \"Props\"), \"\\n\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트간-협력\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트간-협력\"\n  }, \"컴포넌트간 협력\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트-분류\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트-분류\"\n  }, \"컴포넌트 분류\")), \"\\n\", React.createElement(_components.h1, {\n    id: \"컴포넌트-평가\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트-평가\"\n  }, \"컴포넌트 평가\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트의-사회성\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트의-사회성\"\n  }, \"컴포넌트의 사회성\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트의-신뢰성\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트의-신뢰성\"\n  }, \"컴포넌트의 신뢰성\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트의-가독성\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트의-가독성\"\n  }, \"컴포넌트의 가독성\")), \"\\n\", React.createElement(_components.h2, {\n    id: \"컴포넌트의-의존성\"\n  }, React.createElement(_components.a, {\n    href: \"#컴포넌트의-의존성\"\n  }, \"컴포넌트의 의존성\")), \"\\n\", React.createElement(_components.h1, {\n    id: \"마치며\"\n  }, React.createElement(_components.a, {\n    href: \"#마치며\"\n  }, \"마치며\")), \"\\n\", React.createElement(_components.p, null, \"사고 방식은 실제 구현에 큰 영향을 미친다. 또한, 소통을 위한 명확한 기준은 팀의 생산성을 높인다. 컴포넌트는 추상적이면서 구체적인 개념이다. 그러다보니 굉장히 다양한 방식의 구현이 가능하다. 이로 인한 커뮤니케이션 비용이 증가할 수 있기 때문에 컴포넌트에 대한 사고 방식을 명확히 하는 것이 중요하다. 꼭 이 글이 아니더라도 컴포넌트에 대한 기준을 정하고 팀원들과 공유하는 것이 중요하다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import React, { useCallback, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\ninterface ImageProps {\n  src: string;\n  caption?: string;\n  width?: number;\n  maxWidth?: number;\n  expandable?: boolean;\n}\n\nconst Image = ({ src, caption, width, maxWidth, expandable }: ImageProps) => {\n  const [isExpanded, toggleExpanded] = useState(false);\n\n  console.log(isExpanded);\n\n  return (\n    <figure>\n      <img\n        src={src}\n        width={width || '100%'}\n        style={{ cursor: expandable ? 'zoom-in' : 'default', maxWidth }}\n        onClick={expandable ? () => toggleExpanded(true) : undefined}\n      />\n      {caption && <figcaption dangerouslySetInnerHTML={{ __html: caption }} />}\n      {isExpanded &&\n        ReactDOM.createPortal(\n          <div\n            style={{\n              position: 'fixed',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: '100%',\n              cursor: 'zoom-out',\n              backgroundColor: 'rgba(0, 0, 0, 0.7)',\n              zIndex: 1000\n            }}\n            onClick={() => toggleExpanded(false)}\n          >\n            <img\n              src={src}\n              width=\"100%\"\n              style={{\n                display: 'block',\n                borderRadius: 8,\n                width: 'auto',\n                height: 'auto',\n                maxWidth: 1440,\n                maxHeight: '80vh',\n                position: 'fixed',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                backgroundColor: 'white'\n              }}\n            />\n          </div>,\n          document.body\n        )}\n    </figure>\n  );\n};\n\nexport default Image;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","strong","h1","a","ul","li","h2","_provideComponents","components","React","Image","src","caption","id","href","wrapper","MDXLayout","_ref","width","maxWidth","expandable","isExpanded","toggleExpanded","useState","console","log","___EmotionJSX","style","cursor","onClick","undefined","dangerouslySetInnerHTML","__html","ReactDOM","position","top","left","height","backgroundColor","zIndex","display","borderRadius","maxHeight","transform","document","body","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}