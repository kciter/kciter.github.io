---
title: "바보야, 문제는 경계야!"
categories: article
tags: [software-engineering, boundary, architecture, design]
image: /images/2026-02-20-it-is-the-boundary-stupid/thumbnail.png
comments: true
draft: true
hide: false
---

import Image from '@components/Image';

> Something there is that doesn't love a wall. — Robert Frost, Mending Wall

버그를 추적해 본 경험이 있는가? 로그를 따라가고, 스택 트레이스를 읽고, 변수의 상태를 하나하나 확인하며 원인을 좁혀간다. 그렇게 한참을 헤매다 보면 결국 도달하는 곳이 있다. 함수와 함수 사이, 모듈과 모듈 사이, 시스템과 시스템 사이. 문제는 늘 **경계**에 있었다.

이는 소프트웨어만의 이야기가 아니다. 국경에서 분쟁이 일어나고, 부서 간 협업에서 갈등이 생기며, 문화와 문화가 만나는 곳에서 오해가 피어난다. 인간 세계에서 발생하는 대부분의 갈등은 경계에서 시작된다. 1992년 미국 대선에서 제임스 카빌은 "It's the economy, stupid"라는 슬로건을 내걸었다. 복잡해 보이는 선거 전략의 핵심을 한 문장으로 꿰뚫은 것이다. 필자는 소프트웨어 개발에서도 비슷한 말을 하고 싶다.

**바보야, 문제는 경계야.**

개발에서 발생하는 문제의 대부분은 경계에서 온다. 이것이 이 글의 핵심 주장이다. 물론 모든 문제가 경계에서 온다고 말하는 것은 아니다. 알고리즘의 논리적 오류나 단순한 오타는 경계와 무관하다. 그러나 실무에서 개발자를 괴롭히는 **진짜 어려운 문제**들, 디버깅에 며칠이 걸리고 설계를 뒤엎어야 하는 그런 문제들은 놀라울 정도로 경계에 집중되어 있다.

이 글에서는 소프트웨어 개발에서 경계가 만들어내는 다양한 문제를 살펴보고, 경계를 다루는 전략에 대해 이야기해보려 한다.

{/* TODO: 이미지 — 함수 → 모듈 → 시스템 → 조직으로 확대되는 경계의 스케일을 보여주는 동심원 또는 줌아웃 다이어그램 */}

# 경계란 무엇인가

그렇다면 소프트웨어에서 **경계**란 정확히 무엇일까? 경계란 **서로 다른 관심사, 책임, 또는 맥락이 만나는 지점**이다. 함수와 함수 사이에는 호출이라는 경계가 있고, 모듈과 모듈 사이에는 인터페이스라는 경계가 있다. 클라이언트와 서버 사이에는 네트워크라는 경계가 있고, 개발팀과 운영팀 사이에는 조직이라는 경계가 있다.

경계는 왜 존재할까? 우리가 소프트웨어를 만들 때 하는 거의 모든 행위가 경계를 만드는 행위이기 때문이다. 함수를 나누는 것, 클래스를 정의하는 것, 모듈을 분리하는 것, 서비스를 쪼개는 것. 이 모든 것은 **관심사를 분리**하고 **복잡성을 관리하기 위한 경계 설정** 행위다. 소프트웨어 공학의 역사는 어떻게 보면 경계를 만드는 기술의 역사라 할 수 있다. 구조적 프로그래밍은 제어 흐름에 경계를 만들었고, 객체지향은 데이터와 행위에 경계를 만들었으며, 마이크로서비스는 배포 단위에 경계를 만들었다.

{/* TODO: 이미지 — 경계의 양면성 다이어그램. 하나의 덩어리를 경계로 나누면 내부는 단순해지지만, 경계 접점에서 새로운 복잡성(화살표, 프로토콜, 에러 처리 등)이 태어나는 모습 */}

여기서 아이러니가 발생한다. **경계는 복잡성을 다루기 위해 만들지만, 경계 자체가 새로운 복잡성의 원천이 된다.** 하나의 덩어리로 존재하던 코드를 둘로 나누는 순간, 그 둘 사이의 소통 방식을 정의해야 한다. 누가 누구를 호출하는지, 어떤 데이터를 주고받는지, 에러가 발생하면 어떻게 처리하는지. 경계가 없었다면 존재하지 않았을 문제들이 경계와 함께 태어난다.

그렇다고 경계를 만들지 않을 수는 없다. 경계 없는 소프트웨어는 모든 것이 뒤엉킨 혼돈이며, 인간의 인지 능력으로는 다룰 수 없다. 우리는 경계를 만들 수밖에 없고, 따라서 경계에서 발생하는 문제와도 함께 살아갈 수밖에 없다. 중요한 것은 **경계가 어디에 있는지 인식하고, 그 경계에서 어떤 문제가 발생할 수 있는지 이해하는 것**이다.

이제부터 소프트웨어 개발에서 마주치는 다양한 경계 문제를 네 가지 범주로 나누어 살펴보자.

# 접점의 경계

첫 번째 범주는 **접점의 경계**다. 코드가 코드를 만나는 가장 기본적인 지점에서 발생하는 문제들이다. 함수 호출, 모듈 간 의존, API 통신 등 소프트웨어 개발에서 매일 마주치는 일상적인 경계이기도 하다.

## Caller와 Callee의 경계

가장 원초적인 경계는 **호출하는 쪽(Caller)과 호출당하는 쪽(Callee) 사이**에 존재한다. 하나의 함수가 다른 함수를 호출하는 단순한 행위에서조차 경계 문제가 발생한다.

```kotlin
fun getUser(id: String): User? {
    // 사용자가 없으면 null을 반환할까? 예외를 던질까?
    // 이 결정은 Caller의 삶을 완전히 바꾼다.
}

fun processOrder(userId: String) {
    val user = getUser(userId)
    // user가 null일 수 있다는 것을 알고 있는가?
    // getUser가 예외를 던질 수 있다는 것을 알고 있는가?
    user.name // 💥 NullPointerException
}
```

이 코드에서 문제의 핵심은 **계약(Contract)의 부재** 혹은 **계약의 모호함**이다. `getUser`는 사용자를 찾지 못했을 때 `null`을 반환하는가, 예외를 던지는가? `processOrder`는 그 사실을 알고 있는가? Kotlin의 Nullable 타입(`User?`)은 이 계약을 타입 시스템에 녹여낸 좋은 사례지만, Java 라이브러리와의 경계에서는 이 보호가 무력화되기도 한다. 호출자와 피호출자 사이의 경계에서 이 계약이 명확하지 않으면 문제가 발생한다.

이 문제는 Defensive Programming과 Design by Contract라는 두 가지 철학으로 이어진다. Defensive Programming은 경계를 불신하는 접근이다. 상대방이 무엇을 보내든 방어적으로 대응한다. Design by Contract는 경계를 명시적 계약으로 정의하는 접근이다. 계약을 어긴 쪽이 책임을 진다. 어떤 접근이 옳다고 단정할 수는 없지만, 두 접근 모두 **경계에서의 계약**이라는 문제를 해결하려는 시도라는 점에서 공통된다.

{/* TODO: 이미지 — Caller와 Callee 사이의 경계 다이어그램. 양쪽에서 "상대방이 처리하겠지"라고 생각하며 책임이 공중에 떠있는 모습 */}

더 근본적으로 보면, 이 문제는 **책임의 경계** 문제이기도 하다. 입력값의 유효성은 누가 검증해야 하는가? 에러 처리의 책임은 누구에게 있는가? 이런 질문에 명확한 답이 없을 때 버그가 태어난다. 경계에서 책임이 모호해지는 순간, 양쪽 모두 상대방이 처리해줄 것이라 기대하고, 결국 아무도 처리하지 않는 상황이 벌어진다.

## 인터페이스의 경계

Caller-Callee가 함수 레벨의 경계라면, 인터페이스의 경계는 **추상화 계층 사이의 경계**다. 우리는 복잡성을 감추기 위해 추상화를 만들고, 그 추상화의 표면을 인터페이스라 부른다. 문제는 이 추상화가 **완벽하지 않다**는 데 있다.

Joel Spolsky는 이를 **누수되는 추상화의 법칙(The Law of Leaky Abstractions)**이라 불렀다.[^1] 모든 비자명한(non-trivial) 추상화는 어느 정도 누수된다. 추상화가 감추려 했던 아래 계층의 복잡성이 경계를 뚫고 올라온다.

```kotlin
// JPA는 SQL을 추상화한다
val users = userRepository.findAllByActiveTrue()

// 하지만 성능 문제가 생기면 결국 SQL을 이해해야 한다
// ORM이라는 경계 아래를 들여다봐야 하는 순간이 온다
@Query("""
    SELECT u FROM User u
    JOIN FETCH u.profile p
    WHERE u.active = true
    AND p.lastLogin > :threshold
""")
fun findActiveUsersWithRecentLogin(
    @Param("threshold") threshold: LocalDateTime
): List<User>
```

{/* TODO: 이미지 — 추상화 계층 다이어그램. 깔끔한 인터페이스 표면 아래로 복잡한 SQL, 네트워크, 바이트 등이 비져나오는(leaking) 모습 */}

ORM은 데이터베이스와 애플리케이션 코드 사이의 경계에 위치한 추상화다. 대부분의 경우 잘 동작하지만, 복잡한 쿼리나 성능 최적화가 필요한 순간 추상화가 누수된다. 개발자는 ORM이 감추려 했던 SQL의 세계를 다시 직면해야 한다. 경계가 완벽하지 않기에 발생하는 문제다.

REST API도 마찬가지다. HTTP라는 프로토콜 위에 리소스라는 추상화를 얹었지만, 복잡한 비즈니스 로직을 CRUD 패턴에 끼워 맞추기 어려운 순간이 온다. GraphQL은 이 문제를 해결하려 했지만, 다시 캐싱이라는 새로운 경계 문제를 만들어냈다. **하나의 경계 문제를 해결하면 다른 경계 문제가 생기는 것**, 이것이 인터페이스 경계의 본질적 어려움이다.

## 의존성의 경계

세 번째 접점은 **내가 통제하는 코드와 통제하지 못하는 코드의 경계**다. 외부 라이브러리, 외부 서비스, 런타임 환경 등 우리가 직접 작성하지 않은 모든 것은 경계 너머에 존재한다.

Michael Nygard는 저서 Release It!에서 **"Integration Points are the #1 killer"**라고 말했다.[^2] 시스템이 외부와 통합하는 모든 지점은 잠재적 장애 지점이다. 외부 API가 응답하지 않을 때, 라이브러리가 메이저 버전을 올리며 하위호환성을 깨뜨릴 때, 의존하던 서비스가 예고 없이 스펙을 변경할 때. 경계 너머의 변화가 내 코드를 무너뜨린다.

```kotlin
// 어제까지 잘 동작하던 코드
val response = paymentClient.charge(request)
// 외부 결제 API가 응답 필드명을 바꿨다.
// transactionId → txnId
// 내 코드에는 버그가 없는데 시스템이 실패한다.
val transactionId = response.transactionId // 💥 null
```

이 문제가 특히 까다로운 이유는 **경계 너머를 통제할 수 없기 때문**이다. 내 코드에는 버그가 없는데 시스템이 실패한다. 어제까지 잘 돌아가던 코드가 오늘 갑자기 깨진다. 원인을 추적하면 의존하던 무언가가 바뀌었다는 사실을 알게 된다. 의존성의 경계는 **내가 통제할 수 있는 영역의 한계**를 보여준다.

# 데이터의 경계

두 번째 범주는 **데이터의 경계**다. 코드의 접점뿐 아니라, 데이터가 경계를 넘을 때도 문제가 발생한다. 데이터는 경계를 넘을 때마다 변환되고, 손실되고, 때로는 오염된다.

## 표현의 경계

소프트웨어에서 같은 데이터는 경계를 넘을 때마다 다른 형태로 **표현(representation)**된다. 이를 **임피던스 불일치(Impedance Mismatch)**라 부른다. 원래 전기공학에서 온 용어지만 소프트웨어에서도 정확히 같은 현상이 일어난다.

가장 잘 알려진 예는 객체-관계 불일치(Object-Relational Impedance Mismatch)다. 애플리케이션은 객체로 세상을 표현하고, 데이터베이스는 테이블과 행으로 세상을 표현한다. 같은 "사용자"라는 개념이 코드에서는 상속과 다형성을 가진 객체이고, 데이터베이스에서는 정규화된 여러 테이블의 조인이다. 이 두 표현 사이를 오갈 때마다 변환이 일어나고, 변환은 정보를 잃거나 왜곡한다.

```kotlin
// 서버: Kotlin 도메인 모델
data class User(
    val id: Long,
    val name: String,
    val createdAt: Instant,       // java.time.Instant
    val profile: Profile          // 중첩 객체
)

// API 경계: JSON 직렬화
// { "id": 1, "name": "...", "created_at": "2024-01-15T09:30:00Z", "profile": { ... } }

// 클라이언트: 또 다른 모델
// { id: number, name: string, createdAt: Date, profile: { bio: string, avatar: string } }
```

{/* TODO: 이미지 — 하나의 User 데이터가 서버(Kotlin 객체) → API(JSON) → 클라이언트(JS 객체) → DB(테이블 행)로 형태가 바뀌며 흐르는 데이터 변환 다이어그램. 각 경계에서 타입과 구조가 달라지는 모습 */}

하나의 User 데이터가 여러 경계를 넘으며 각각 다른 형태로 표현된다. 각 변환 지점에서 타입이 바뀌고(`Instant` → `String` → `Date`), 구조가 바뀌며(중첩 객체 → 평탄한 JSON → 다른 중첩 구조), 의미가 미묘하게 달라질 수 있다. 프론트엔드 모델과 백엔드 모델이 일치하지 않아 발생하는 버그는 모두 이 표현의 경계에서 비롯된다.

## 원자성의 경계

**"하나의 작업"이 여러 경계를 넘어가야 할 때**, 원자성의 문제가 발생한다. 원자성이란 작업이 전부 성공하거나 전부 실패해야 한다는 것을 말한다. 경계 안에서는 비교적 쉽게 보장할 수 있지만, 경계를 넘으면 급격히 어려워진다.

```kotlin
// 주문 처리: 세 서비스의 경계를 넘어야 하는 하나의 작업
fun processOrder(order: Order) {
    paymentService.charge(order.payment)      // ✓ 성공
    inventoryService.deduct(order.items)       // ✗ 실패!
    notificationService.send(order.userId)     // — 실행되지 않음

    // 결제는 됐는데 재고는 차감되지 않았다.
    // 사용자에게는 어떤 상태를 보여줘야 하는가?
}
```

단일 데이터베이스 안에서라면 트랜잭션으로 원자성을 보장할 수 있다. 그러나 작업이 여러 서비스, 여러 데이터베이스에 걸쳐있다면 이야기가 달라진다. 분산 트랜잭션은 악명 높게 어렵고, 2PC(Two-Phase Commit)는 성능 문제를 일으키며, Saga 패턴은 보상 트랜잭션이라는 복잡성을 더한다. 이 모든 어려움은 **"하나의 작업"이 여러 경계에 걸쳐있기 때문**에 발생한다.

{/* TODO: 이미지 — 원자성이 깨지는 순간을 보여주는 다이어그램. 하나의 작업이 서비스 A, B, C 경계를 넘어가는데, B에서 실패하여 A는 완료, C는 미실행인 불일치 상태 */}

더 일상적인 예를 들면, 파일에 쓰기 작업을 하다가 중간에 프로세스가 죽는 경우도 원자성의 경계 문제다. 메모리(애플리케이션 경계 안)에서는 데이터가 완전하지만, 디스크(경계 밖)에는 절반만 기록된 상태가 된다. 경계를 넘는 순간, 원자성은 더 이상 보장되지 않는다.

## 신뢰의 경계

**신뢰의 경계(Trust Boundary)**란 검증된 데이터와 검증되지 않은 데이터가 만나는 지점이다. 경계 안쪽의 데이터는 이미 검증을 거쳤으므로 신뢰할 수 있다. 그러나 경계 바깥에서 들어오는 데이터는 원칙적으로 신뢰할 수 없다.

```kotlin
// 신뢰의 경계를 무시한 코드
fun searchUser(name: String): List<User> {
    val query = "SELECT * FROM users WHERE name = '$name'"
    return jdbcTemplate.query(query, userRowMapper)
}

// name에 "'; DROP TABLE users; --" 가 들어온다면?
```

SQL Injection, XSS, CSRF 같은 보안 취약점의 본질은 모두 **신뢰의 경계를 무시한 것**이다. 외부에서 들어온 데이터를 검증 없이 내부 시스템에 전달한 것, 즉 경계를 넘는 데이터에 대한 불신이 부족했던 것이다.

Michael Nygard는 이를 **"냉소적인 소프트웨어(Cynical Software)"**라는 개념으로 설명했다.[^3] 좋은 소프트웨어는 냉소적이다. 자기 자신조차 믿지 않으며, 외부에서 오는 모든 것을 의심한다. 이는 비관적인 것이 아니라 현실적인 것이다. 경계 바깥은 언제나 예측 불가능하며, 그 예측 불가능성으로부터 경계 안쪽을 보호하는 것이 견고한 소프트웨어의 조건이다.

{/* TODO: 이미지 — 신뢰의 경계(Trust Boundary) 다이어그램. 안쪽은 "검증된 영역(Trusted Zone)", 바깥은 "검증되지 않은 영역". 경계를 넘어오는 화살표(사용자 입력, 외부 API 응답, 파일 업로드 등)에 검증 게이트가 있는 모습 */}

신뢰의 경계는 보안에만 국한되지 않는다. 외부 API의 응답을 그대로 믿고 사용하다가, 스펙에 없던 필드가 `null`로 오면서 시스템이 터지는 경우도 신뢰의 경계 문제다. **경계 너머에서 오는 모든 것은 의심의 대상**이라는 원칙을 잊으면, 언젠가 반드시 문제가 발생한다.

# 보이지 않는 경계

세 번째 범주는 **보이지 않는 경계**다. 코드를 아무리 읽어봐도 보이지 않지만, 실행 시점에 비로소 드러나는 경계들이다. 이 경계들은 눈에 보이지 않기에 더욱 위험하다.

## 시간의 경계

소프트웨어에서 가장 교묘한 경계 중 하나는 **시간**이다. 동기 코드에서는 시간이 선형적으로 흐른다. A가 끝나면 B가 시작되고, B가 끝나면 C가 시작된다. 그러나 비동기의 세계로 넘어가는 순간, 시간은 더 이상 선형적이지 않다.

```kotlin
// 코루틴: 동기적으로 보이지만, 각 suspend 지점 사이에 시간의 경계가 존재한다
suspend fun buildOrderSummary(id: String): OrderSummary {
    val user = userService.getUser(id)
    // ⏳ 이 사이에 user의 상태가 바뀔 수 있다
    val orders = orderService.getOrders(user.id)
    // ⏳ 이 사이에 새로운 주문이 추가될 수 있다
    return createSummary(user, orders)
    // summary는 이미 과거의 스냅샷이다
}
```

코루틴의 `suspend` 지점은 코드를 동기적으로 보이게 만들지만, 실제로는 각 `suspend` 사이에 시간의 경계가 존재한다. 그 경계 사이에서 세상이 바뀔 수 있다. Race condition, 이벤트 순서 역전, Stale data 문제는 모두 이 시간의 경계에서 비롯된다.

{/* TODO: 이미지 — 시간의 경계 타임라인 다이어그램. 서버 A와 서버 B의 시간축이 나란히 있고, 같은 이벤트가 각 서버에서 다른 순서로 도착하는 모습. Clock Drift와 네트워크 지연이 이벤트 순서를 뒤바꾸는 것을 시각화 */}

분산 시스템에서 시간의 경계는 더 극적이다. 서로 다른 서버의 시계는 미세하게 다르고(Clock Drift), 네트워크 지연은 이벤트의 순서를 뒤바꾼다. 서버 A에서 먼저 일어난 일이 서버 B에서는 나중에 도착할 수 있다. **물리적 시간과 논리적 시간의 경계**는 분산 시스템의 가장 근본적인 문제 중 하나다.

## 규모의 경계

**작은 규모에서 동작하던 것이 규모가 커지면 깨진다.** 이것은 단순히 성능이 느려진다는 의미가 아니다. 규모가 특정 **임계점(Threshold)**을 넘는 순간, 시스템의 동작 자체가 근본적으로 달라진다.

메모리에 담을 수 있던 데이터가 디스크로 넘어가는 순간, 접근 속도는 수만 배 느려진다. 단일 서버에서 처리하던 요청이 여러 서버로 분산되는 순간, 데이터 일관성이라는 새로운 문제가 등장한다. 하나의 프로세스에서 돌아가던 코드가 네트워크를 사이에 두고 실행되는 순간, 부분 실패(Partial Failure)라는 개념이 생겨난다.

{/* TODO: 이미지 — 규모의 경계 그래프. X축은 데이터/트래픽 규모, Y축은 복잡도/비용. 선형이 아닌 계단식 또는 지수적으로 증가하며, 임계점(메모리→디스크, 단일→분산 등)에서 급격히 점프하는 모습 */}

이 현상의 핵심은 **비선형성**이다. 규모가 10배가 되면 문제가 10배 어려워지는 것이 아니라 100배, 1000배 어려워질 수 있다. 이는 규모의 경계가 **양적 변화가 아닌 질적 변화**를 가져오기 때문이다. 메모리 안에서의 프로그래밍과 분산 시스템에서의 프로그래밍은 같은 언어를 사용하더라도 본질적으로 다른 활동이다.

흥미로운 점은 이 경계가 **미리 예측하기 어렵다**는 것이다. 어느 지점에서 임계점이 올지, 그때 어떤 문제가 발생할지를 정확히 예측하는 것은 거의 불가능하다. 그래서 규모의 경계는 대부분 사후적으로 발견되며, 그때부터 고통스러운 전환이 시작된다.

## 환경의 경계

**"Works on my machine."** 소프트웨어 역사상 가장 유명한 말일 것이다. 이 말은 환경의 경계를 완벽하게 요약한다. 같은 코드가 다른 환경에서 다르게 동작하는 현상, 이것이 환경의 경계 문제다.

개발 환경과 운영 환경의 차이는 다양한 형태로 나타난다. OS가 다르다(macOS에서 개발하고 Linux에서 배포한다). 런타임 버전이 다르다(로컬은 Node 20인데 서버는 Node 18이다). 환경 변수가 다르다. 네트워크 구성이 다르다. 시간대(Timezone)가 다르다.

```kotlin
// 로컬에서는 완벽하게 동작하는 코드
fun getRegisteredToday(): List<User> {
    val today = LocalDate.now() // 로컬: KST 기준 2024-01-16
    return userRepository.findByCreatedDate(today)
}
// 서버(UTC)에서는 KST 기준 전날의 데이터를 조회한다.
// 같은 코드, 같은 시각, 다른 결과.
```

이 목록에서 하나라도 차이가 나면 버그가 발생할 수 있다. 타임존 차이로 날짜 계산이 하루 밀리거나, 파일 경로의 대소문자 구분 차이로(macOS는 기본적으로 대소문자를 구분하지 않지만 Linux는 구분한다) 파일을 찾지 못하거나, 메모리 제한으로 로컬에서는 발생하지 않던 OOM(Out of Memory)이 운영에서 터지거나.

Docker와 같은 컨테이너 기술은 이 문제를 완화하기 위해 등장했다. 환경의 경계를 좁히려는 시도다. 그러나 컨테이너조차 완벽하지는 않다. 호스트 OS와 컨테이너 OS의 차이, 네트워크 구성의 차이, 스토리지 드라이버의 차이 등 **환경의 경계는 기술이 발전해도 완전히 사라지지 않는다.**

# 코드 밖의 경계

마지막 범주는 **코드 밖의 경계**다. 소프트웨어 문제는 코드 안에서만 발생하지 않는다. 코드와 그 너머의 세계, 즉 사람, 설계, 그리고 사용자 사이에도 경계가 존재하며, 이 경계에서도 마찬가지로 문제가 피어난다.

## 코드와 사람 사이

1968년, Melvin Conway는 다음과 같은 관찰을 발표했다.

> Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. — Melvin Conway

{/* TODO: 이미지 — Conway's Law 다이어그램. 왼쪽에 3개 팀의 조직 구조(소통 경로 포함), 오른쪽에 그와 동일한 구조로 나뉜 시스템 아키텍처. 조직의 경계선과 시스템의 경계선이 거울처럼 일치하는 모습 */}

**Conway's Law**로 알려진 이 법칙은 조직의 경계가 곧 시스템의 경계가 된다는 것을 말한다. 세 팀이 따로 일하면 세 개의 컴포넌트가 나오고, 두 팀 사이의 커뮤니케이션이 원활하지 않으면 두 시스템 사이의 인터페이스도 어색해진다. 이는 시스템이 조직의 소통 구조를 반영(Mirror)하기 때문이다.

코드 오너십도 경계 문제다. "이 코드는 누구 것인가?"라는 질문에 명확한 답이 없을 때, 양쪽 팀 모두 손대기를 꺼리는 무주공산(No man's land)이 생긴다. 반대로 여러 팀이 같은 코드를 수정하면 충돌이 발생한다. 코드의 경계와 조직의 경계가 일치하지 않을 때 이런 문제가 나타난다.

지식 사일로(Knowledge Silo)는 사람의 경계가 만드는 또 다른 문제다. 특정 시스템을 이해하는 사람이 한 명뿐이라면, 그 사람이 떠나는 순간 경계가 벽이 된다. 코드는 남아있지만 그 코드를 이해하는 맥락은 사라진다. 코드와 사람 사이의 경계에서 **지식이라는 데이터가 손실**된 것이다.

## 코드와 설계 사이

아키텍처 다이어그램을 그려본 적이 있는가? 깔끔한 박스와 화살표로 시스템을 표현하면 모든 것이 명확해 보인다. 그런데 실제 코드를 열어보면 다이어그램과는 사뭇 다른 세상이 펼쳐진다. 이것이 **코드와 설계 사이의 경계**다.

"지도는 영토가 아니다(The map is not the territory)"라는 격언이 있다. 설계는 지도이고 코드는 영토다. 지도는 현실을 단순화하고 추상화한 것이므로, 반드시 현실과 차이가 있다. 요구사항이 설계로 번역될 때 일부가 손실되고, 설계가 코드로 구현될 때 또 일부가 손실된다. **경계를 넘을 때마다 정보가 손실**되는 것이다.

{/* TODO: 이미지 — 설계 침식(Design Erosion) 다이어그램. 요구사항 → 설계 → 구현 → 운영으로 이어지는 파이프라인에서, 각 경계를 넘을 때마다 원래 의도(신호)가 조금씩 변형/손실되어 최종 결과와 원래 요구사항 사이에 간극이 생기는 모습 */}

이 경계가 문제가 되는 이유는 손실이 누적되기 때문이다. 요구사항 → 설계 → 구현 → 테스트 → 운영으로 이어지는 각 단계 사이에 경계가 있고, 각 경계에서 조금씩 정보가 변형된다. 최종적으로 운영되는 시스템은 원래 요구사항과 상당한 간극을 가질 수 있다. 이를 일컬어 **설계 침식(Design Erosion)**이라 부르기도 한다.

## 코드와 사용자 사이

UI는 **코드의 세계와 사용자의 세계가 만나는 경계면**이다. 이 경계면에서는 두 가지 근본적으로 다른 모델이 충돌한다. 시스템이 내부적으로 사용하는 모델(시스템 모델)과 사용자가 머릿속에 가지고 있는 모델(멘탈 모델)이다.

예를 들어 파일 시스템을 생각해보자. 운영체제는 파일을 inode와 블록으로 관리하지만, 사용자는 폴더와 파일이라는 비유로 이해한다. 이 두 모델 사이의 간극이 클수록 사용자는 혼란을 느낀다. "왜 파일을 삭제했는데 용량이 안 늘어나지?" 같은 질문은 이 경계에서의 모델 불일치에서 비롯된다.

디자인 시안과 실제 구현 사이의 괴리도 이 경계의 문제다. 디자이너가 그린 시안은 정적이고 이상적이다. 모든 텍스트는 적절한 길이이고, 이미지는 완벽한 비율이며, 네트워크는 항상 빠르다. 하지만 실제 구현에서는 텍스트가 넘치고, 이미지가 깨지며, 로딩 상태와 에러 상태를 처리해야 한다. 이상적 디자인과 현실적 구현 사이의 경계에서 수많은 엣지 케이스가 태어난다.

# 경계를 다스리는 법

지금까지 소프트웨어 개발에서 마주치는 다양한 경계 문제를 살펴보았다. 접점의 경계, 데이터의 경계, 보이지 않는 경계, 코드 밖의 경계. 이렇게 많은 곳에서 문제가 발생한다면, 대체 어떻게 해야 할까? 필자는 크게 두 가지 전략이 있다고 생각한다.

{/* TODO: 이미지 — 두 가지 전략의 대비. 왼쪽: "나누기" — 하나의 큰 경계가 여러 작은 경계로 분할되는 모습. 오른쪽: "제거하기" — 여러 경계가 제거되어 하나로 합쳐지는 모습 */}

## 경계를 나누기 — 분할 정복

첫 번째 전략은 **큰 경계를 작고 명확한 경계 여러 개로 나누는 것**이다. 분할 정복(Divide and Conquer)의 원리다.

거대하고 모호한 경계 하나보다는, 작고 명확한 경계 여러 개가 관리하기 쉽다. DDD의 Bounded Context는 이 전략의 대표적인 예다. 거대한 도메인을 여러 개의 명확한 맥락으로 나누고, 각 맥락 사이의 경계를 명시적 계약으로 정의한다. Anti-corruption Layer는 외부 시스템의 모델이 내부로 침투하지 못하도록 경계에 번역 계층을 두는 패턴이다.

모듈화, 계층 분리, 인터페이스 정의 등 소프트웨어 공학의 많은 원칙이 이 전략에 속한다. 경계를 명확히 하고, 각 경계에서의 계약을 엄격히 정의하여 문제가 발생할 여지를 줄이는 것이다.

그러나 이 전략에도 한계가 있다. 경계를 나누면 **경계의 수 자체가 늘어난다.** 마이크로서비스가 대표적이다. 모놀리스의 내부 경계 문제를 해결하려고 서비스를 쪼갰더니, 네트워크 경계, 데이터 일관성 경계, 배포 경계 등 새로운 종류의 경계 문제가 쏟아진다. 경계를 나누는 것은 문제를 해결하는 것이 아니라 **문제의 성격을 바꾸는 것**에 가깝다.

## 경계를 제거하기 — 파괴와 혼돈

두 번째 전략은 **불필요한 경계 자체를 없애는 것**이다. 경계가 문제의 원인이라면, 경계를 제거하면 문제도 사라진다.

과도한 추상화 계층을 걷어내는 것, 불필요하게 분리된 마이크로서비스를 다시 합치는 것, 복잡한 인터페이스 대신 직접 호출로 바꾸는 것. 이 전략은 "모놀리스가 나쁜 것이 아니다"라는 최근의 논의와도 맞닿아 있다. 경계가 적다는 것은 경계에서 발생하는 문제도 적다는 것을 의미한다.

그러나 이 전략에도 한계가 있다. 경계를 제거하면 **관심사가 뒤섞인다.** 분리되어 있던 것이 하나로 합쳐지면 내부 복잡성이 증가한다. 경계가 없는 코드는 모든 것이 모든 것과 얽혀있는 상태가 될 수 있으며, 이는 이해하기도 수정하기도 어렵다.

## 선택의 기준

그렇다면 언제 경계를 나눠야 하고, 언제 경계를 제거해야 할까? 불행히도 보편적인 정답은 없다. 다만 몇 가지 기준은 제시할 수 있다.

경계를 나눠야 할 때는 **경계의 양쪽이 서로 다른 속도로 변화**할 때다. 자주 바뀌는 부분과 거의 바뀌지 않는 부분 사이에는 명확한 경계를 두는 것이 좋다. 또한 경계의 양쪽이 **서로 다른 팀에 의해 관리**될 때도 경계를 명확히 하는 것이 유리하다.

경계를 제거해야 할 때는 **경계가 가져다주는 이점보다 비용이 클 때**다. 두 서비스가 항상 함께 배포되고, 항상 같은 데이터를 공유하며, 항상 같은 팀이 관리한다면, 그 둘 사이의 경계는 비용만 발생시키는 불필요한 것일 수 있다.

결국 핵심은 **나누기와 제거하기가 상반된 전략이 아니라 상황에 따른 도구**라는 것이다. 어떤 경계를 나누고, 어떤 경계를 제거할지를 판단하는 것. 이것이 소프트웨어 설계의 핵심이며, 이 판단을 하려면 먼저 **경계가 어디에 있는지 볼 수 있어야 한다.**

# 마치며

> 경계를 제압하는 자가 지배한다.

이 글에서 살펴본 것처럼, 소프트웨어 개발에서 문제는 놀라울 정도로 경계에 집중되어 있다. Caller와 Callee 사이에서, 데이터가 형태를 바꾸는 곳에서, 시간이 비선형적으로 흐르는 곳에서, 코드와 사람이 만나는 곳에서. 경계는 어디에나 있고, 문제는 그 경계에서 피어난다.

그렇다고 경계를 두려워할 필요는 없다. 경계는 복잡한 세상을 다루기 위한 필수적인 도구이며, 경계 없이 소프트웨어를 만들 수는 없다. 중요한 것은 경계의 존재를 **의식**하는 것이다. 경계가 보이면 그 경계에서 어떤 문제가 발생할 수 있는지 예측할 수 있고, 예측할 수 있으면 대비할 수 있다.

글의 처음에서 인간 세계의 갈등이 경계에서 시작된다고 이야기했다. 어쩌면 개발만이 아니라 **인간의 모든 문제가 경계에서 비롯되는 것**인지도 모른다. 이해와 오해의 경계, 나와 타인의 경계, 아는 것과 모르는 것의 경계. 경계를 인식하고 다루는 능력은 소프트웨어 개발뿐 아니라 세상을 이해하는 렌즈가 될 수 있다.

지금 당신이 겪고 있는 문제가 있다면, 한번 물어보자. 혹시 그 문제, 경계에서 오고 있지는 않은가?

[^1]: Joel Spolsky, "The Law of Leaky Abstractions", 2002
[^2]: Michael T. Nygard, "Release It! Design and Deploy Production-Ready Software", 2007
[^3]: Nygard는 이 개념을 "enterprise software must be cynical"이라 표현했다. 좋은 소프트웨어는 나쁜 일이 일어날 것을 예상하며, 그것이 실제로 일어나도 놀라지 않는다.
