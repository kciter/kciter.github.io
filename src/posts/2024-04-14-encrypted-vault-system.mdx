---
title: "비밀 관리를 위한 금고 시스템 만들기"
categories: dev
tags: [vault, cipher, security, password]
image: /images/2024-04-14-encrypted-vault-system/thumbnail.jpeg
comments: true
draft: false
hide: false
---

import Image from '@components/Image';

요즘은 편한 UX에 힘입어 비밀번호 관리 시스템을 사용하는 사람들이 많다. 대체로 브라우저 혹은 OS에서 제공하는 시스템을 이용하지만 1Password와 같은 애플리케이션을 이용하는 사람도 적지않다. 만약 힙한 것을 좋아하는 사람이라면 오픈소스를 이용하는 경우도 있다.

이런 제품을 사용한다면 한 번쯤 `정말 안전한게 맞을까?`라는 의심을 해본 적이 있을 것이다. 이번 글에서는 금고 시스템을 직접 구현해보며 비밀번호 관리 시스템의 원리에 대해 알아볼 것이다.

# 암호화에 대한 정의

암호화라는 것은 무엇을 말하는 것일까? 한국어 위키피디아에 의하면 **특별한 지식을 소유한 사람들을 제외하고는 누구든지 읽어볼 수 없도록 알고리즘을 이용하여 정보(평문을 가리킴)를 전달하는 과정**이라고 한다. 조금 더 단순하게 표현하자면 평문(Plain text)를 암호문(Cipher text)으로 바꿔서 전달하는 것을 의미한다.

원시적인 암호화 방법으로는 **카이사르 암호**라는 것도 있다. 카이사르 암호는 [치환암호](https://ko.wikipedia.org/wiki/%EC%B9%98%ED%99%98_%EC%95%94%ED%98%B8)의 일종으로 암호화하고자 하는 내용을 알파벳별로 일정한 거리만큼 밀어서 다른 알파벳으로 치환하는 방식이다. 예를 들어 3글자씩 밀어내는 카이사르 암호로 'COME TO ROME'을 암호화하면 'FRPH WR URPH'가 된다. 이렇게 암호화된 문장을 다시 복호화하려면 암호화할 때와 같은 거리만큼 밀어내면 된다. 물론 이런 방식은 매우 취약하기에 현대에선 사용되지 않는다.

<Image src="/images/2024-04-14-encrypted-vault-system/caesar-cipher.png" caption="카이사르 암호는 각각의 알파벳을 일정한 거리만큼 밀어 글자를 치환하는 방식으로 암호화한다" />

스포츠를 좋아한다면 실시간으로 전략을 정할 때 사인을 보낸다는 것을 알 수 있다. 이 때 전략이 유출되면 안되기 때문에 팀 내에서 수신호의 의미를 정하고 외부에 공개하지 않는다. 그렇지만 상대편 또한 의미를 해석하려 하기에 키 사인(Key sign)을 사용하여 숨기기도 한다. 이 또한 암호화의 한 형태라고 할 수 있다.

<Image src="/images/2024-04-14-encrypted-vault-system/sport-sign.jpeg" caption="다른 사람들은 이 수신호의 의미를 알 수 없다" />

# 케르크호프스의 원칙

카이사르 암호나 스포츠에서 사용되는 사인과 다르게 프로그래밍에 쓰이는 암호화 관련 알고리즘은 대부분 공개되어 있다. 앞서 소개한 두 사례는 알고리즘이 유출되는 경우 너무나도 쉽게 복호화가 가능하다. 그러니 알고리즘이 공개되었는데 정말 안전한게 맞는가? 라는 의문이 충분히 들 수 있다. 결론부터 말하자면 안전하다. 이에 대한 내용인 케르크호프스의 원칙에 대해서 알아보자.

케르크호프스 혹은 커코프라 불리는 원칙은 Auguste Kerckhoffs가 작성한 글인 군사용 암호 설계 원칙에서 따온 것이다. 한국어 위키백과에 실린 내용은 다음과 같다.

1. 암호체계는 수학적으로는 해독불가능하지 않다고 하더라도, 실질적으로 그래야한다.
2. **암호체계는 비밀에 부쳐질 필요가 없어야만 하며, 적의 손에 떨어지더라도 문제가 없어야 한다.**
3. 키는 글로 쓰여지지 않더라도 교환 혹은 보관할 수 있어야 한다. 당사자들의 의지에 의해서 바뀌거나 수정될 수 있어야 한다.
4. 전신에 적용할 수 있어야 한다.
5. 이동이 가능해야하며, 암호 체계의 사용과 기능을 위해 여러 사람의 협력을 필요로 하지 않아야 한다.
6. 마지막으로, 시스템의 활용을 요구하는 여러 상황들이 주어졌을 때, 암호 체계는 이용이 쉬워야 하며, 정신적인 압박감이나 여러 규칙들의 관찰을 필요로 하지 않아야 한다.

이 중 두 번째 `암호체계는 비밀에 부쳐질 필요가 없어야만 하며, 적의 손에 떨어지더라도 문제가 없어야 한다.`가 케르크호프스의 원칙으로 알려졌으며 소프트웨어적으로 표현한다면 암호화 알고리즘이 노출되더라도 안전해야 한다고 할 수 있다. 이 말처럼 이미 HTTPS나 이 글에서 다루는 비밀번호 관리자 시스템 등 많은 영역에서 AES, RSA 등 공개된 암호화 알고리즘을 사용하지만 충분히 안전하다.

알고리즘이 공개되어도 안전할 수 있는 이유는 **비밀 키**에 있다. 현대에서 사용되는 대부분의 알고리즘은 비밀 키를 다른 사람들이 모른다면 알고리즘이 알려지더라도 암호문을 안전하게 전달할 수 있다. 오히려 **알고리즘은 공개하여 더 많은 사람들이 검증하고 개선할 수 있도록 하는 것이 좋다.**

# 개인 비밀번호 관리자

보통 브라우저나 OS에서 제공하는 비밀번호 관리자 시스템은 사용자 개인을 위해 만들어졌다. 이를 이용하면 어렵게 만든 비밀번호를 외우지 않더라도 쉽게 로그인하는 것이 가능하기에 매우 편리하다. 하지만 쓰면서도 정말 안전하게 맞는지 의심이 들 수 있다. 개인 비밀번호 관리자가 어떻게 돌아가는 지 이해하기 위해선 두 가지 개념을 알아야 한다. 바로 **마스터 패스워드**와 **대칭키 암호화**다. 실제 제품에는 보안을 위해 더 많은 기술이 필요하겠지만 가장 핵심적인 기술은 이 두 가지라고 할 수 있다.

## 마스터 패스워드

마스터 패스워드는 암호화되어 저장한 모든 비밀번호를 복호화할 수 있는 키를 의미한다. 이말은 즉, 마스터 패스워드이 유출되면 모든 비밀번호가 유출된다는 것을 의미한다. 또한, 유실할 경우 저장된 모든 비밀번호를 알 수 없게 되버린다. 따라서 이 마스터 패스워드는 안전하게 보관해야 한다. 다만, 유실의 경우 다른 특수한 기술을 사용하여 복구하는 방법이 있을 수 있다.

보통 마스터 패스워드는 그대로 사용하지 않고 사용자가 입력한 값을 해싱(Hashing) 알고리즘을 통해 만들어 낸다. 해싱 알고리즘은 단방향 암호화라고도 부르는데 그 이유는 받은 쪽에서 복호화가 불가능하기 때문이다. 오로지 받은 평문을 해싱하여 저장된 해싱값과 일치하는지 확인하는 것만 가능하다.

<Image src="/images/2024-04-14-encrypted-vault-system/hashing-algorithm.png" />

이를 이용하여 사용자가 입력한 마스터 패스워드를 해싱하여 비밀 키를 만들어낸다. 이렇게 만들어진 비밀 키를 저장하여 이후 사용자가 보낸 마스터 패스워드가 진짜인지 확인하는 용도로 사용할 수 있다.

## 대칭키 암호화

대칭키 암호화는 하나의 비밀 키를 이용하여 암호화하고 복호화하는 알고리즘을 의미한다. 

<Image src="/images/2024-04-14-encrypted-vault-system/symmetric-key-algorithm.png" />

대표적으로 AES 알고리즘이 있으며 이를 이용하여 사용자가 추가할 비밀번호를 암호화하여 저장할 수 있다. 또한, 사용자가 비밀번호를 요청할 때 이 비밀 키를 이용하여 복호화하여 반환할 수 있다.

## 정리

개인 비밀번호 관리자는 사용자가 입력한 마스터 패스워드를 해싱하여 비밀 키를 만들고 이를 저장하여 검증에 이용한다. 검증에 성공했다면 마스터 패스워드를 이용하여 대칭키 암호화로 추가할 비밀번호를 암호화한다. 사용자가 만약 비밀번호를 요청하면 대칭키를 이용해 복호화하여 반환한다. 이렇게 하면 사용자는 하나의 마스터 패스워드로 모든 비밀번호를 관리할 수 있게 된다.

<!--

# 팀 단위 관리

마스터 패스워드
대칭키
비대칭키
하이브리드 암호화

## 영지식 증명

-->
<!-- 
# 마치며

암호라는 것은 모든 것이 공개되는 인터넷 세계에선 필수라고 할 수 있다. 그럼에도 불구하고 필자를 포함한 많은 개발자들이 암호에 대해 잘 알지 못한다. 이 도메인을 전문적으로 다루거나 종사하는 것이 아니라면 모든 것을 다 알아야할 필요는 없겠지만 단순히 패스워드를 해싱하는 수준에서 벗어나 더 넓은 세계를 탐구해보는 것은 좋을 것이다.

참고로 이 글에서 쓰여진 코드는 정말 안전한지 검증된 것은 아니다. 따라서 실제 제품에 반영한다면 충분히 검증하며 구현하는 것을 권장한다. 여기서 사용된 알고리즘은 보편적으로 사용하는 것을 택했으며 더 안전한 방법이 있을 수 있다. -->