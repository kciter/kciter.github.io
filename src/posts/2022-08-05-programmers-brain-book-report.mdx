---
title: "올바른 코드를 위한 끝없는 고찰"
categories: book-report
tags: [book]
image: /images/2022-08-05-programmers-brain-book-report/thumbnail.png
comments: true
draft: false
---

> 코드 잘짜기 위해서 뇌 과학까지 알아야하다니

평소 이 책에 대해서 극찬하는 글을 자주봤는데 기대했던 것 이상으로 좋은 책이었다. 평소에 올바른 코드란 무엇인지에 대해서 정말 많은 고민을 했는데 이 책을 접한건 큰 행운이라 생각된다. 읽기 전엔 위와 같은 생각이었지만 읽고 난 후에는 역시 지식은 넓을 수록 좋다는 것을 다시금 깨달았다.

이 책은 들어가며 간단한 코드 예제를 보여주며 예제 코드를 왜 읽기 힘든지, 왜 이해하기 어려운지를 설명하며 시작한다. 책 내용을 따르면 우리 뇌는 다음과 같은 세 가지 방식으로 기억한다고 한다.

* 장기 기억 (Long term memory, LTM)
* 단기 기억 (Short term memory, STM)
* 작업 기억 (Working Memory)

우리가 코드를 바라볼 때 이해하기 쉬운 코드인지 아닌지는 이 세 기억 방식에 의해서 판단된다고 한다. 이 기억 방식들에 대한 설명 이후로 이 책은 세 가지 기억 방식을 통해 프로그래머가 어떻게 코드를 읽고 이해하는지, 그리고 뇌 과학에 기반하여 어떻게 코드를 작성하는 것이 좋은지 가이드해준다.

책의 모든 내용을 이곳에 정리하는 것보단 한 번 꼭 읽어보는 것을 추천하는 책이다. 이 책에서 인상 깊었던 내용만 몇 가지 뽑아 정리하면 다음과 같다.

# 인상 깊었던 내용

## 인지 부하

작업 기억 공간은 정보를 처리하는 역할로 한 번에 너무 많은 것을 처리하려 하면 과부하 상태가 된다고 한다. 이 부분은 사람마다 다를 수 있지만 협업을 한다는 것은 다양한 사람을 고려해야 한다는 것은 분명하다.

이 인지 부하를 줄이기 위한 방법도 책에 소개가 되어있는데 그중 인상 깊었던 것은 프로그래밍 언어의 구성 요소 중 생소할 수 있는 것은 다른 것으로 대체하는 것이다.

예를 들어, Python의 경우 흔히 없는 독특한 문법이 몇 가지 있는데 그 중 comprehension이라는 문법이 있다. 코드로 표현하면 다음과 같다.

```python
# comprehension을 사용하지 않은 경우
sum = 0
for i in range(1, 10):
    sum += i
print(sum)

# comprehension을 사용한 경우
print(sum(i for i in range(1, 10)))
```

위 코드에서 윗부분과 아랫부분은 동일한 결과를 나타내는 코드다. 만약 comprehension을 아는 개발자라면 아래 코드도 이해하기 쉽겠지만 만약 모르는 개발자라면 가독성이 좋지 않을 것이라고 생각한다. 물론 보통은 같이 일하는 개발자들은 대체로 같은 기술을 사용하기 때문에 이런 작은 부분에서 문제가 생기진 않겠지만 언제든지 다른 사람은 모를 수 있음을 염두에 두고 코드를 작성하는 것이 좋겠다고 느꼈다.

## 이름에 대하여

이 책에서는 함수, 클래스, 변수 이름에 대한 중요성도 말하고 있다. 이 부분에 대해서는 평소 선언적으로 작성하는 것이 중요하다고 생각하는데, 예를 들어 `!isEmpty()`와 `isNotEmpty()`를 보았을 때 어떤 것이 가독성에 좋은지 생각했을 때 큰 차이가 없다고 생각할 수 있지만 코드 분석을 하다 보면 후자가 더 가독성에 좋다는 것을 알 수 있다. 이것처럼 프로그래밍 언어에서만 사용되는 규칙이나 특수 문자를 더하는 것보다 정확한 단어를 사용하는 것이 가독성에 좋기 때문에 함수나 클래스, 변수명이 중요하다는 것에는 큰 공감을 했다.

# 앞으로 어떻게 개발할까?

사실 책을 읽고 나서 앞으로 어떻게 하는 게 좋을까 고민했지만, 책에서 말한 것처럼 처음에 정한 규칙을 벗어나는 것은 쉽지않다. 그래도 부분적으로 개선할 수 있는 부분이 있을 것이라 생각하는데, 위에서 작성한 인상 깊었던 부분이 마침 평소에 고민하고 있던 부분과 일치해서 방향성이 잡힌 것 같다.

## 선언적으로 작성하기

본래 객체지향은 가독성이 좋지 않은 방법론이라고 한다. 그 이유는 객체의 관계를 한 눈에 알 수 없기 때문이다. 따라서 UML이나 문서를 보기 전까진 로직을 쉽게 파악하기 힘들다. 객체를 포기할 수는 없어도 어느 정도 가독성있게 작성할 수는 있을 것이라 생각한다. 클래스는 한 가지 책임을 가져야하고 함수는 한 가지 일을 해야한다라는 말은 객체지향 프로그래밍에서 굉장히 유명한 말이다. 물론 급하게 작성하거나 오버 엔지니어링이 될 수 있기에 이 유명한 말을 무시하는 경우도 종종 있다. 그렇지만 다시 이 점을 상기하고 함수의 추상 정도를 높이고 최대한 선언적으로 작성하려고 한다. 예를 들어 코드로 표현하면 다음과 같다. 여기서는 너무 길어지지 않도록 클래스 선언은 제외한다.

```kotlin
// Kotlin
fun sumOfOddNumbers(n: Int): Int {
  var sum = 0

  for (i in 1..n) {
    if (i % 2 == 1) {
      sum += i
    }
  }

  return sum
}

fun main() {
  print(sumOfOddNumbers(10))
}
```

위 코드는 n까지의 홀수 합을 구하는 단순한 코드다. 이렇게 사용해도 충분히 괜찮지만 다음과 같이 구현할 수도 있다.

```kotlin
fun main() {
  print(
    generateSequence(0) { it + 1 } // 코틀린에서 제공하는 함수 사용
      .take(10)
      .filter { it % 2 == 1 }
      .fold(0) { a, b -> a + b }
  )
}
```

generator를 이용하여 지연 평가를 통해 구현하고 선언적으로 무엇을 필터링할 것인지, 필터링한 데이터를 어떻게 더할 것인지를 표현했다. 만약 이 부분을 좀 더 가독성 있게 만든다면 다음과 같이 표현할 수 있을 것이다.

```kotlin
fun generateSequentialList(n: Int) = generateSequence(0) { it + 1 }.take(n)
fun Sequence<Int>.filterOdd(): Sequence<Int> = this.filter { it % 2 == 1 }

fun main() {
  print(
    generateSequentialList(10)
      .filterOdd()
      .sum()
  )
}
```

위처럼 이미 작성된 코드를 통해 좀 더 선언적으로 작성하는 것도 가능하다. 지연 평가를 안 쓰더라도 다음과 같이 함수 합성을 통해 작성하는 것도 가능하다.

```kotlin
infix fun <F : (T1) -> T2, T1, T2, T3> F.andThen(n: (T2) -> T3): (T1) -> T3 = { n(this(it)) }
fun createSequentialList(n: Int) = List(n) { it + 1 }
fun filterOdd(list: List<Int>) = list.filter { it % 2 == 1 }
fun sum(list: List<Int>) = list.sum()

fun main() {
  val sumOfOddNumbers = ::createSequentialList andThen
    ::filterOdd andThen
    ::sum
  print(sumOfOddNumbers(10))
}
```

사실 이 부분은 사실 함수형 패러다임이 들어가기 때문에 기초가 되는 코드를 작성하는 것은 어려울 것이라 생각한다. 하지만 일단 기초가 되는 코드를 작성하고 나면 쉽게 확장하고 재사용 할 수 있다는 것이 장점이다. 그렇지만 이처럼 더 재사용할 수 있도록 추상화하고 로직을 순차적으로 봐도 이해할 수 있도록 개선하는 것이 가능하다. 물론 말은 쉽고 행동은 어렵기 때문에 얼마나 적용할 수 있을지는 모르겠다.

# 결론

굉장히 인상 깊고 신선한 책이었다. 아직 올바른 코드란 무엇인가에 대한 고민이 전부 해결되진 않았지만, 이 책을 읽고 나서 안개가 걷힌 기분을 느꼈다. 사실 아직 모든 내용을 읽지 않아서 완독하면 다시 정리해봐야겠다.