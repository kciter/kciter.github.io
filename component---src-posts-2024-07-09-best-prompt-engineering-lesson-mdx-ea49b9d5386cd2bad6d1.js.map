{"version":3,"file":"component---src-posts-2024-07-09-best-prompt-engineering-lesson-mdx-ea49b9d5386cd2bad6d1.js","mappings":"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","sources":["webpack://kciter.so/./src/posts/2024-07-09-best-prompt-engineering-lesson.mdx","webpack://kciter.so/./src/components/Image/index.tsx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport Image from '@components/Image';\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    blockquote: \"blockquote\",\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h1: \"h1\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.blockquote, null, \"\\n\", React.createElement(_components.p, null, \"프롬프트 엔지니어링은 더 많은 사람이 프로그래머가 될 수 있는 세상이 온 것을 의미합니다.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"\\\"이제는 AI가 가치있다는 것을 인정하지 않을 수 없다. 실제로 ChatGPT와 Copilot을 사용하면서 AI가 얼마나 빠르게 발전하고 있는지를 느낄 수 있었다. 이러한 AI의 발전으로 인해 개발자가 생각할 시간을 줄여주며 반복적인 일을 대신해주기에 정말로 많은 개발자가 진짜 \", React.createElement(_components.strong, null, \"Develop\"), \"을 할 수 있는 기회를 제공해준다.\\\"\"), \"\\n\", React.createElement(_components.p, null, \"그런 생각을 떨칠 수 없었기에 최근에 서점으로 달려가서 보이는대로 AI를 다루는 책을 읽기 시작했다. 읽었던 책 중에서 가장 친절하고 이해하기 쉬운 책이 바로 \", React.createElement(_components.a, {\n    href: \"https://product.kyobobook.co.kr/detail/S000213362002\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"최고의 프롬프트 엔지니어링 강의\"), \"였다. 정확히는 LLM과 프롬프트 엔지니어링에 대해 다루는 책이지만 LLM이 등장하기까지의 역사도 설명해 주기에 흥미롭게 읽을 수 있었다. 너무 어려운 부분은 배제하고 여러 도식과 이미지를 이용하여 LLM에 대해 잘 모르는 나도 금방 이해할 수 있었다. 얼마나 편하게 읽었냐면, 서점에서 절반 읽고 이후에 구매한 후 집에 돌아와 완독했으니 하루가 지나기도 전에 다 읽은 샘이다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"소프트웨어-30\"\n  }, React.createElement(_components.a, {\n    href: \"#소프트웨어-30\"\n  }, \"소프트웨어 3.0\")), \"\\n\", React.createElement(_components.p, null, \"인상적이었던 내용은 소프트웨어의 진화 과정을 3단계로 나눴다는 점이다. 아직 이런 표현을 접해보지 않았기에 실제로 널리 쓰이는 표현인지는 모르겠지만 소프트웨어의 유형을 AI 기준에 맞춰 표현하기엔 적절하다 생각했다.\"), \"\\n\", React.createElement(_components.p, null, \"소프트웨어 1.0은 개발자가 대부분 하는 작업이다. 적절한 데이터와 알고리즘을 이용하여 데이터를 조작하고 결과를 도출하는 \", React.createElement(_components.strong, null, \"결정론적인 방법\"), \"이다. 대부분 문제는 없지만 \", React.createElement(_components.strong, null, \"비결정론적인 문제\"), \"에 대해서는 대응하기 어렵다. 예를 들어, 감정을 인식한다거나 대화를 하는 등에 대해서는 소프트웨어 1.0으로는 대응하기 어렵다. 이는 지금까지 무수히 많은 경우의 수로 대응하려한 많은 프로젝트의 실패가 증명한다.\"), \"\\n\", React.createElement(_components.p, null, \"머신러닝이 급부상하면서 상황은 조금씩 변했다. 머신러닝 알고리즘을 통해 데이터를 학습시킨 모델을 통해 \", React.createElement(_components.strong, null, \"비결정론적인 문제\"), \"에 대응할 수 있게 되었다. 이를 소프트웨어 2.0이라고 부른다. 이러한 기술을 통해 사용자에게 적합한 제품을 추천하고 이미지에서 물체를 인식하는 등의 작업을 수행할 수 있게 되었다. 하지만 이 또한 최적화되지 않은 데이터에 대해서는 대응하기 어렵다는 문제가 있었다.\"), \"\\n\", React.createElement(_components.p, null, \"딥러닝이 발전하고 대규모 언어 데이터를 학습시킨 LLM이 등장하면서 소프트웨어 3.0이라는 새로운 시대가 열렸다. LLM은 \", React.createElement(_components.strong, null, \"프롬프트\"), \"라는 것을 통해 사용자가 원하는 것을 수행한다. 즉, 어느정도는 자연어를 통해 코딩을 하는 것과 같은 것이다. 개발자는 LLM의 등장으로 더 많은 문제를 해결할 수 있게 되었다. 앞으로 어떻게 될지 모르겠지만 다양한 문제를 해결할 수 있게 프롬프트 엔지니어링을 배워야한다는 점은 확실하다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"프롬프트-엔지니어링은-어려운가\"\n  }, React.createElement(_components.a, {\n    href: \"#프롬프트-엔지니어링은-어려운가\"\n  }, \"프롬프트 엔지니어링은 어려운가?\")), \"\\n\", React.createElement(_components.p, null, \"사실 개인적인 생각으로 프롬프트 엔지니어링이 그렇게 어렵게 느껴지지는 않았다. 물론 LLM이 어떻게 동작하는지에 대한 이해가 필요하긴 하지만, 실제로 업무 생산성을 위해 프롬프트를 작성하는 것이 그리 어렵지 않았다. 물론 혼자 사용하는 것이 아닌 제품 기능에 반영하려면 검증과 평가 작업도 필요하기에 많은 시행착오와 경험이 필요할 것 같다.\"), \"\\n\", React.createElement(_components.p, null, \"필자는 아직 학습량이 많지 않고 실제 제품에 운용한 경험도 부족하다. 그러나 어느 정도 IT와 개발에 대한 지식이 있다면 지래 겁먹고 시작 못 할 정도로 어렵지는 않다고 생각한다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"마치며\"\n  }, React.createElement(_components.a, {\n    href: \"#마치며\"\n  }, \"마치며\")), \"\\n\", React.createElement(_components.p, null, \"이 책은 프롬프트 엔지니어링에 대한 전반적인 이해를 얻을 수 있는 좋은 책이었다. 아무래도 직접 많은 실습을 해보는게 중요하겠지만 이 책에서 소개해주는 여러 방법을 여러 예제와 함께 쉽게 설명해주기에 실습해보는 것은 어렵지 않을 것이다.\"), \"\\n\", React.createElement(_components.p, null, \"여담으로 앞으로 만들 제품에 AI에 대한 기능을 넣을 날이 얼마 남지 않았다. 그렇지만 아직 제대로된 AI 제품을 만들기엔 경험과 학습이 부족하고 느낀다. 프롬프트 엔지니어링을 넘어서 더 많은 기술에 대한 학습을 해봐야겠다.\"), \"\\n\", React.createElement(_components.p, null, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<code class=\\\"language-text\\\">P.S. 만약 좋은 책이 있다면 추천 부탁드립니다. 🙇‍♂️</code>\"\n    }\n  })));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import React, { useCallback, useState } from 'react';\nimport ReactDOM from 'react-dom';\n\ninterface ImageProps {\n  src: string;\n  caption?: string;\n  width?: number;\n  maxWidth?: number;\n  expandable?: boolean;\n}\n\nconst Image = ({ src, caption, width, maxWidth, expandable }: ImageProps) => {\n  const [isExpanded, toggleExpanded] = useState(false);\n\n  return (\n    <figure>\n      <img\n        src={src}\n        width={width || '100%'}\n        style={{ cursor: expandable ? 'zoom-in' : 'default', maxWidth }}\n        onClick={expandable ? () => toggleExpanded(true) : undefined}\n      />\n      {caption && <figcaption dangerouslySetInnerHTML={{ __html: caption }} />}\n      {isExpanded &&\n        ReactDOM.createPortal(\n          <div\n            style={{\n              position: 'fixed',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: '100%',\n              cursor: 'zoom-out',\n              backgroundColor: 'rgba(0, 0, 0, 0.7)'\n            }}\n            onClick={() => toggleExpanded(false)}\n          >\n            <div\n              style={{\n                borderRadius: 8,\n                maxWidth: 1200,\n                width: '80%',\n                position: 'fixed',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                backgroundColor: 'white'\n              }}\n            >\n              <img src={src} width=\"100%\" />\n            </div>\n          </div>,\n          document.body\n        )}\n    </figure>\n  );\n};\n\nexport default Image;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","blockquote","p","strong","a","h1","span","_provideComponents","components","React","href","rel","id","dangerouslySetInnerHTML","__html","wrapper","MDXLayout","_ref","src","caption","width","maxWidth","expandable","isExpanded","toggleExpanded","useState","___EmotionJSX","style","cursor","onClick","undefined","ReactDOM","position","top","left","height","backgroundColor","borderRadius","transform","document","body","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}