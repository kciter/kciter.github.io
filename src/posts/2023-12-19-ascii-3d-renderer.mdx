---
title: "ASCII 3D 렌더러 만들기"
categories: dev
tags: [renderer, 3d]
image: /images/2023-12-19-ascii-3d-renderer/thumbnail.png
comments: true
draft: false
hide: false
---

import Image from '@components/Image';
import { SpinningCube } from '@materials/2023-12-19-ascii-3d-renderer';

필자는 쓸데없지만 재밌는 프로그램을 만들면서 공부하는 것을 좋아한다. 최근에 정신적으로 에너지가 바닥나고 있다는 것을 느껴 작년에 재미로 만들었던 [Jazzlang](https://kciter.so/posts/crafting-esolang/)과 같이 정신적 에너지를 채워줄만한 재미를 느끼고 싶었다. 그래서 무언가 할만한 것을 찾던 중 작년 이맘때 쯤 재밌는 [유튜브 영상](https://www.youtube.com/watch?v=p09i_hoFdd0)을 봤던 것이 생각났다. 영상에서는 **CLI 환경에서 큐브를 회전시키는 프로그램**을 처음부터 끝까지 조용히 코딩하는 것을 보여준다. 해당 영상에서 보여주는 결과를 웹에서 보여줄 수 있도록 구현하면 다음과 같다.

<div style="box-shadow: 1px 1px 2px 2px rgba(0, 0, 0, 0.1); border-radius: 4px; padding: 16px; width: 80%; margin: 0 auto 8px auto">
  <SpinningCube />
</div>
<figcaption>마치 상자가 회전하는 것처럼 보인다</figcaption>

필자는 굉장히 신선하고 재밌는 아이디어라고 생각했다. 영상에서 아쉬웠던 점은 오직 큐브만 보여주고 있으며 빛 방향에 기반한 명암을 표현하거나 카메라 사용을 하는 것이 아니라는 점이다. 그렇지만 훌륭하게 입체감을 표현하고 있기에 이 아이디어를 참고하여 `CLI 환경에서도 3D 렌더링을 할 수 있지 않을까?`라는 생각을 하게 되었다. 

# 어떻게 ASCII를 3D처럼 보이게 할까?

3D 렌더링은 빛과 그림자, 최적화, 쉐이더, 충돌 처리, 물리 계산 등 굉장히 난이도가 높은 기술이 포함된다. 하지만 우리는 단순히 3D 물체를 화면에 그리기만 할 것이기 때문에 몇 가지 기본적인 기술만 있으면 된다. 우선 화면에 나오는 물체를 왜 3D처럼 인식을 할까? 답은 간단하다. 스크린을 통해 **원근감**을 표현했기 때문이다. 사람이 원근감을 느끼도록 만드는 방법은 다양하지만 CLI 환경에서 쓸 수 있는 것은 **선과 명암**이라 생각한다.

<Image src="/images/2023-12-19-ascii-3d-renderer/perspective.png" caption="겨우 선 몇 개 공간을 표현할 수 있다" />

선을 이용하여 원근감을 표현하는 방법은 간단하다. **멀리있는 것은 결국 한 점으로 모인다**는 사실을 이용할 수 있다. 이를 미술 용어로 [소실점](https://ko.wikipedia.org/wiki/%EC%86%8C%EC%8B%A4%EC%A0%90)이라 부른다. 이러한 소실점은 여러 개가 있을 수 있다.

<Image src="/images/2023-12-19-ascii-3d-renderer/shade.jpeg" caption="빛과 그림자를 통해 입체감을 표현할 수 있다" width="70%" />

명암을 포함한 원근감을 표현하는 방법은 더욱 간단하다. **빛이 있는 곳은 밝게, 빛이 없는 곳은 어둡게** 표현하면 된다. 이를 통해 물체의 입체감을 표현할 수 있다.

그럼 이제 ASCII 만으로 원근감, 입체감을 표현할 방법을 찾아야한다. 

# 기본 지식

이 재밌는 아이디어를 실현시키기 위해서 몇 가지 기본적인 지식이 필요하다. 3D 렌더링을 하기 위해서는 **3D 공간 좌표를 2D 공간 좌표로 변환**시켜야 한다. 이를 위해서는 다음과 같은 지식이 필요하다.

## 수학적 지식
* 벡터
* 행렬 연산
* 삼각함수

## 3D 그래픽스 지식
* 폴리곤 (삼각형)
* 빛과 그림자

# 설계 해보기

## 프로세스

## 필요한 객체

# 구현하기

# 마치며