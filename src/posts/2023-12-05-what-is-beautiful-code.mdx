---
title: "아름다운 코드에 대하여"
categories: life
tags: []
image: /images/2023-12-05-what-is-beautiful-code/thumbnail.png
comments: true
draft: false
hide: false
---

import Image from '@components/Image';

> Beauty is mute deception. - Theophrastos

기원전, 테오프라스토스라는 사람은 **'아름다움은 말 없는 속임수'**라는 말을 했다. 언뜻보면 아름다움이란 사람들마다 비슷하게 생각하는 것 같으면서도 각자 생각하는 기준이 다르다. 말 그대로 아름다움은 **보편적이면서 개인적**인 것이다. 그래서 테오프라스토스는 실체를 알 수 없는 아름다움에 대해 속임수라는 박한 평가를 내린 것이 아닐까 싶다. 애초에 아름다움이란 **추상적인 개념**인데 기준을 정할 수 있을까?

필자는 개발자 모임을 가거나 강의 중 아름다운, 이쁜, 좋은 등 앞에 수식어가 붙는 코드에 대한 질문을 여러 차례 받았다. 그럴때마다 '가독성이 좋은', '유지보수가 쉬운', '재사용성이 높은' 등의 답변을 했지만 스스로도 만족스럽지 못한 답변이라 느낀적이 많았다. 앞서 테오프라스토스가 말한 것과 비슷한 말이 개발 업계에도 존재한다. 바로 **은 총알은 없다**는 말이다.

<Image src="/images/2023-12-05-what-is-beautiful-code/silver-bullet.jpeg" caption="은 총알은 없다라는 말이 은총알이다" />

은총알은 없다라는 말은 업계 전반적으로 굉장히 많이 쓰이는 표현이다. 맞는 말이지만 필자는 개인적으로 이 말은 굉장히 조심스럽게 사용해야 한다고 생각한다. 정말 좋은 해결 방법을 찾는 노력 대신 이 표현을 통해 넘어가는 경우가 많기 때문이다. 앞서 질문에 대해 '가독성이 좋은', '유지보수가 쉬운', '재사용성이 좋은'이라는 답변을 했지만 깊게 들어가면 결국 '상황에 따라 다르다'와 같은 표현으로 이어진다. 이는 결국 은 총알은 없다는 말과 같은 말이다.

대체 아름다운 코드란 대체 무엇인가. 진지하게 개발자를 업으로 삼는 사람이라면 한 번쯤 고민해 본 적이 있을 것이다. 그렇지만 그 고민은 대게 일이 바빠 다음으로 넘기거나 정답은 없다는 결론에 이르게 된다. 필자 또한 그렇다. 그렇지만 이번 기회에 은 총알은 없다와 같은 말로 회피하지 않고 진지하게 생각해 보기로 생각했다. 이때 고민하며 나온 생각을 글로 정리해 보고자 한다.

# 아름다움이란?

필자는 아름다운 코드를 정의하려면 먼저 **아름다움이라는 것이 무엇인지 이해해야 한다**고 생각했다. 신경미학이라는 아름다움에 대해 뇌과학적 접근을 하는 학문도 있지만 필자는 이에 대해서 문외한이고 자료도 많지 않아 다른 방법으로 접근하기로 했다.

우선 아름다움이란 **사람이 느끼는 가치**라 할 수 있다. 이는 사람마다 다르게 느낄 수 있으며 또한 시대에 따라 변할 수 있다. 그리고 대상에 따라서도 기준이 다르다. 다음 이미지를 참고해 보자.

<Image src="/images/2023-12-05-what-is-beautiful-code/kinds-of-beauty.png" />

좌측부터 고흐의 별이 빛나는 밤, 몬드리안의 컴포지션, 자연 풍경 사진과 오일러 등식이다. 이 네 가지는 큰 연관이 없어 보이지만 많은 사람들이 아름다운 것으로 생각한다는 공통점이 있다. 그렇다면 이 네 가지가 모두 아름다운 것이라면 사람이 아름답다 느끼는 기준이 무엇일까? 필자는 여러 자료를 조사하며 나오는 키워드를 카테고라이징 했더니 `놀라움 / 새로움 / 안정성 / 편안함 / 단순성`으로 정리가 됐다.

앞서 말한 다섯 가지는 아름다움에 대한 키워드로서 자주 나오는 것들을 묶어서 한 단어로 표현한 것이다. 굉장히 다양한 표현들이 나왔지만 일반화해 보면 위와 같다. 이를 다시 둘로 나눠보면 `놀라운 아름다움`과 `자연적 아름다움`으로 나눌 수 있다. 위 이미지에 나온 네 가지를 분류하면 다음과 같다.

<Image src="/images/2023-12-05-what-is-beautiful-code/beauty-position.png" />

몬드리안의 컴포지션은 새로운 패러다임을 제시했기에 놀라운 아름다움으로 분류했다. 그리고 자연 풍경은 말 그대로 자연적 아름다움으로 분류했다. 고흐의 별이 빛나는 밤은 자연 풍경을 묘사했지만 현실 세계와는 다른 표현 방식을 사용했기에 놀라운 아름다움과 자연적 아름다움 중간으로 분류했다. 마지막으로 오일러 등식은 많은 수학자들이 경이롭게 바라보기 때문에 놀라운 아름다움으로 분류했다.

사실 필자는 몬드리안의 컴포지션과 오일러 등식을 보며 아름다움을 크게 느끼지는 못했다. 그저 다른 이들이 느낀 감정을 받아들였을 뿐이다. 왜 필자는 아름다움을 느끼지 못했을까? 그 이유는 **깨달음**이 없었기 때문이다. 놀라운 아름다움을 알기 위해서는 사물에 대한 이해가 필요하며 그 말은 즉, 이해할 수 있는 **기본적인 지식이 필요함**을 뜻한다. 독자 여러분은 <code>e<sup>iπ</sup>+1 = 0</code>라는 식을 봤을 때 어떤 감정을 느꼈는가? 누군가는 아름답다 느꼈을 것이고 누군가는 관심이 없거나 **두려움**을 느꼈을 것이다. 이는 많은 이들이 수학을 두려워하는 이유기도 하다. 정리하면 이해할 수 없는 사물에 대해선 아름다움 대신 두려움을 느낀다는 것이다.

## 아름다움은 생존 전략
왜 우리는 이해할 수 없는 것들에 대해 두려움을 느끼게 됐을까? 시간이 괜찮다음 다음 영상을 시청해보자.

<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.1972%;"><iframe src="https://www.youtube.com/embed/-O5kNPlUV7w?si=k4VmfCFuB8UVqNjq" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute; border: 0;" allowfullscreen allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe></div>

앞 부분 내용을 요약하자면 인류는 안전하고 도움이 되는 것에 아름다움을 느꼈기에 **아름다움은 생존을 위한 것**이며 이에 대한 사고가 지금까지 발전했다는 것이다. 따라서 우리가 모르는 것, 이해할 수 없는 것에 대해선 불쾌감과 더불어 두려움까지 느끼게 한다고 할 수 있다. 이는 코드에도 그대로 반영이 된다. 우리가 이해할 수 없는 코드에 대해 불안함을 느끼고 그것이 아름답지 못한, 더러운 코드라고 느끼게 된다.

여기서 주의할 점으로 지식이 부족해서 더럽다고 느끼는지, 정말 이해하기 어렵게 작성되어서 더럽다고 느끼는지 구분할 필요가 있다.

# 아름다운 코드

코드는 왜 아름다워야 할까? 그냥 일단 돌아가도록 만드는게 좋지 않을까?라고 생각할 수 있다. 물론 필자도 **제일 중요한 것은 동작하는 코드**라고 생각한다. 그렇지만 그에 못지않게 코드를 아름답게 만드는 것도 중요하다. 왜냐하면 코드라는 것은 **혼자 보는 것이 아니기 때문**이다. 코드는 언제든 다른 사람과 함께 볼 수 있고 코드 소유권이 나에게서 다른 사람으로 이관될 수도 있다. 따라서 **코드를 아름답게 만드는 행위는 배려이자 팀을 위한 활동**이라 할 수 있다. 그리고 만에 하나 혼자 일을 하더라도 코드를 아름답게 만드는 것은 중요하다. 이는 나 자신의 성장을 위한 드라이브의 원인이 될 수 있고 미래에 코드를 다시 들여다보는 나를 위함이기도 하다. 미래의 나는 사실상 타인이라고 봐도 무방하다.

## 아름다운 코드에 대한 정의

필자는 코드 또한 앞서 이야기했던 놀라운 아름다움과 자연적 아름다움으로 나눌 수 있다고 생각한다. 필자는 그 비율이 2:98로 극명하게 나뉜다고 생각한다. 여기서 놀라운 아름다움의 비율이 2%로 코드에서의 놀라운 아름다움이라는 것은 우리가 생각하지 못했던 방식으로 깔끔하게 문제를 해결하는 경우에만 느낄 수 있다고 생각하기 때문이다. 따라서 주니어 시기에는 비교적 자주 느낄 수도 있겠지만 점점 경력이 쌓일 수록 느끼기 힘들어진다. 그렇기 때문에 협업을 중시하는 실제 업무에선 놀라운 아름다움을 생각하기 보다는 대체로 **공학적으로 자연스러운 아름다움을 추구하는 것이 좋다**고 생각한다.

필자는 자연스럽게 아름다운 코드가 될 수 있는 조건을 다음과 같이 정의내렸다.

* 사회적
* 신뢰적
* 선언적
* 선형적

이 네 가지 조건은 다음과 같이 코드의 두 가지 요소를 구성한다.

<Image src="/images/2023-12-05-what-is-beautiful-code/parts-of-beautiful-code.png" />

사회적이고 신뢰적인 코드는 안정성을 보장한다. 그리고 선언적이고 선형적인 코드는 코드의 심미성을 보장한다. 어떻게 보면 너무 당연한 이야기일 수 있다. 하지만 우리가 자연 풍경을 볼때 편안한 마음을 느끼듯 코드를 볼 때 위화감을 못느끼고 편안한 감정을 느꼈다면 그것이 아름다운 코드라 할 수 있다.

## 사회적인 코드

사회적인 코드란 것은 본인뿐만 아닌 주변 상황을 모두 고려한 코드를 의미한다. 이는 **언어의 사회성**과 유사하다. 보통 코딩을 한다는 것은 수학적인 사고와 엮이는 경우가 많지만 필자는 언어적인 사고 또한 코딩 능력에 중요한 부분이라 생각한다.

사회적인 코드는 관습이나 규칙, 해야 하는 일인 미션에 따라 다를 수 있다. 관습은 패러다임이나 언어나 프레임워크의 공식 문서 스타일 가이드, 커뮤니티 표준이나 언어의 특성을 고려하는 것을 말한다. 독자분들 중 Python을 하는 분이 있다면 Pythonic 이라는 말을 들어본 적이 있을 것이다. 이는 얼마나 Python스럽게 코드를 작성했는지를 말하는데, 이런 것도 관습을 따랐는지를 의미한다.

다음으로 규칙을 따랐는지를 따질 수 있다. 사내 네이밍 규칙이나 설계 규칙, 사내에서만 사용되는 스타일 가이드 등을 말한다. 보통 스타일 가이드는 관습이나 커뮤니티 표준을 따르는 경우가 많지만, 가끔 회사 차원에서 재정의할 때도 있다. 예를 들어, Python은 보통 snake_case를 사용하지만 camelCase를 쓰겠다고 규칙을 정하면 그것을 따라야 한다. 마지막으로 고려할 것은 미션인데 해결해야 하는 문제를 의미한다. 문제에 따라 가독성보다는 성능이 우선일 수 있고 복잡한 도메인에 맞춰 코드 또한 복잡해질 수 있다.

앞서 언어의 사회성과 유사하다 한 것처럼 보편적인 규칙을 무시하고 혼자 엇나가면 그것이 옳은 방향이라 하더라도 다른 이들에게 불편을 줄 수 있다. 따라서 급진적인 것보다 서서히 바꿔나가는 방향이 좋다. 어떻게 보면 이런 것이 정치라고 할 수 있다.

## 신뢰적인 코드

신뢰적인 코드란 말은 너무 당연해 보인다. 누군가 만든 코드를 신뢰할 수 없다면 들어가서 까봐야 하는 코드가 되고 불편함을 느끼게 된다. 불편한 마음을 느끼게 된다면 필자 기준에선 아름답지 못한 코드라 할 수 있다. 신뢰성에 대한 측정은 여러 방법이 있지만 보통 사이드 이펙트가 존재하는지, 이것이 알려져 있는지, 예외가 있다는 것을 알 수 있는지, 결함이 있는지, 순수함수인지 멱등성이 있는지 등을 통해 알 수 있다. 참고로 앞서 말한 것과 별개로 당연히 버그나 결함은 치명적이기 때문에 없어야 한다. 다음 예시를 살펴보자.

```kt
// 🔴 - 실행 시점에 따라 함수 결과가 달라진다
var global = 0
fun sum(a: Int, b: Int): Int {
  global += 1
  return a + b + global
}

// 🟢 - 같은 입력에 대해 같은 출력을 보장한다
fun sum(a: Int, b: Int): Int {
  return a + b
}
```

첫 번째 코드를 자세히 살펴보면 실행 시점에 따라 결과가 달라진다는 것을 알 수 있기 때문에 신뢰할 수 없다. 반면 두 번째 코드는 순수 함수라 어떤 입력이 들어오더라도 같은 출력을 보장한다. 따라서 신뢰할 수 있다.

```kt
fun divide(a: Int, b: Int): Int {
  return a / b
}
```

그리고 코드엔 사이드 이펙트가 존재할 수 있다. 예를 들어 위 함수에서 `b`에 0 값이 들어와 에러가 발생한다면 사이드 이펙트가 있다고 볼 수 있다. 그렇지만 요즘에 와선 사이드 이펙트가 전혀 없는 프로그램을 만드는 것은 불가능하기 때문에 이를 최대한 신뢰성 있게 제공하기 위해 문서화를 작성하거나 예외가 있음을 알리는 방법을 사용할 수 있다.

## 선형적인 코드

선형적인 코드는 가독성에 좋다. 이를 더 풀어서 설명하자면 코드를 읽을 때 위에서 아래로 한 번만 읽어도 되는 것을 의미한다. 참고로 뇌과학적으론 우리가 사고할 때 사용하는 영역인 작업 기억 공간이 처리하기 쉬워진다. 다음 예시를 살펴보자.

```kt
// 🔴 - 루프를 머리에서 연산해야 한다
fun binaryToDecimal(input: String): Int {
  var decimal = 0
  var binary = input
  var power = 0

  while (binary.isNotEmpty()) {
    val lastChar = binary.last()
    binary = binary.dropLast(1)
    if (lastChar == '1') {
      decimal += 2.0.pow(power).toInt()
    }
    power += 1
  }
  
  return decimal
}

// 🟢 - 위에서 아래로 한 번만 읽으면 된다
fun binaryToDecimal(input: String): Int {
  return input
    .reversed()
    .mapIndexed { index, char ->
      if (char == '1') {
        2.0.pow(index).toInt()
      } else {
        0
      }
    }
    .sum()
}
```

첫 번째 코드는 루프를 돌리기 때문에 위아래로 왔다 갔다 해야 한다. 반면 두 번째 코드는 어떤 행위를 하는지 읽기만 하면 된다. 이에 대한 더 자세한 내용이 궁금하다면 필자가 작성한 [프로그래머를 위한 뇌 독후감](https://kciter.so/posts/programmers-brain-book-report)을 읽어보길 바란다.

## 선언적인 코드

선언적인 코드도 가독성에 좋다. 선언적인 코드라는 말이 조금 헷갈리게 느껴질 수 있다. 간략하게 표현하자면 코드에 무엇을 하는지 정확히 알리는 것으로 생각하면 편하다. 이를 위해서는 함수, 클래스, 변수명 등에 적절한 이름을 지정해 주는 것이 좋다. 실험을 하나 해보자. 다음 문장을 5초간 본 후 어떤 문장이었는지 기억해 보자.

> abk mrtpi gbar

5초면 생각보다 짧기 때문에 다 외우지 못한 사람이 꽤 많을 것이다. 그럼 이번엔 다음 문장을 5초간 본 후 어떤 문장이었는지 기억해보자.

> cat loves cake

이번엔 아주 쉬웠을 것이다. 아마 5초가 너무 길었을지도 모른다. 이 또한 뇌과학적인 부분이 존재한다. 우리의 뇌에는 단기 기억 공간(STM)이라는 부분이 존재한다. 이 부분은 정보를 일시적으로 저장하는 공간이다. 말 그대로 정보를 일시적으로 저장하기 때문에 다른 정보를 찾는 과정을 거치거나 시간이 지나면 잊게 된다. 앞 `abk mrtpi gbar`는 3개의 단어와 9개의 서로 다른 문자로 이루어져있다. 이는 STM의 용량을 훌쩍 넘어서는 크기기 때문에 외우기 어렵다. 반면, `cat loves cake`는 우리가 이미 알고있는 단어들로 이루어져있어 기억해야 할 항목이 3개 밖에 없다. STM 한도 이내기 때문에 외우기 쉽다.

따라서 선언적인 코드는 코드를 읽는데에 도움이 되고 이해하는 것이 쉬워진다. 따라서 마음이 편해진다고 볼 수 있다. 다음 예시도 살펴보자.

```kt
// 🟡 - 내용을 한 번 더 읽어야 한다.
fun main() {
  print(
    generateSequence(1) { it + 1 }
      .take(10)
      .filter { it % 2 == 1 }
      .fold(0) { a, b -> a + b }
  )
}

// 🟢 - 함수명에서 의도를 바로 파악할 수 있다.
fun main() {
  print(
    generateSequentialNumber(10)
      .filterOdd()
      .sum()
  )
}
```

첫 번째 코드도 충분히 선언적이지만 아래 코드와 비교하면 아래 코드가 더 명확하다는 것을 알 수 있다. 5초 안에 파악하느냐 1초 안에 파악하느냐 정도의 차이라 느낄 수도 있지만 이러한 차이가 모여서 큰 차이를 이룬다고 생각한다.

# 마음가짐

지금까지 아름다운 코드는 어떻게 구성되는지를 살펴보았다. 그렇지만 이 모든 내용을 다 지키면서 코드를 만들 수 있을까? 아마 힘들 것이다. 따라서 오히려 코드를 대하는 마음가짐이 더 중요하다고 생각한다. 필자가 생각하기로 두 가지 마음가짐이 필요하다. 

첫째는 아름다운 코드라는 것은 한 번에 뚝딱 나오는 게 아니라는 점이다. 현실엔 다양한 문제가 있으며 여러 명과 일하다 보면 정말 생각지도 못한 이슈가 발생한다. 그러다 보면 흔히 안좋다 말하는 코드를 작성할 때가 많다. 중첩된 if, 적절하지 못한 네이밍, 통일성 없는 규칙 등이 있을 수 있다. 그리고 다른 관점에서도 아름다운 코드가 아닐 수 있다. 바로 오버 엔지니어링이다. 무조건적인 디자인 패턴 적용이나 너무 과도한 추상화 등을 예로 들 수 있다.

두 번째는 완벽하게 아름다운 코드라는 것은 흔하지 않다는 점이다. 앞서 설명한 사회적, 신뢰적, 선형적, 선언적 네 가지를 모두 지킨 코드는 생각보다 많지 않다. 사이드 이펙트는 어쩔 수 없이 필요하며 크기가 적당한 함수, 객체만 작성한다는 것은 이상에 가깝습니다. 또한, 성능이 중요하다면 선형적이거나 선언적이지 않을 수도 있습니다. 이는 소규모 조직이며 빠르게 발전하는 소프트웨어일수록 더 그렇다.

따라서 한 번에 만드는 것보다 두 가지를 더 중요하게 생각해야 한다. 바로 **점진적인 코드 개선**과 **코드 수식**입니다. 참고로 여기서 말하는 수식이란 꾸며주는 것을 말한다.

### 점진적 개선

점진적 개선은 한 번에 완벽하게 코드를 작성하지 말고 괜찮은 품질을 계속 유지시키는 것을 말한다. 코드 개선이라하면 결국 리팩토링이라 할 수 있는데, 주변 코드는 계속 바뀌기 마련이고 그에 따라 리팩토링은 계속 필요하다. 완벽한 코드도 언젠가 훼손되기 때문에 너무 많은 시간을 들이지 않고 점검과 개선을 반복하며 적당한 품질을 유지시키는 것이 좋다. 앞서 설명한 네 가지 요소 중 하나가 조금 부족해도 괜찮다는 의미라고 할 수 있다. 필자가 생각하기로 100%가 가장 아름다운 코드라면 대략 70%~80% 정도의 품질을 유지하는 것이 중요하다.

<Image src="/images/2023-12-05-what-is-beautiful-code/check-improve-cycle.png" width="50%" caption="점검과 개선의 무한 반복" />

### 코드 수식

코드 수식은 코드를 아름답게 보이도록 꾸며주는 것을 말한다. 여러가지 방법이 있지만 주로 쓰이는 것은 **테스트, 코드 리뷰, 문서화, 주석**이 사용된다. 필자가 생각하기로 이 네 가지는 다음과 같이 코드의 요소를 보강해준다.

* 테스트 - 신뢰적
* 코드 리뷰 - 신뢰적, 사회적
* 문서화 - 신뢰적, 사회적
* 주석을 통한 설명 - 신뢰적, 선형적

주석을 통한 설명에 선형적이 있다는 것이 조금 의아할 수 있다. 필자가 생각하기로 주석이 존재한다면 루프 등을 생략할 수 있기 때문에 어느정도 선형적이게 읽을 수 있도록 도와준다 생각한다.

# 마치며

아름다운 코드에 대해선 아직도 고민할 것이 많다. 옛 말로 아름답다는 나 답다라는 뜻이라고 한다. 어쩌면 나의 경험과 고민이 축적된 코드가 나 다운 코드며 가장 아름다운게 아닐까 싶다.

참고로 이 글이 정답은 아니며 단지 필자 개인의 생각을 정리했을 뿐이다. 특히 아름다움에 대해 필자가 정의한 것은 뇌피셜이며 뇌과학적으로 진실이 밝혀진다면 헛소리로 치부될 가능성이 높다. 그럼에도 불구하고 아름다운 코드를 만들기 위한 개발자 개인의 치열한 고민의 흔적이라 생각해 준다면 감사할 것이다. 만약 아름다운 코드에 대한 의견이 있다면 언제든지 댓글로 남겨주길 바란다.

<!--
참고로 이 글에 대한 내용은 이 글을 쓰기 일주일 전에 오프라인 발표를 통해 먼저 공유했다. 발표 자료는 다음과 같다.

<div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.1972%;"><iframe src="https://present.do/@kciter/656d799fadca9f388ff98de5/embed?dss=true&dpm=false&dptm=SINGLE&page=0&dq=false&dbb=false&df=false&dst=false&dsh=false&dap=false%2Cfalse&dpl=false&dpt=false&dv=true&dpc=false&dz=false&dpbs=false&dpbm=false&ddt=false&dd=false&dtb=false&dw=false&ds=false&dp=false&dl=false&documentId=656d799fadca9f388ff98de5" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute; border: 0;" allowfullscreen scrolling="no" allow="encrypted-media;"></iframe></div>
-->