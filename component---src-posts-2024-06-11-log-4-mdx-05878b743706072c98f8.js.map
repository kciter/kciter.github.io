{"version":3,"file":"component---src-posts-2024-06-11-log-4-mdx-05878b743706072c98f8.js","mappings":"6QAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,MACFC,EAAAA,EAAAA,KAAsBL,EAAMM,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,wLAAyL,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,mNAAoN,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,iTAAkT,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,0QAA2Q,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,6LAA8L,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,wMAC/8C,CAKA,UAJA,SAAoBJ,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOQ,QAASC,GAAaP,OAAOC,OAAO,CAAC,GAAGE,EAAAA,EAAAA,KAAsBL,EAAMM,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWT,EAAOO,EAAAA,cAAoBR,EAAmBC,IAAUD,EAAkBC,EAC9H,C,qECeA,MAAMU,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBN,GAC/B,MAAMO,EAAoB,aAAiBF,GAG3C,OAAO,WACL,WAEE,MAA0B,mBAAfL,EACFA,EAAWO,GAGb,IAAIA,KAAsBP,EACnC,GACA,CAACO,EAAmBP,GAExB,C","sources":["webpack://kciter.so/./src/posts/2024-06-11-log-4.mdx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"유명 소설 ‘플랜더스의 개’ 주인공 네로는 마지막 순간 그토록 좋아했던 루벤스의 그림 앞에서 숨을 거둡니다. 이야기에서 언급되는 루벤스는 살짝 신성시 될 정도로 거장인 화가입니다. 재밌는 사실은 루벤스가 반박의 여지가 없는 거장이지만 대량 생산으로도 유명하다는 점입니다. 대량 생산과 거장이라니? 뭔가 어색하게 느껴집니다.\"), \"\\n\", React.createElement(_components.p, null, \"루벤스 공방을 방문한 덴마크 의사 오토 스페를링은 다음과 같이 말했습니다. “많은 젊은 화가들이 각자 캔버스에 작업하고 있었다. 그 그림들은 루벤스가 먼저 초크로 드로잉하고 색을 지시해 둔 작품들이며 마무리는 그가 직접 했다. 이 그림들은 루벤스 작품으로 인정받았다.” 여기서 중요한 것은 큰 그림을 그리고 마무리만 했음에도 루벤스 본인의 작품으로 인정받았다는 점입니다.\"), \"\\n\", React.createElement(_components.p, null, \"최근에는 AI의 급격한 발전으로 두려워하는 개발자가 많습니다. 저 또한 약간의 두려움과 한 땀 한 땀 코드를 짜는 손맛을 잃어 조금 불만이 있습니다. 그렇지만 AI 툴이 생산성에 큰 도움이 되는 것도 사실입니다. 루벤스가 큰 틀을 구상하고 그릴 영역을 젊은 화가들이 채웠듯, 개발자도 설계와 제품 개선에 더 신경쓰면서 구현 틀을 AI에게 맡길 수 있습니다. 그리고 마무리를 루벤스가 직접했듯 개발자도 적절한 마무리를 통해 좋은 품질의 코드를 생산하는 것이 가능합니다. AI가 도왔다고 해서 직접 짠 코드가 아니라고 비난할 사람은 없습니다.\"), \"\\n\", React.createElement(_components.p, null, \"저 또한 GitHub Copilot을 사용하며 AI의 도움을 받은 지 벌써 1년이 넘었습니다. 모든 면에서 도움이 된다고 말하면 거짓말이지만 생산성에 큰 도움이 되는 것은 사실입니다. 요즘은 AI의 동작을 어느 정도 예상하여 도움이 될 만한 곳에서 간단한 주석과 몇 글자를 타이핑한 후 3초 정도 기다립니다. 그러면 제가 원했던 코드를 만들어줍니다. 살짝 틀렸다면 마무리 교정만 조금 해주면 됩니다. 원래라면 몇 분 걸릴 일을 몇 초 만에 해주니 너무 마음이 편합니다.\"), \"\\n\", React.createElement(_components.p, null, \"개발자의 진정한 역할을 생각하면 AI를 두려워할 필요는 없습니다. 개발자는 제품을 만드는 사람입니다. 실제로 개발자는 코드만을 작성하지 않고 제품의 결함을 발견하고 부족한 부분을 개선하며 제품이 올바른 방향으로 성장할 수 있도록 도움을 줍니다. 그 과정에서 커뮤니케이션이 중요해지고 이는 아직 AI가 해결해 줄 수 없는 문제입니다.\"), \"\\n\", React.createElement(_components.p, null, \"그렇게 생각한다면 개발자 스스로 AI를 조수로서 이용해야 합니다. AI는 우리의 시간을 더 가치 있게 만들어줄 수 있습니다. 그리고 관리자 또한 어떻게 개발자를 AI로 대체하여 인건비를 줄일까를 고민할 것이 아닌 AI를 더 잘 활용하여 더 가치 있는 일을 할 수 있게 돕는 것이 좋다고 생각합니다. 오히려 그편이 비용을 훨씬 아끼는 길이라 생각합니다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","_provideComponents","components","React","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}