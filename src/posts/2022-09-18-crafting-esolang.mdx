---
title: "난해한 프로그래밍 언어 만들어보기"
categories: dev
tags: [만들어보기, 언어]
image: /images/2022-09-18-crafting-esolang/thumbnail.png
comments: true
draft: true
---

import Image from '@components/Image';

**잉여 코딩**이라는 말을 들어본 적 있는가? 잉여 코딩은 돈 버는데엔 쓸모없지만 취미로 즐겁게 코딩하는 것을 의미한다. 지난 주 정말 오랜만에 업무와 전혀 무관한 [잉여 코딩](https://github.com/kciter/jazzlang)을 했다. 최근 몇 년 사이엔 대부분 업무와 직간접적으로 연관이 있는 코딩만 했는데 조금 마음의 여유가 생겼나보다.

<Image src="/images/2022-09-18-crafting-esolang/jazzlang-repo.png" caption="잉여 코딩의 결과물" />

학창 시절에 들은 **"잉여 코딩을 하면 코딩 실력이 금방 좋아집니다"**라는 말은 아직도 마음에 새겨두고 있는 말이다. 나의 코딩 실력 자체는 업무에 도움이 되든 안되든 대부분 재미로 무언가를 만들 때 가장 크게 성장했다. 그래서 마음의 여유가 있는 당분간은 많은 시간을 할애할 수는 없겠지만 기회가 될 때마다 **만들어보기**라는 주제를 잡고 여러 재밌는 것들을 만드는 잉여 코딩을 해볼 생각이다.

# 난해한 프로그래밍 언어란?

그래서 이 포스팅에서 만들어볼 것은 난해한 프로그래밍 언어라는 특이한 언어를 만들어볼 것이다. 난해한 프로그래밍 언어는 해외에선 Esolang이라 부르는데 말 그대로 난해한 프로그래밍 언어(Esoteric programming language)의 준말이다. 

아마 SNS나 뉴스레터 소식을 자주 보시는 분이라면 가끔 이게 언어라고? 생각되는 신기한 언어들을 본적이 있을 것이다. 대표적으로는 [Brainfuck](https://ko.wikipedia.org/wiki/%EB%B8%8C%EB%A0%88%EC%9D%B8%ED%8D%BD)이 있고 국내 제작된 것 중에선 가장 바이럴이 잘된 [엄랭](https://github.com/rycont/umjunsik-lang)이라는 언어가 있다. 이런 언어들은 **난해한** 프로그래밍 언어라고 부르는 것 처럼 실제 업무에 사용할 수는 없지만 개발자의 호기심을 자극시키는 부분이 있어 때문에 많은 사람들에게 널리 알려져있다.

<Image src="/images/2022-09-18-crafting-esolang/brainfuck.jpeg" caption="이게... 코드라고?" />

위 이미지에 나오는 부호들의 모음은 실제로 실행되는 Brainfuck이란 언어의 코드다. 위 코드를 실행하면 `ROBBIE`라는 문자열이 출력된다. Brainfuck 외에도 Esolang은 많다. 만약 어떤 언어가 있는지 관심있다면 [Esolang Wiki](https://esolangs.org/)에서 더 찾아볼 수 있다.

# Brainfuck 소개
이제 독자 여러분은 여기서 말하는 **난해한**이 어느 정도인지 알게됐다고 생각한다. 그 결과 위 코드 내용조차 이해하지 못했는데 어떻게 언어를 만들까? 라는 생각이 들 수 있다. 그렇지만 이어서 스펙에 대한 설명을 읽고나면 생각이 바뀌게 될 것이다.

## 스펙 설명
우선 언어에 대한 이해가 필요하다. Brainfuck은 8개의 문자가 명령어로서 존재한다. 그 외의 문자는 무시된다. 여기서 피연산자(변수, 상수 등)는 존재하지 않는다. 명령어의 종류는 다음과 같다.

| <center>명령어</center> | 의미 |
|------|-----|
| <center>></center>  | 포인터 위치가 1 증가한다. |
| <center><</center>  | 포인터 위치가 1 감소한다. |
| <center>+</center>  | 포인터 위치에 해당하는 값이 1 증가한다. |
| <center>-</center>  | 포인터 위치에 해당하는 값이 1 감소한다. |
| <center>.</center> | 포인터에 해당하는 값을 ASCII 값으로 출력한다. |
| <center>,</center> | 포인터 위치에 입력받은 값을 저장한다. |
| <center>[</center>  | 포인터 위치에 해당하는 값이 0이라면 "]"로 이동한다. 0이 아니라면 다음 명령어로 이동한다. |
| <center>]</center>  | 포인터 위치에 해당하는 값이 0이 아니라면 "["로 이동한다. 0이라면 다음 명령어로 이동한다. |

포인터가 있는 언어에 대해 다뤄본 적이 있다면 반복문에 해당하는 `[`와 `]`를 제외하면 이해하기 쉬웠을 것이다. 만약 포인터라는 것이 이해하기 어려웠다면 **배열**을 떠올려보자. `>`를 사용하면 배열을 가리키는 index가 1 증가하는 것이고 `<`를 사용하면 index가 1 감소하는 것이다. 이렇게 생각하면 그다지 어렵지 않다. 반복문에 대한 내용은 더 뒤에 살펴보고 예제 코드를 한 번 살펴보자.

### Hello, World!
코드가 조금 길다. 이 예제 코드는 [나무위키](https://namu.wiki/w/%EB%B8%8C%EB%A0%88%EC%9D%B8%ED%8D%BD#s-4.2)에 수록된 코드를 수정한 것으로 반복문을 사용하지 않은 노가다 출력 예제다.
```brainfuck
// 한글을 포함하여 알파벳은 무시된다
// 플러스는 10개 단위로 끊었다
H
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++ . >
e
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++ + . >
l
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++ . >
l
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++ . >
o
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ + . >
Comma
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++ . >
Space
++++++++++ ++++++++++ ++++++++++ ++ . >
w
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ +++++++++ . >
o
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ + . >
r
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++ . >
l
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++ . >
d
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++
++++++++++ ++++++++++ ++++++++++ ++++++++++ ++++++++++ . >
!
++++++++++ ++++++++++ ++++++++++ +++ .
```
길지만 침착하고 코드를 분석해보자. 앞서 `+`는 현재 포인터 위치에 해당하는 값을 1 증가시킨다고 했다. 그렇다면 현재 포인터 위치를 0이라 가정했을 때 H 다음에 나오는 두 줄은 72만큼 증가한 후 `.`을 통해 출력한다는 것을 알 수 있다. H의 아스키 코드 값을 기억하는가? 아마 충분히 예상했겠지만 72에 해당한다.

이어서 다음 글자인 e에 대해서도 살펴보자. H를 출력한 후 `>`를 통해 포인터 위치를 1 증가시켰으므로 현재 포인터 위치는 1이다. e 다음 두 줄은 101만큼 증가한 후 `.`을 통해 출력한다. 마찬가지로 e의 아스키 코드 값은 101이다. 나머지 글자도 같은 원리로 출력된다.

생각보다 너무 간단하지 않은가? 갑자기 구현에 대한 자신감이 조금은 생겼을 것이라 믿는다. 이처럼 모르는 것을 학습하면 **난해한 일**이 **단순한 일**로 변한다.

### 반복문
아직 `[`와 `]`에 대해선 살펴보지 않았다. Brainfuck도 반복되는 작업을 줄이기 위해 반복문이란 문법이 있는데, 이는 다른 명령어들보단 조금 난해하다.

* `[` : 포인터 위치에 해당하는 값이 0이라면 "]"로 이동한다. 0이 아니라면 다음 명령어로 이동한다.
* `]` : 포인터 위치에 해당하는 값이 0이 아니라면 "["로 이동한다. 0이라면 다음 명령어로 이동한다.

익숙하지 않아 조금 헷갈릴 수 있겠지만 문장을 자세히 들여다보면 그다지 어렵진 않다. 말 그대로 `[`를 해석할 때 포인터 위치에 해당하는 값이 0이라면 `]` 명령어가 있는 위치까지 이동한다는 뜻이다. 그 사이에 있는 명령어는 무시된다. 만약 `]`가 없다면 컴파일 에러가 발생해야 한다. `]`의 경우도 마찬가지로 동작한다. 이 경우는 `[`를 만날 때까지 거꾸로 되돌아가는 것이라 볼 수 있다.

이번엔 Hello, world! 출력을 반복문을 사용하여 코드를 줄여볼 것이다. 마찬가지로 [나무위키](https://namu.wiki/w/%EB%B8%8C%EB%A0%88%EC%9D%B8%ED%8D%BD#s-4.1)의 예제와 설명을 이용하였다.

```brainfuck
++++++++++
[>+++++++>++++++++++>+++>+<<<<-]
>++.>+.+++++++..+++.>++++++++++++++.------------.<<+++++++++++++++.>.+++.------.--------.>+.
```
포인터의 위치는 0부터 시작하고 모든 포인터의 메모리 초기값은 0이라고 가정한다.

1. `+++++ +++++`<br />
  현재 포인터 위치(0)의 값을 10 증가시킨다. 결과적으로 포인터 위치에 해당하는 값은 10이 된다.
2. `[>+++++ ++ >+++++ +++++ >+++ >+ <<<<`<br />
  현재 포인터 위치(0)를 하나씩 증가시키며( > (1) > (2) > (3) > (4) ) 각 주소의 값을 7, 10, 3, 1씩 증가시킨다. 이후 `<<<<`를 통해 포인터의 위치를 다시 0으로 만든다.
3. `-]`<br />
  현재 포인터 위치(0)의 값을 1 감소시킨 후, 그 값이 0이 아닐 경우 **2.**의 `[` 로 돌아간다. **1.**에서 0에 해당하는 포인터 값을 10으로 만들었기 때문에 10회 반복문이 된다. 결국 **2.**가 10번 실행되므로 각 포인터의 1~4번째 위치에는 70, 100, 30, 10의 값이 들어가게 된다.
4. `>++ .` → H<br />
  포인터 위치를 1 증가시키고(1), 위치에 해당하는 값(=70)에 2를 더한 후(=72, H) 그 값을 아스키 코드로 출력한다.
5. `>+ . +++++ ++ .. +++ .` → ello<br />
  다시 포인터 위치를 1 증가시키고(2), 위치에 해당하는 값(=100)에 1을 더한 후(=101, e) 한 번 출력, 7을 더한 후(=108, l) 두 번 출력, 또다시 3을 더한 후(=111, o) 한 번 출력한다. 여기서 **Hello**가 출력된다.
6. `>++++++++++++++.------------.<<+++++++++++++++.>.+++.------.--------.>+.` → , World!<br />
  4~5와 같다. 포인터 위치를 이리저리 바꾸고 그 주소의 값에 숫자를 더하고 빼 가면서 문자를 출력한다. 여기서 **, World!**가 출력된다.

각 단계를 보면 알겠지만 단순 노가다를 줄인 것에 가깝다. 너무 단순하기 때문에 위 두 예제를 봤다면 Brainfuck이란 언어가 어떻게 동작하는지 완벽하게 파악했을 것이다.

## 튜링 완전이란?
그런데 이런 언어로 프로그램을 만들 수 있을까? 결론부터 말하면 **가능**하다. 물론 이런 난해한 프로그래밍 언어를 이용하여 제대로된 프로그램을 만든 사람은 없다. 그럼 제대로된 프로그램을 만든 사람이 없다면 이런 언어가 어떻게 상용 소프트웨어, 컴파일러, 운영체제, 게임과 같은 복잡한 프로그램을 만들어 낼 수 있다는 것을 증명할 수 있을까?

이는 **튜링 머신**이라는 것을 통해서 가능하다. 컴퓨터 과학에서 중요한 개념으로 이 개념이 있기에 지금의 컴퓨터가 있을 수 있다고 볼 수 있다.

## 프로그래밍 언어라고 볼 수 있는가?

# Brainfuck 구현해보기

## 명령어 구현

## 실행해보기

# 재즈랭 만들어보기

# 마치며
글을 끝까지 읽어보면 난해한 프로그래밍 언어라는 것은 이름치고는 생각보다 구현하기 쉽다는 것을 알 수 있다. 물론 조금 더 심화 내용이 있을 거라 기대한 사람은 이 내용이 아쉽게 느껴질 수 있다. 추후에 여유가 생긴다면 이번에 구현한 Jazzlang을 LLVM을 이용하여 최적화된 언어로 만드는 과정을 포스팅해볼 예정이니 혹시 이 글을 읽고 관심이 생긴 독자가 있다면 추후 올라올 포스팅을 기대해주시길 바란다.