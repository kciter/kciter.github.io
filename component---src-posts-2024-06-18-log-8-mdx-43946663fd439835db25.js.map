{"version":3,"file":"component---src-posts-2024-06-18-log-8-mdx-43946663fd439835db25.js","mappings":"iPAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,MACFC,EAAAA,EAAAA,KAAsBL,EAAMM,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,2OAA4O,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,2JAA4J,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,6OAA8O,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,4MAA6M,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,yNAA0N,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,wJACp2C,CAKA,UAJA,SAAoBJ,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOQ,QAASC,GAAaP,OAAOC,OAAO,CAAC,GAAGE,EAAAA,EAAAA,KAAsBL,EAAMM,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWT,EAAOO,EAAAA,cAAoBR,EAAmBC,IAAUD,EAAkBC,EAC9H,C,qECeA,MAAMU,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBN,GAC/B,MAAMO,EAAoB,aAAiBF,GAG3C,OAAO,WACL,WAEE,MAA0B,mBAAfL,EACFA,EAAWO,GAGb,IAAIA,KAAsBP,EACnC,GACA,CAACO,EAAmBP,GAExB,C","sources":["webpack://kciter.so/./src/posts/2024-06-18-log-8.mdx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"“남해의 임금을 숙이라 하고, 북해의 임금을 홀이라 하며, 중앙의 임금을 혼돈(渾沌)이라 한다. 숙과 홀이 때마침 혼돈의 땅에서 만났는데, 혼돈이 매우 융숭하게 그들을 대접했으므로, 숙과 홀은 혼돈의 은혜에 보답할 것을 논의해 말하기를, 사람은 모두 일곱 개의 구멍이 있어 보고 듣고 먹고 숨 쉬는데 오직 혼돈에게만 없으므로 구멍을 뚫어보자고 했다. 날마다 한 구멍씩 뚫었는데 7일이 지나자 혼돈은 죽고 말았다.”\"), \"\\n\", React.createElement(_components.p, null, \"장자의 내편 마지막 권인 응제왕에선 위와 같이 혼돈에 대한 짧은 이야기가 있습니다. 혼돈에게 구멍을 뚫어줬더니 죽었다라는 말은 주로 우리 생각의 틀(프레임워크)에 맞춰 혼돈을 규정하지 말라는 의미로 해석됩니다. 어쩌면, 혼돈을 그 자체로 내버려두라는 말일 수도 있습니다.\"), \"\\n\", React.createElement(_components.p, null, \"혼돈(Chaos)은 비즈니스, 조직 관리, 인간관계, 개발 아키텍처 등 다양한 영역에서 접할 수 있습니다. 장자의 생각과는 달리 우리는 다양한 이유를 위해서 혼돈을 가만히 내버려둘 수 없습니다. 이해할 수 없는 혼돈을 이해하고자 다양한 학문과 방법론이 탄생했고 이를 통해 우리는 여러 문제를 해결해 나갑니다. 오늘날 발전한 많은 방법론은 여러 겹으로 추상화되어 마치 혼돈을 쉽게 해결할 수 있는 것처럼 느끼게 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"어느정도 경력이 쌓인 사람들은 다들 자신만의 프레임워크를 하나씩 마음에 품고 있습니다. 대게 그 사람의 풍부한 경험과 시행착오로 이루어진 정교한 틀은 이전 문제에선 잘 작동했을지 모르지만, 다른 문제에선 유효하지 않을 수 있습니다. 이전 혼돈과 새로운 혼돈은 달랐던 것이죠. 그렇지만 자신의 프레임워크가 완벽하다 믿는 사람은 혼돈을 죽여버리는 실수를 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"이미 만들어진 프레임워크는 어려운 일을 단순화합니다. 그래서 쉽게 해결할 수 있는 것처럼 보이지만 잘못된 방법일 수 있습니다. 프레임워크와 방법론이 하나만 존재하는 것이 아닌 만큼, 한 가지에 집착하지 않고 여러 접근 방법과 시각을 익히고 다른 사람의 의견을 수용할 수 있어야 합니다. 그리고 새로운 혼돈을 발견했다면 다양한 시각에서 분석하고 분해하여 경험적으로 풀어나가야 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"장자의 이야기처럼 보고 듣고 먹고 숨 쉬지 못하는 것은 혼돈의 진짜 문제가 아닐지 모릅니다. 조금 더 시간이 걸리고 힘들지라도 다양한 방법을 논의하고 검증하며 혼돈을 이해하려 노력해 봅시다. 그러면 언젠가 혼돈이 품고 있던 진짜 문제를 해결할 수 있다고 생각합니다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","_provideComponents","components","React","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}