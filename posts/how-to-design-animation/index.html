<!DOCTYPE html><html lang="ko"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="color-scheme" content="light"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="manifest" href="/manifest.webmanifest"><link rel="alternate" type="application/rss+xml" title="kciter.so" href="/feed.xml"><title>애니메이션을 설계하는 방법 | kciter.so</title><meta name="description" content="들어가며 웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 애니메이션은 재미를 더할 뿐 아니라 사용자의 이해를 돕고 인터랙션의 결과를 명확히 전달하며 브랜드의 개성을 표현하는 등 중요한 역할을 한다. 그런데 이런…"><meta name="author" content="Lee Sun-Hyoup"><!-- Open Graph --><meta property="og:title" content="애니메이션을 설계하는 방법 | kciter.so"><meta property="og:description" content="들어가며 웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 애니메이션은 재미를 더할 뿐 아니라 사용자의 이해를 돕고 인터랙션의 결과를 명확히 전달하며 브랜드의 개성을 표현하는 등 중요한 역할을 한다. 그런데 이런…"><meta property="og:type" content="website"><meta property="og:site_name" content="kciter.so"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png"><meta property="og:url" content="https://kciter.so/posts/how-to-design-animation/"><link rel="canonical" href="https://kciter.so/posts/how-to-design-animation/"><!-- Twitter --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="Sunhyoup Lee"><meta name="twitter:title" content="애니메이션을 설계하는 방법 | kciter.so"><meta name="twitter:description" content="들어가며 웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 애니메이션은 재미를 더할 뿐 아니라 사용자의 이해를 돕고 인터랙션의 결과를 명확히 전달하며 브랜드의 개성을 표현하는 등 중요한 역할을 한다. 그런데 이런…"><meta name="twitter:image" content="https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png"><!-- Additional meta from props --><meta name="article:published_time" content="2026-02-18T00:00:00+09:00"><meta name="image" content="https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png"><meta property="og:image" content="https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png"><meta property="og:image:secure_url" content="https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png"><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400&family=PT+Sans:wght@400&family=Source+Code+Pro&family=Quattrocento+Sans&display=swap"><!-- Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-7M8K7EBEDX"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());
      gtag('config', 'G-7M8K7EBEDX');
    </script> <script type="application/ld+json">{"headline":"애니메이션을 설계하는 방법","dateModified":"2026-02-18T00:00:00+09:00","datePublished":"2026-02-18T00:00:00+09:00","image":"https://kciter.so/images/2026-02-18-how-to-design-animation/thumbnail.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://kciter.so/posts/how-to-design-animation/"},"author":{"@type":"Person","name":"Lee Sun-Hyoup"},"description":"들어가며 웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 애니메이션은 재미를 더할 뿐 아니라 사용자의 이해를 돕고 인터랙션의 결과를 명확히 전달하며 브랜드의 개성을 표현하는 등 중요한 역할을 한다. 그런데 이런…","url":"https://kciter.so/posts/how-to-design-animation/","@type":"BlogPosting","@context":"https://schema.org"}</script> <link rel="stylesheet" href="/_astro/_slug_.CNFATi3L.css">
<style>.name-gradient[data-astro-cid-k7qsseos]{background:linear-gradient(to right,#191335,#191335 33.33333%,#00ab6c 66.66666%,#00cb8c);background-clip:text;-webkit-text-fill-color:transparent;transition:all .3s ease;background-size:300% 100%;background-position:top left}.name-gradient[data-astro-cid-k7qsseos]:hover{background-position:top left 100%}@media(max-width:30rem){.sponsors[data-astro-cid-4kgnabjz] a:not(:first-of-type){margin-left:-16px}}.related-post[data-astro-cid-llggujpl]{position:relative;transform:scaleZ(1)}.related-post[data-astro-cid-llggujpl]:after{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:8px;transform:scale(1.06);transition:opacity 2s cubic-bezier(.165,.84,.44,1);box-shadow:0 8px 17px #0003,0 6px 20px #00000026;content:"";opacity:0;z-index:-1}.related-post[data-astro-cid-llggujpl]:hover{transform:scale3d(1.006,1.006,1)}.related-post[data-astro-cid-llggujpl]:hover:after{opacity:1}
</style></head> <body> <div class="mx-auto w-[715px] pt-4 max-md:w-[90vw]"> <div class="relative z-10 mb-10 -mx-4 rounded-xl bg-white/40 px-4 py-2.5 font-['Quattrocento_Sans',sans-serif] backdrop-blur-[44px] max-md:-mx-4 max-md:-mt-4 max-md:mb-8 max-md:rounded-none max-md:bg-transparent max-md:backdrop-blur-none" data-astro-cid-3ef6ksr2> <div class="mt-2 w-full" data-astro-cid-3ef6ksr2> <a href="/" class="site-title text-[32px] font-black" style="line-height: 1.15; text-decoration: none; margin-right: 5px;" data-astro-cid-3ef6ksr2>kciter.so</a> <small class="text-[#999]" data-astro-cid-3ef6ksr2>devlog</small> </div> <nav class="flex w-full justify-between pt-2" data-astro-cid-3ef6ksr2> <div class="flex items-center" data-astro-cid-3ef6ksr2> <a href="/timeline/" class="menu-item updated" data-astro-cid-3ef6ksr2>
Timeline
</a> <div class="dropdown" data-astro-cid-3ef6ksr2> <span class="menu-item dropdown-trigger" id="posts-trigger" data-astro-cid-3ef6ksr2>
Posts <span class="chevron" data-astro-cid-3ef6ksr2>&#9662;</span> </span> <div class="dropdown-menu" data-astro-cid-3ef6ksr2> <a href="/articles/" class="dropdown-item" data-astro-cid-3ef6ksr2>Articles</a> <a href="/bookshelf/" class="dropdown-item" data-astro-cid-3ef6ksr2>Bookshelf</a> <a href="/thought/" class="dropdown-item" data-astro-cid-3ef6ksr2>Thoughts</a> </div> </div> <a href="https://kciter.so/talks/" class="menu-item" data-astro-cid-3ef6ksr2>Talks</a> <a href="/about/" class="menu-item" data-astro-cid-3ef6ksr2>About</a> </div> <div class="flex items-center gap-3" data-astro-cid-3ef6ksr2> <button id="search-btn" class="search-btn" aria-label="Search" data-astro-cid-3ef6ksr2> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-3ef6ksr2> <circle cx="11" cy="11" r="8" data-astro-cid-3ef6ksr2></circle> <line x1="21" y1="21" x2="16.65" y2="16.65" data-astro-cid-3ef6ksr2></line> </svg> </button> <div class="max-md:hidden" data-astro-cid-3ef6ksr2> <a href="https://github.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="GitHub" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.44 9.8 8.2 11.38.6.12.83-.26.83-.57v-2.2c-3.34.73-4.04-1.44-4.04-1.44-.55-1.38-1.33-1.75-1.33-1.75-1.09-.74.08-.73.08-.73 1.2.09 1.84 1.24 1.84 1.24 1.07 1.83 2.8 1.3 3.49 1 .1-.78.42-1.3.76-1.6-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.13-.3-.54-1.52.12-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6.02 0c2.28-1.55 3.28-1.23 3.28-1.23.66 1.66.25 2.88.12 3.18.77.84 1.24 1.91 1.24 3.22 0 4.61-2.81 5.63-5.48 5.92.43.37.81 1.1.81 2.22v3.29c0 .31.22.7.83.57C20.57 21.8 24 17.3 24 12c0-6.63-5.37-12-12-12z"/></svg></a><a href="https://www.facebook.com/sunhyoup.lee" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="Facebook" style="--hover-color: #3d5b99; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M24 12.07C24 5.41 18.63 0 12 0S0 5.41 0 12.07c0 6.02 4.39 11.02 10.13 11.93v-8.44H7.08v-3.49h3.04V9.41c0-3.02 1.79-4.68 4.53-4.68 1.31 0 2.68.24 2.68.24v2.97h-1.51c-1.49 0-1.95.93-1.95 1.88v2.26h3.33l-.53 3.49h-2.8v8.44C19.61 23.09 24 18.09 24 12.07z"/></svg></a><a href="https://www.linkedin.com/in/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="LinkedIn" style="--hover-color: #0073a4; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M20.45 20.45h-3.55v-5.57c0-1.33-.02-3.04-1.85-3.04-1.85 0-2.14 1.45-2.14 2.94v5.67H9.36V9h3.41v1.56h.05c.48-.9 1.64-1.85 3.37-1.85 3.6 0 4.27 2.37 4.27 5.46v6.28zM5.34 7.43a2.06 2.06 0 1 1 0-4.12 2.06 2.06 0 0 1 0 4.12zM7.12 20.45H3.56V9h3.56v11.45zM22.22 0H1.77C.79 0 0 .77 0 1.72v20.56C0 23.23.79 24 1.77 24h20.45C23.2 24 24 23.23 24 22.28V1.72C24 .77 23.2 0 22.22 0z"/></svg></a><a href="https://twitter.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="X (Twitter)" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a><a href="/feed.xml" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="RSS Feed" style="--hover-color: #ff6600; transition: color .5s;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M6.18 15.64a2.18 2.18 0 1 1 0 4.36 2.18 2.18 0 0 1 0-4.36zM4 4.44v3.57A12.01 12.01 0 0 1 15.99 20h3.57A15.57 15.57 0 0 0 4 4.44zM4 10.1v3.57c3.5 0 6.33 2.84 6.33 6.33h3.57c0-5.47-4.43-9.9-9.9-9.9z"/></svg></a> </div> </div> </nav> <!-- Mobile sub-tab (hidden by default) --> <div class="mobile-tabs" id="mobile-tabs" data-astro-cid-3ef6ksr2> <a href="/articles/" class="mobile-tab" data-astro-cid-3ef6ksr2>Articles</a> <a href="/bookshelf/" class="mobile-tab" data-astro-cid-3ef6ksr2>Bookshelf</a> <a href="/thought/" class="mobile-tab" data-astro-cid-3ef6ksr2>Thoughts</a> </div> </div> <!-- Search Modal --> <div id="search-modal" class="search-modal" data-astro-cid-3ef6ksr2> <div class="search-backdrop" data-astro-cid-3ef6ksr2></div> <div class="search-container" data-astro-cid-3ef6ksr2> <div class="search-input-wrap" data-astro-cid-3ef6ksr2> <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-astro-cid-3ef6ksr2> <circle cx="11" cy="11" r="8" data-astro-cid-3ef6ksr2></circle> <line x1="21" y1="21" x2="16.65" y2="16.65" data-astro-cid-3ef6ksr2></line> </svg> <input id="search-input" type="text" placeholder="Search posts..." autocomplete="off" data-astro-cid-3ef6ksr2> <kbd class="search-kbd" data-astro-cid-3ef6ksr2>ESC</kbd> </div> <div id="search-results" class="search-results" data-astro-cid-3ef6ksr2></div> </div> </div>  <script type="module">const o=document.getElementById("posts-trigger"),l=document.getElementById("mobile-tabs");if(o&&l){const e=o.querySelector(".chevron");o.addEventListener("click",t=>{window.innerWidth<=768&&(t.preventDefault(),l.classList.toggle("open"),e?.classList.toggle("open"))});const i=window.location.pathname;l.querySelectorAll(".mobile-tab").forEach(t=>{i.startsWith(t.getAttribute("href")||"")&&t.classList.add("active")})}let s=null;async function m(){if(s)return s;try{s=await import(new URL("/pagefind/pagefind.js",window.location.origin).href),await s.init()}catch{console.warn("Pagefind not available (run build first)")}return s}const c=document.getElementById("search-modal"),r=document.getElementById("search-input"),a=document.getElementById("search-results"),p=document.getElementById("search-btn"),v=c.querySelector(".search-backdrop");function f(){c.classList.add("open"),r.value="",a.innerHTML="",setTimeout(()=>r.focus(),50),m()}function d(){c.classList.remove("open")}p.addEventListener("click",f);v.addEventListener("click",d);document.addEventListener("keydown",e=>{(e.metaKey||e.ctrlKey)&&e.key==="k"&&(e.preventDefault(),c.classList.contains("open")?d():f()),e.key==="Escape"&&d()});let u;r.addEventListener("input",()=>{clearTimeout(u),u=setTimeout(()=>g(r.value),200)});async function g(e){if(!e.trim()){a.innerHTML="";return}const i=await m();if(!i){a.innerHTML='<div class="search-no-results">Search is not available in dev mode.</div>';return}const t=await i.search(e);if(t.results.length===0){a.innerHTML='<div class="search-no-results">No results found.</div>';return}const h=await Promise.all(t.results.slice(0,10).map(n=>n.data()));a.innerHTML=h.map(n=>`
        <a href="${n.url}" class="search-result-item">
          <div class="search-result-title">${n.meta?.title||n.url}</div>
          <div class="search-result-excerpt">${n.excerpt}</div>
        </a>
      `).join("")}</script> <div class="post-container">   <h1 class="post-title">애니메이션을 설계하는 방법</h1> <span class="post-date">Written on February 18, 2026</span> <img src="/images/2026-02-18-how-to-design-animation/thumbnail.png" alt="애니메이션을 설계하는 방법" style="width: 100%;"><div class="toc" data-margin-top="50"><ul class="toc-list"><li><a href="#들어가며">들어가며</a></li><li><a href="#애니메이션은-그래프다">애니메이션은 그래프다</a></li><li><a href="#애니메이션을-위한-도구-수학">애니메이션을 위한 도구, 수학</a><ul class="toc-list"><li><a href="#이징과-베지어-커브">이징과 베지어 커브</a></li><li><a href="#지수적-접근">지수적 접근</a></li><li><a href="#스프링-애니메이션">스프링 애니메이션</a></li><li><a href="#물리-시뮬레이션">물리 시뮬레이션</a></li><li><a href="#자연스러운-방향-전환">자연스러운 방향 전환</a></li><li><a href="#삼각함수로-만드는-주기적-움직임">삼각함수로 만드는 주기적 움직임</a></li><li><a href="#톱니파">톱니파</a></li></ul></li><li><a href="#애니메이션-설계하기">애니메이션 설계하기</a><ul class="toc-list"><li><a href="#그래프를-나눠라">그래프를 나눠라</a></li><li><a href="#무엇에-의존하는가">무엇에 의존하는가</a></li><li><a href="#파이프라이닝">파이프라이닝</a></li><li><a href="#상태-전환으로-설계하기">상태 전환으로 설계하기</a></li><li><a href="#속성-분리">속성 분리</a></li><li><a href="#랜덤성">랜덤성</a></li><li><a href="#양방향성-고려">양방향성 고려</a></li></ul></li><li><a href="#정말-복잡한-애니메이션은">정말 복잡한 애니메이션은?</a></li><li><a href="#마치며">마치며</a></li></ul></div><div class="post-content" data-pagefind-body>  <h1 id="들어가며"><a href="#들어가며">들어가며</a></h1>
<p>웹이나 앱을 사용하다 보면 자연스럽게 눈길을 끄는 애니메이션을 마주할 때가 있다. 애니메이션은 재미를 더할 뿐 아니라 사용자의 이해를 돕고 인터랙션의 결과를 명확히 전달하며 브랜드의 개성을 표현하는 등 중요한 역할을 한다.</p>
<p>그런데 이런 애니메이션을 직접 만들어야 하는 순간이 오면 이야기가 달라진다. 디자이너가 건네준 프로토타입 영상을 보며 “이걸 어떻게 구현하지?”라고 막막해한 경험이 한 번쯤은 있을 것이다. 혹은 머릿속에 그려지는 움직임은 있지만 코드로 옮기려니 어디서부터 손을 대야 할지 모를 때도 있다.</p>
<p>핵심은 애니메이션도 <strong>설계</strong>할 수 있다는 것이다. 복잡해 보이는 움직임도 잘게 쪼개면 단순한 상태 변화의 조합이고, 각각의 상태 변화는 수학적으로 표현할 수 있다. 이 글에서는 애니메이션을 체계적으로 분해하고 설계하는 방법을 다룰 것이다.</p>
<h1 id="애니메이션은-그래프다"><a href="#애니메이션은-그래프다">애니메이션은 그래프다</a></h1>
<p>무언가를 “설계”하려면 두 가지 필요한 조건이 있다. <strong>재현할 수 있어야</strong> 하고, <strong>조합할 수 있어야</strong> 한다. 머릿속의 감각에 의존하면 같은 움직임을 다시 만들기 어렵고, 여러 움직임을 체계적으로 엮기도 어렵다. 따라서 움직임을 공학적으로 나타내는 방법이 필요하며, 이를 위해 <strong>그래프</strong>를 이용할 수 있다. 모든 애니메이션은 그래프로 표현할 수 있다. 이 관점을 갖게 되면 복잡한 움직임도 체계적으로 분석하고 만들어낼 수 있게 된다.</p>
<p>요소의 투명도가 0에서 1로 변하는 페이드인 애니메이션을 생각해보자. 이것을 그래프로 그리면 가로축은 시간, 세로축은 투명도가 된다. 예를 들면, 0초에서 시작해 2초에 끝나는 동안 투명도 값이 0에서 1로 올라가는 그래프를 그려 볼 수 있다.</p>
<style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var a=(s,i,o)=>{let r=async()=>{await(await s())()},t=typeof i.value=="object"?i.value:void 0,c={rootMargin:t==null?void 0:t.rootMargin},n=new IntersectionObserver(e=>{for(let l of e)if(l.isIntersecting){n.disconnect(),r();break}},c);for(let e of o.children)n.observe(e)};(self.Astro||(self.Astro={})).visible=a;window.dispatchEvent(new Event("astro:visible"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z1jYK35" prefix="r26" component-url="/_astro/index.BLQV0jyi.js" component-export="FadeInGraphDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;FadeInGraphDemo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;align-items:center;gap:48px;padding:24px 0;flex-wrap:wrap"><div style="width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg, #228be6, #339af0);box-shadow:0 2px 8px rgba(34,139,230,0.3);opacity:0"></div><canvas style="width:100%;max-width:240px;aspect-ratio:240 / 160;display:block"></canvas></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:4px">페이드인 — 시간에 따라 투명도가 0에서 1로 변한다</div></div><!--astro:end--></astro-island>
<p>이동 애니메이션도 마찬가지다. 왼쪽에서 오른쪽으로 움직이는 요소는 시간-위치 그래프로 나타낼 수 있고, 크기가 커지는 애니메이션은 시간-스케일 그래프가 된다. 가로축이 꼭 시간일 필요도 없다. 스크롤 위치에 따라 요소가 나타나는 패럴랙스 효과는 스크롤 오프셋이 가로축이 된다. 어떤 애니메이션이든 결국 <strong>어떤 입력에 따라 값이 변하는 것</strong>이고, 이 변화를 그래프로 그릴 수 있다.</p>
<p>여기서 중요한 것은 그래프의 <strong>모양</strong>이 곧 움직임의 <strong>느낌</strong>을 결정한다는 점이다. 같은 시작점과 끝점이라도 곡선의 형태에 따라 전혀 다른 인상을 줄 수 있다. 이 곡선을 원하는 대로 만들어내는 것이 애니메이션 설계의 핵심이며, 그 도구가 되는 것이 수학이다.</p>
<h1 id="애니메이션을-위한-도구-수학"><a href="#애니메이션을-위한-도구-수학">애니메이션을 위한 도구, 수학</a></h1>
<p>그렇다면 원하는 모양의 그래프를 어떻게 만들 수 있을까? 여기서 수학이 등장한다. 이 섹션에서는 애니메이션에서 자주 쓰이는 수학적 도구들을 살펴보고 그것들이 어떻게 그래프의 형태를 조절하는지 알아볼 것이다. 수학이 낯설게 느껴질 수도 있지만 걱정할 필요 없다. 핵심은 수학적 개념을 이해하는 것이 아니라 애니메이션의 느낌에 어떤 영향을 주는지 파악하는 것이다.</p>
<h2 id="이징과-베지어-커브"><a href="#이징과-베지어-커브">이징과 베지어 커브</a></h2>
<p>가장 단순한 애니메이션은 선형이다. 선형은 시작점에서 끝점까지 일정한 속도로 변한다. 하지만 현실 세계의 움직임은 선형이 아니다. 공을 던지면 처음에 빠르다가 점점 느려지고, 자동차는 출발할 때 천천히 시작해서 속도를 높인다. 이런 자연스러운 가감속을 표현하는 것이 <strong>이징</strong><sup>easing</sup> 함수다.</p>
<p>이징 함수는 0에서 1 사이의 진행률을 입력받아 변환된 진행률을 출력한다. <code>ease-in</code>은 느리게 시작해서 빠르게 끝나고, <code>ease-out</code>은 빠르게 시작해서 느리게 끝난다. 이것을 수학적으로 표현하는 가장 널리 쓰이는 방법이 <strong>큐빅 베지어 커브</strong><sup>cubic bezier curve</sup>다.</p>
<p>큐빅 베지어 커브는 네 개의 제어점으로 곡선을 정의한다. 이징에서는 시작점 (0, 0)과 끝점 (1, 1)이 고정이므로 실질적으로 두 개의 제어점 (x1, y1)과 (x2, y2)만 조절하면 된다. 제어점은 곡선이 지나가는 점이 아니라, 곡선을 <strong>끌어당기는</strong> 점이다. 마치 자석처럼 곡선의 경로에 영향을 준다.</p>
<p>그렇다면 제어점으로부터 곡선이 어떻게 만들어질까? 핵심은 <strong>선형 보간</strong><sup>linear interpolation</sup><strong>의 재귀적 적용</strong>이다. 두 점 사이의 선형 보간은 단순하다. 진행률 <code>t</code>가 0이면 시작점, 1이면 끝점, 0.5면 정확히 중간점이다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">function</span><span style="color:#6F42C1"> lerp</span><span style="color:#24292E">(</span><span style="color:#E36209">a</span><span style="color:#24292E">, </span><span style="color:#E36209">b</span><span style="color:#24292E">, </span><span style="color:#E36209">t</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#24292E"> a </span><span style="color:#D73A49">+</span><span style="color:#24292E"> (b </span><span style="color:#D73A49">-</span><span style="color:#24292E"> a) </span><span style="color:#D73A49">*</span><span style="color:#24292E"> t;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre>
<p>베지어 커브는 이 보간을 여러 단계에 걸쳐 반복한다. 네 개의 제어점 P0, P1, P2, P3이 있다고 하자.</p>
<ol>
<li>P0-P1, P1-P2, P2-P3 사이를 각각 <code>t</code>만큼 보간하여 세 개의 중간점을 얻는다</li>
<li>그 세 중간점 사이를 다시 <code>t</code>만큼 보간하여 두 개의 점을 얻는다</li>
<li>마지막 두 점 사이를 <code>t</code>만큼 보간하면 최종 곡선 위의 한 점이 나온다</li>
</ol>
<p>이 방식은 꽤나 강력한데 두 개의 제어점만으로 매우 다양한 움직임을 만들어낼 수 있기 때문이다. 그 중에서 대표적으로 많이 사용되는 제어점 조합을 예제로 살펴보면 다음과 같다.</p>
<astro-island uid="28TRll" prefix="r27" component-url="/_astro/index.BLQV0jyi.js" component-export="EasingVisualizer" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;EasingVisualizer&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;gap:8px;margin-bottom:16px;flex-wrap:wrap"><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400">Linear</button><button style="padding:6px 14px;border:2px solid #228be6;border-radius:6px;background:#e7f5ff;color:#1971c2;cursor:pointer;font-size:13px;font-weight:600">Ease</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400">Ease In</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400">Ease Out</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400">Overshoot</button></div><div style="display:flex;gap:20px;align-items:stretch;flex-wrap:wrap"><canvas style="width:100%;max-width:320px;height:240px;flex-shrink:0"></canvas><div style="flex:1;min-width:200px;display:flex;flex-direction:column;justify-content:space-between"><div><div style="font-size:12px;color:#868e96;margin-bottom:4px">cubic-bezier(<!-- -->0.25<!-- -->, <!-- -->0.1<!-- -->, <!-- -->0.25<!-- -->, <!-- -->1<!-- -->)</div><div style="position:relative;height:40px;background:#f1f3f5;border-radius:8px;margin-top:12px;overflow:hidden"><div style="position:absolute;left:0%;top:50%;transform:translate(-50%, -50%);width:28px;height:28px;border-radius:50%;background:#228be6;transition:none"></div></div><div style="font-size:11px;color:#adb5bd;margin-top:4px;text-align:center">← 이 공의 위치가 커브를 따라 변합니다 →</div></div><button style="margin-top:16px;padding:10px 24px;background:#228be6;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">▶ 재생</button></div></div></div><!--astro:end--></astro-island>
<p>이징을 실전에서 어떻게 선택할까? 토스트 알림이 화면 아래에서 올라오는 애니메이션을 예로 들어보자.</p>
<p><code>ease-out</code>을 적용하면 토스트가 빠르게 나타나 사용자의 주의를 끌고, 최종 위치에서 부드럽게 감속하며 안착한다. 반면 <code>ease-in</code>을 적용하면 천천히 시작해서 점점 빨라지는데, 등장이 느긋해서 덜 눈에 띈다. <code>linear</code>는 일정한 속도로 올라오다 갑자기 멈추기 때문에 기계적인 느낌을 준다.</p>
<p>같은 요소, 같은 움직임이지만 이징에 따라 전달하는 인상이 완전히 달라진다. 어떤 이징이 “정답”인 것은 아니다. 중요한 것은 <strong>그 움직임이 어떤 목적을 가지는가</strong>다. 사용자의 시선을 빠르게 끌어야 한다면 초반이 빠른 커브를, 조용히 사라져야 한다면 후반이 빠른 커브를 선택할 수 있다. 아래 데모에서 같은 토스트에 서로 다른 이징을 적용했을 때 인상이 어떻게 달라지는지 비교해보자.</p>
<astro-island uid="Z1zIhJh" prefix="r28" component-url="/_astro/index.BLQV0jyi.js" component-export="EasingPracticeDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;EasingPracticeDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:grid;grid-template-columns:repeat(auto-fill, minmax(130px, 1fr));gap:12px;margin-bottom:16px"><div><div style="font-size:12px;font-weight:600;color:#868e96;text-align:center;margin-bottom:6px">Linear</div><div style="position:relative;height:140px;background:#f8f9fa;border-radius:8px;border:1px solid #e9ecef;overflow:hidden"><div style="position:absolute;bottom:10px;left:10px;right:10px;background:#343a40;color:#fff;border-radius:6px;padding:8px 10px;font-size:11px;font-weight:500;text-align:center;transform:translateY(60px);opacity:0;box-shadow:0 4px 12px rgba(0,0,0,0.15)">저장되었습니다</div></div></div><div><div style="font-size:12px;font-weight:600;color:#f76707;text-align:center;margin-bottom:6px">Ease In</div><div style="position:relative;height:140px;background:#f8f9fa;border-radius:8px;border:1px solid #e9ecef;overflow:hidden"><div style="position:absolute;bottom:10px;left:10px;right:10px;background:#343a40;color:#fff;border-radius:6px;padding:8px 10px;font-size:11px;font-weight:500;text-align:center;transform:translateY(60px);opacity:0;box-shadow:0 4px 12px rgba(0,0,0,0.15)">저장되었습니다</div></div></div><div><div style="font-size:12px;font-weight:600;color:#228be6;text-align:center;margin-bottom:6px">Ease Out</div><div style="position:relative;height:140px;background:#f8f9fa;border-radius:8px;border:1px solid #e9ecef;overflow:hidden"><div style="position:absolute;bottom:10px;left:10px;right:10px;background:#343a40;color:#fff;border-radius:6px;padding:8px 10px;font-size:11px;font-weight:500;text-align:center;transform:translateY(60px);opacity:0;box-shadow:0 4px 12px rgba(0,0,0,0.15)">저장되었습니다</div></div></div><div><div style="font-size:12px;font-weight:600;color:#40c057;text-align:center;margin-bottom:6px">Ease In-Out</div><div style="position:relative;height:140px;background:#f8f9fa;border-radius:8px;border:1px solid #e9ecef;overflow:hidden"><div style="position:absolute;bottom:10px;left:10px;right:10px;background:#343a40;color:#fff;border-radius:6px;padding:8px 10px;font-size:11px;font-weight:500;text-align:center;transform:translateY(60px);opacity:0;box-shadow:0 4px 12px rgba(0,0,0,0.15)">저장되었습니다</div></div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center">같은 토스트가 이징에 따라 어떻게 다른지 비교해보세요</div></div><!--astro:end--></astro-island>
<p>베지어 커브의 원리를 이해하면 도구에 의존하지 않고도 원하는 움직임을 직접 설계할 수 있다. “처음에 빠르게 튀어나왔다가 천천히 안착하는 느낌”이 필요하면 첫 번째 제어점의 y값을 크게, 두 번째 제어점을 (1, 1) 근처에 두면 된다. 그래프의 모양을 먼저 그린 뒤, 그에 맞는 제어점을 찾아가는 것이다.</p>
<h2 id="지수적-접근"><a href="#지수적-접근">지수적 접근</a></h2>
<p>이징은 시작과 끝이 정해진 곡선이다. 하지만 목표값이 도중에 바뀔 수 있는 상황에서는 어떨까? 커서를 따라다니는 요소처럼 목표가 매 프레임 달라진다면, 미리 정해진 곡선으로는 대응하기 어렵다. 이때 유용한 패턴이 <strong>지수적 접근</strong><sup>exponential approach</sup>이다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#24292E">value </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> (target </span><span style="color:#D73A49">-</span><span style="color:#24292E"> value) </span><span style="color:#D73A49">*</span><span style="color:#24292E"> factor; </span><span style="color:#6A737D">// factor: 0~1</span></span></code></pre>
<p>수식은 놀라울 정도로 단순하다. 위 수식을 매 프레임마다 적용하면 현재 값과 목표 값의 <strong>차이에 비례하는 만큼</strong>만 이동한다. 그 결과 빠르게 접근하다가 점점 느려지는 자연스러운 감속 곡선이 만들어진다.</p>
<astro-island uid="ZF2hJg" prefix="r29" component-url="/_astro/index.BLQV0jyi.js" component-export="ExpApproachGraphDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;ExpApproachGraphDemo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;padding:24px 0"><canvas style="width:100%;max-width:280px;aspect-ratio:280 / 160;display:block"></canvas></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:4px">지수적 접근 — factor가 클수록 빠르게 목표에 수렴한다</div></div><!--astro:end--></astro-island>
<p><code>factor</code>가 작으면 천천히 다가가고 크면 빠르게 다가간다. 수학적으로 이것은 <strong>지수 감쇠</strong><sup>exponential decay</sup>다. 차이가 매 프레임 <code>(1 - factor)</code> 비율로 줄어들기 때문에 남은 거리가 지수적으로 감소한다.</p>
<astro-island uid="ehvxP" prefix="r30" component-url="/_astro/index.BLQV0jyi.js" component-export="ExponentialApproachDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;ExponentialApproachDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="margin-bottom:12px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Factor: <strong>0.08</strong><span style="font-size:11px;color:#adb5bd;margin-left:8px">(중간)</span></label><input type="range" min="0.01" max="0.3" step="0.01" style="width:100%;max-width:300px" value="0.08"/></div><div style="position:relative;height:220px;background:#f8f9fa;border-radius:8px;cursor:crosshair;overflow:hidden;touch-action:none"><div style="position:absolute;left:0;top:0;width:20px;height:20px;border-radius:50%;border:2px solid #ff6b6b;pointer-events:none"></div><div style="position:absolute;left:0;top:0;width:28px;height:28px;border-radius:50%;background:#228be6;pointer-events:none"></div><div style="position:absolute;bottom:8px;width:100%;font-size:11px;color:#adb5bd;text-align:center;pointer-events:none">마우스를 움직여보세요</div></div></div><!--astro:end--></astro-island>
<p>위치뿐 아니라 모든 종류의 값에 동일하게 적용할 수 있다. 대시보드의 카운터가 목표 수치를 향해 빠르게 올라가다 점점 느려지며 안착하는 효과도 같은 원리다.</p>
<astro-island uid="ZovTDl" prefix="r31" component-url="/_astro/index.BLQV0jyi.js" component-export="CounterDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;CounterDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="background:#f8f9fa;border-radius:8px;padding:20px"><div style="text-align:center;margin-bottom:16px"><div style="font-size:11px;color:#868e96;margin-bottom:4px">총 방문자 수</div><span style="font-size:32px;font-weight:700;color:#212529;font-variant-numeric:tabular-nums">0</span></div><div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap"><button style="padding:6px 14px;border:2px solid #228be6;border-radius:6px;background:#e7f5ff;color:#1971c2;cursor:pointer;font-size:13px;font-weight:600;font-variant-numeric:tabular-nums">1,247</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400;font-variant-numeric:tabular-nums">8,392</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400;font-variant-numeric:tabular-nums">3,156</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400;font-variant-numeric:tabular-nums">5,720</button><button style="padding:6px 14px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px;font-weight:400;font-variant-numeric:tabular-nums">9,481</button></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">목표값을 바꿔보세요 — 숫자가 부드럽게 새 목표를 쫓아간다</div></div><!--astro:end--></astro-island>
<p>프로그레스 바도 마찬가지다. 실제 진행률은 네트워크 상황에 따라 뚝뚝 끊기지만 표시되는 바가 지수적 접근으로 목표를 쫓아가면 사용자에게는 부드러운 진행으로 보인다.</p>
<astro-island uid="VqK8U" prefix="r32" component-url="/_astro/index.BLQV0jyi.js" component-export="ProgressBarDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;ProgressBarDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="background:#f8f9fa;border-radius:8px;padding:20px"><div style="display:flex;justify-content:space-between;margin-bottom:8px"><span style="font-size:13px;color:#495057;font-weight:500">파일 업로드</span><span style="font-size:13px;color:#228be6;font-weight:600;font-variant-numeric:tabular-nums">0%</span></div><div style="height:10px;background:#e9ecef;border-radius:5px;overflow:hidden"><div style="height:100%;width:0;background:linear-gradient(90deg, #228be6, #339af0);border-radius:5px;will-change:width"></div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">실제 진행률이 뚝뚝 끊겨도 바는 부드럽게 목표를 쫓아간다</div></div><!--astro:end--></astro-island>
<p>지수적 접근의 장점은 <strong>목표가 바뀌어도 자연스럽다</strong>는 것이다. 커서가 갑자기 반대편으로 이동해도 현재 위치에서부터 새 목표를 향해 부드럽게 방향을 전환한다.</p>
<h2 id="스프링-애니메이션"><a href="#스프링-애니메이션">스프링 애니메이션</a></h2>
<p>이징과 지수적 접근은 목표에 단조롭게 수렴한다. 하지만 현실의 물체에는 관성이 있다. 목표를 살짝 지나쳤다가 되돌아오는 탄성이 움직임에 생동감을 더한다. 버튼을 눌렀을 때의 탄력적인 피드백, 드래그한 요소가 원래 자리로 튕겨 돌아오는 느낌을 주고 싶다면 <strong>스프링 애니메이션</strong>을 사용할 수 있다.</p>
<p>스프링 애니메이션은 물리의 <strong>감쇠 진동</strong><sup>damped harmonic oscillation</sup>을 기반으로 한다. 용수철에 매달린 물체를 생각하면 된다. 물체를 잡아당겼다 놓으면 원래 위치를 중심으로 진동하고 마찰에 의해 점점 진폭이 줄어들면서 결국 멈춘다.</p>
<p>기반이 되는 원리는 두 가지 힘이다.</p>
<ul>
<li><strong>복원력</strong>: 현재 위치가 목표에서 멀수록 강하게 잡아당긴다. <code>F = -k × (현재 - 목표)</code>. 여기서 <code>k</code>는 <strong>강성</strong><sup>stiffness</sup>이다.</li>
<li><strong>감쇠력</strong>: 속도에 비례하여 움직임을 억제한다. <code>F = -c × 속도</code>. 여기서 <code>c</code>는 <strong>감쇠 계수</strong><sup>damping</sup>이다.</li>
</ul>
<p>매 프레임마다 이 두 힘을 합산하여 가속도를 구하고, 가속도로 속도를 갱신하고, 속도로 위치를 갱신한다. 코드로 표현하면 다음과 같다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> force</span><span style="color:#D73A49"> =</span><span style="color:#D73A49"> -</span><span style="color:#24292E">stiffness </span><span style="color:#D73A49">*</span><span style="color:#24292E"> (current </span><span style="color:#D73A49">-</span><span style="color:#24292E"> target) </span><span style="color:#D73A49">-</span><span style="color:#24292E"> damping </span><span style="color:#D73A49">*</span><span style="color:#24292E"> velocity;</span></span>
<span class="line"><span style="color:#24292E">velocity </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> force </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span>
<span class="line"><span style="color:#24292E">current </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> velocity </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span></code></pre>
<astro-island uid="Z1Ik8rk" prefix="r33" component-url="/_astro/index.BLQV0jyi.js" component-export="SpringPlayground" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;SpringPlayground&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;gap:24px;flex-wrap:wrap;margin-bottom:16px"><div style="flex:1;min-width:180px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Stiffness (강성): <strong>120</strong></label><input type="range" min="10" max="400" style="width:100%" value="120"/></div><div style="flex:1;min-width:180px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Damping (감쇠): <strong>10</strong></label><input type="range" min="1" max="60" style="width:100%" value="10"/></div></div><div style="font-size:12px;color:#1971c2;margin-bottom:12px;padding:6px 12px;background:#e7f5ff;border-radius:4px;display:inline-block">Underdamped (진동)<!-- --> — damping ratio: <!-- -->0.46</div><canvas style="width:100%;height:200px;display:block;margin-bottom:12px"></canvas><div style="position:relative;height:40px;background:#f1f3f5;border-radius:8px;margin-bottom:4px;overflow:hidden"><div style="position:absolute;left:6px;top:50%;margin-top:-14px;width:28px;height:28px;border-radius:50%;background:#228be6"></div><div style="position:absolute;right:34px;top:50%;transform:translateY(-50%);width:2px;height:20px;background:#adb5bd;border-radius:1px"></div></div><div style="font-size:11px;color:#adb5bd;text-align:right;margin-bottom:12px">↑ target</div><button style="padding:10px 24px;background:#228be6;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">▶ 재생</button></div><!--astro:end--></astro-island>
<p>스프링의 느낌은 <code>stiffness</code>와 <code>damping</code> 두 값으로 결정된다. 강성이 높으면 팽팽하고 빠르게 반응하며 감쇠가 낮으면 더 오래 진동한다. 이 두 파라미터를 조절하는 것만으로 “톡 튕기는 버튼”부터 “부드럽게 안착하는 카드”까지 다양한 느낌을 만들어낼 수 있다.</p>
<p>좋아요 버튼을 예로 들어보자. 하트를 누르는 순간 스케일이 순간적으로 작아졌다가 목표(원래 크기)를 향해 튕겨 올라온다. 이때 스프링의 오버슛 덕분에 목표를 살짝 넘었다 돌아오며 “눌렀다”는 촉각적 피드백을 만든다.</p>
<astro-island uid="2cM8FX" prefix="r35" component-url="/_astro/index.BLQV0jyi.js" component-export="SpringLikeDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;SpringLikeDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;justify-content:center;align-items:center;height:100px;background:#f8f9fa;border-radius:8px"><button style="background:none;border:none;cursor:pointer;padding:12px;outline:none"><div style="will-change:transform"><svg width="48" height="48" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5
                   2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09
                   C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5
                   c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" fill="none" stroke="#adb5bd" stroke-width="1.5"></path></svg></div></button></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">하트를 눌러보세요 — 스프링이 만드는 탄성 있는 피드백</div></div><!--astro:end--></astro-island>
<p>스프링 애니메이션이 이징 기반 애니메이션과 근본적으로 다른 점은 <strong>duration이 없다</strong>는 것이다. 이징은 “0.3초 동안” 같은 고정 시간이 있지만, 스프링은 물리 시뮬레이션이 수렴할 때까지 계속된다. 그리고 또 다른 점은 목표값이 중간에 바뀌면 현재 속도를 유지한 채 새 목표를 향해 자연스럽게 전환된다는 점이다.</p>
<h2 id="물리-시뮬레이션"><a href="#물리-시뮬레이션">물리 시뮬레이션</a></h2>
<p>스프링은 하나의 값이 목표를 향해 진동하는 시스템이었다. 하지만 물리를 더 넓게 적용할 수 있다. 중력, 충돌, 마찰, 관성과 같은 물리 법칙들을 조합하면 직접 설계하기 어려운 복잡한 움직임을 자연스럽게 만들어낼 수 있다.</p>
<p>물리 시뮬레이션의 기본 구조는 단순하다. 매 프레임마다 세 단계를 반복한다.</p>
<ol>
<li><strong>힘 계산</strong>: 각 오브젝트에 작용하는 힘들을 합산한다 (중력, 스프링, 마찰, 사용자 입력 등)</li>
<li><strong>적분</strong>: 힘으로부터 가속도를, 가속도로부터 속도를, 속도로부터 위치를 갱신한다</li>
<li><strong>제약 처리</strong>: 충돌 감지, 경계 제한, 연결 관계 등의 제약 조건을 적용한다</li>
</ol>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">for</span><span style="color:#24292E"> (</span><span style="color:#D73A49">const</span><span style="color:#005CC5"> obj</span><span style="color:#D73A49"> of</span><span style="color:#24292E"> objects) {</span></span>
<span class="line"><span style="color:#6A737D">  // 힘 계산</span></span>
<span class="line"><span style="color:#D73A49">  const</span><span style="color:#005CC5"> gravity</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> { x: </span><span style="color:#005CC5">0</span><span style="color:#24292E">, y: </span><span style="color:#005CC5">9.8</span><span style="color:#D73A49"> *</span><span style="color:#24292E"> obj.mass };</span></span>
<span class="line"><span style="color:#D73A49">  const</span><span style="color:#005CC5"> friction</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> { x: </span><span style="color:#D73A49">-</span><span style="color:#24292E">obj.vx </span><span style="color:#D73A49">*</span><span style="color:#24292E"> drag, y: </span><span style="color:#D73A49">-</span><span style="color:#24292E">obj.vy </span><span style="color:#D73A49">*</span><span style="color:#24292E"> drag };</span></span>
<span class="line"><span style="color:#D73A49">  const</span><span style="color:#005CC5"> fx</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> gravity.x </span><span style="color:#D73A49">+</span><span style="color:#24292E"> friction.x;</span></span>
<span class="line"><span style="color:#D73A49">  const</span><span style="color:#005CC5"> fy</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> gravity.y </span><span style="color:#D73A49">+</span><span style="color:#24292E"> friction.y;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 적분</span></span>
<span class="line"><span style="color:#24292E">  obj.vx </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> (fx </span><span style="color:#D73A49">/</span><span style="color:#24292E"> obj.mass) </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span>
<span class="line"><span style="color:#24292E">  obj.vy </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> (fy </span><span style="color:#D73A49">/</span><span style="color:#24292E"> obj.mass) </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span>
<span class="line"><span style="color:#24292E">  obj.x </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> obj.vx </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span>
<span class="line"><span style="color:#24292E">  obj.y </span><span style="color:#D73A49">+=</span><span style="color:#24292E"> obj.vy </span><span style="color:#D73A49">*</span><span style="color:#24292E"> dt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 제약 처리 (바닥 충돌)</span></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (obj.y </span><span style="color:#D73A49">&gt;</span><span style="color:#24292E"> floorY) {</span></span>
<span class="line"><span style="color:#24292E">    obj.y </span><span style="color:#D73A49">=</span><span style="color:#24292E"> floorY;</span></span>
<span class="line"><span style="color:#24292E">    obj.vy </span><span style="color:#D73A49">*=</span><span style="color:#D73A49"> -</span><span style="color:#24292E">restitution; </span><span style="color:#6A737D">// 반발 계수만큼 튕김</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre>
<p>이 구조가 강력한 이유는 <strong>규칙만 정의하면 움직임은 알아서 만들어진다</strong>는 점이다. 컨페티를 예로 들어보자. 각 조각의 궤적을 이징 함수로 일일이 설계하려면 비현실적이다. 하지만 중력과 공기 저항, 회전만 설정하면 수십 개의 조각이 각자 다른 궤적을 그리며 떨어진다. 개별 궤적을 신경 쓸 필요가 없다.</p>
<astro-island uid="Z1y5jXi" prefix="r36" component-url="/_astro/index.BLQV0jyi.js" component-export="ConfettiDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;ConfettiDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="position:relative"><canvas style="width:100%;height:220px;display:block;border-radius:8px;background:#f8f9fa"></canvas><div style="position:absolute;bottom:16px;left:0;right:0;text-align:center"><button style="padding:8px 24px;border-radius:20px;border:none;background:#228be6;color:#fff;font-size:14px;font-weight:600;cursor:pointer">발사</button></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">규칙만 정의하면 자연스러운 움직임이 만들어진다</div></div><!--astro:end--></astro-island>
<p>이런 점에서 물리 시뮬레이션은 <strong>다수의 오브젝트가 상호작용</strong>하거나, <strong>사용자 입력에 따라 결과가 달라지는</strong> 상황에서 유용하다.</p>
<p>다만 물리 시뮬레이션은 <strong>예측 가능성이 떨어진다</strong>는 단점이 있다. 이징 기반 애니메이션은 언제 어떤 위치에 있을지 정확히 알 수 있지만 물리 시뮬레이션은 초기 조건에 따라 결과가 달라진다. 따라서 UI의 핵심 전환 애니메이션보다는 보조적인 효과나 인터랙티브 요소에 더 적합한 경우가 많다.</p>
<h2 id="자연스러운-방향-전환"><a href="#자연스러운-방향-전환">자연스러운 방향 전환</a></h2>
<p>지금까지는 값이 목표를 향해 <strong>얼마나</strong> 변하는지를 다뤘다. 이번에는 <strong>어느 방향으로</strong> 변하는지를 다룰 것이다. 화면 위에서 요소가 커서를 따라다니는 애니메이션을 만든다고 하자. 위치를 따라가는 것은 어렵지 않다. 하지만 요소가 이동 방향을 바라보도록 <strong>회전</strong>까지 시키려면 어떻게 해야 할까?</p>
<p>이때 필요한 것이 <code>atan2</code> 함수다. <code>atan2(dy, dx)</code>는 두 점 사이의 각도를 라디안으로 반환한다. 현재 위치와 목표 위치의 차이 <code>(dx, dy)</code>를 넣으면, 요소가 바라봐야 할 방향이 나온다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> dx</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> targetX </span><span style="color:#D73A49">-</span><span style="color:#24292E"> currentX;</span></span>
<span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> dy</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> targetY </span><span style="color:#D73A49">-</span><span style="color:#24292E"> currentY;</span></span>
<span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> angle</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> Math.</span><span style="color:#6F42C1">atan2</span><span style="color:#24292E">(dy, dx);</span></span>
<span class="line"><span style="color:#24292E">element.style.transform </span><span style="color:#D73A49">=</span><span style="color:#032F62"> `rotate(${</span><span style="color:#24292E">angle</span><span style="color:#032F62">}rad)`</span><span style="color:#24292E">;</span></span></code></pre>
<p>단순하지만 이것만으로도 움직임의 자연스러움이 크게 달라진다. 화살표가 이동 방향을 바라보거나, 캐릭터가 목적지를 향해 고개를 돌리거나, 파티클이 퍼져나가는 방향으로 늘어나는 효과 모두 <code>atan2</code>가 핵심이다.</p>
<astro-island uid="Z1THYmu" prefix="r37" component-url="/_astro/index.BLQV0jyi.js" component-export="Atan2Demo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;Atan2Demo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><canvas style="width:100%;height:220px;display:block;cursor:crosshair;border-radius:8px;touch-action:none"></canvas></div><!--astro:end--></astro-island>
<p><code>atan2</code>의 실전 활용 사례를 하나 보자. 카드 UI 위에서 마우스를 움직이면 카드가 커서 방향으로 기우는 3D 틸트 효과다. <code>atan2</code>로 커서의 <strong>방향</strong>을, 중심으로부터의 거리로 기울기의 <strong>강도</strong>를 구한다.</p>
<astro-island uid="zNssp" prefix="r38" component-url="/_astro/index.BLQV0jyi.js" component-export="CardTiltDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;CardTiltDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;justify-content:center;align-items:center;height:240px;background:#f8f9fa;border-radius:8px;cursor:default"><div style="width:220px;background:#fff;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.12);padding:20px;will-change:transform"><div style="display:flex;align-items:center;gap:12px;margin-bottom:14px"><div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg, #228be6, #845ef7);flex-shrink:0"></div><div style="line-height:1.3"><div style="font-size:14px;font-weight:600;color:#212529">홍길동</div><div style="font-size:11px;color:#868e96;margin-top:2px">Frontend Developer</div></div></div><div style="font-size:12px;color:#495057;line-height:1.5;margin-bottom:14px">애니메이션과 인터랙션에 관심이 많은 개발자입니다.</div><div style="display:flex;gap:16px;font-size:11px;color:#868e96"><span><strong style="color:#212529">128</strong> posts</span><span><strong style="color:#212529">1.2k</strong> followers</span></div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">카드 위에서 마우스를 움직여보세요</div></div><!--astro:end--></astro-island>
<p>이처럼 두 점 사이의 방향을 구할 수 있으면 표현할 수 있는 애니메이션의 폭이 크게 넓어진다.</p>
<h2 id="삼각함수로-만드는-주기적-움직임"><a href="#삼각함수로-만드는-주기적-움직임">삼각함수로 만드는 주기적 움직임</a></h2>
<p>우리가 중학교 때 배운 삼각함수는 애니메이션에서 매우 넓은 쓰임새를 가진다. 핵심 특성은 <strong>주기성</strong>이다. 값이 -1에서 1 사이를 끝없이 반복하기 때문에, 반복되는 움직임을 만드는 데 최적의 도구다.</p>
<p>하나의 <code>sin</code> 함수와 위상 오프셋만으로 수십 개 요소의 협응적인 움직임이 만들어진다. 로딩 인디케이터, 이퀄라이저 바, 물결 효과 등 주기적이면서 군무처럼 보이는 애니메이션 대부분이 이 원리 위에 있다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> y</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> amplitude </span><span style="color:#D73A49">*</span><span style="color:#24292E"> Math.</span><span style="color:#6F42C1">sin</span><span style="color:#24292E">(time </span><span style="color:#D73A49">*</span><span style="color:#24292E"> frequency);</span></span></code></pre>
<p><code>sin</code>이나 <code>cos</code> 함수에 세 개의 파라미터를 조절하면 원하는 모양의 반복을 만들 수 있다.</p>
<ul>
<li><strong>진폭</strong><sup>amplitude</sup>: 움직임의 크기. 값이 클수록 넓게 흔들린다</li>
<li><strong>주파수</strong><sup>frequency</sup>: 움직임의 빠르기. 값이 클수록 빠르게 반복한다</li>
<li><strong>위상</strong><sup>phase</sup>: 시작 지점의 오프셋. 여러 요소에 서로 다른 위상을 주면 파동 효과가 만들어진다</li>
</ul>
<p>삼각함수가 특히 강력한 순간은 <strong>여러 요소에 위상 차이를 줄 때</strong>다. 예를 들어, 리스트의 각 아이템에 인덱스에 비례하는 위상을 주면 파도처럼 차례로 움직이는 효과가 된다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#24292E">items.</span><span style="color:#6F42C1">forEach</span><span style="color:#24292E">((</span><span style="color:#E36209">item</span><span style="color:#24292E">, </span><span style="color:#E36209">i</span><span style="color:#24292E">) </span><span style="color:#D73A49">=&gt;</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#D73A49">  const</span><span style="color:#005CC5"> y</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> amplitude </span><span style="color:#D73A49">*</span><span style="color:#24292E"> Math.</span><span style="color:#6F42C1">sin</span><span style="color:#24292E">(time </span><span style="color:#D73A49">*</span><span style="color:#24292E"> frequency </span><span style="color:#D73A49">+</span><span style="color:#24292E"> i </span><span style="color:#D73A49">*</span><span style="color:#24292E"> phaseOffset);</span></span>
<span class="line"><span style="color:#24292E">  item.style.transform </span><span style="color:#D73A49">=</span><span style="color:#032F62"> `translateY(${</span><span style="color:#24292E">y</span><span style="color:#032F62">}px)`</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">});</span></span></code></pre>
<astro-island uid="Z1GydRO" prefix="r52" component-url="/_astro/index.BLQV0jyi.js" component-export="TrigWaveDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;TrigWaveDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;gap:24px;flex-wrap:wrap;margin-bottom:16px"><div style="flex:1;min-width:140px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Amplitude (<!-- -->진폭<!-- -->): <strong>20</strong></label><input type="range" min="5" max="40" style="width:100%" value="20"/></div><div style="flex:1;min-width:140px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Frequency (<!-- -->주파수<!-- -->): <strong>1.0</strong></label><input type="range" min="0.5" max="5" step="0.1" style="width:100%" value="1"/></div><div style="flex:1;min-width:140px"><label style="font-size:13px;color:#495057;display:block;margin-bottom:4px">Phase Offset (<!-- -->위상 차이<!-- -->): <strong>0.5</strong></label><input type="range" min="0" max="2" step="0.1" style="width:100%" value="0.5"/></div></div><div style="display:flex;align-items:center;justify-content:center;height:120px;background:#f8f9fa;border-radius:8px;gap:6px"><div style="width:8px;height:40px;border-radius:4px;background:hsl(210, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(213, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(216, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(219, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(222, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(225, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(228, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(231, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(234, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(237, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(240, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(243, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(246, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(249, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(252, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(255, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(258, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(261, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(264, 70%, 55%)"></div><div style="width:8px;height:40px;border-radius:4px;background:hsl(267, 70%, 55%)"></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:6px">위상 차이를 조절하면 파동 효과를 만들 수 있습니다</div></div><!--astro:end--></astro-island>
<p>실전에서는 메신저의 타이핑 인디케이터가 대표적이다. 세 개의 점이 차례로 튀어오르는 이 효과는 동일한 <code>sin</code>에 위상만 다르게 준 것이다.</p>
<astro-island uid="2d7dLH" prefix="r39" component-url="/_astro/index.BLQV0jyi.js" component-export="LoadingIndicatorDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;LoadingIndicatorDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;justify-content:center;align-items:center;height:80px;background:#f8f9fa;border-radius:8px"><div style="position:relative"><div style="display:flex;align-items:center;gap:5px;background:#e9ecef;border-radius:18px 18px 18px 4px;padding:10px 16px"><div style="width:7px;height:7px;border-radius:50%;background:#868e96;will-change:transform"></div><div style="width:7px;height:7px;border-radius:50%;background:#868e96;will-change:transform"></div><div style="width:7px;height:7px;border-radius:50%;background:#868e96;will-change:transform"></div></div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">sin + 위상 오프셋으로 만든 타이핑 인디케이터</div></div><!--astro:end--></astro-island>
<p>랜딩 페이지에서 흔히 보이는 플로팅 효과도 삼각함수를 이용해 만들 수 있다. 각 요소마다 서로 다른 진폭, 주파수, 위상을 주면 동일한 <code>sin</code> 함수 하나로 자연스러운 배경이 만들어진다.</p>
<astro-island uid="Z12ohrf" prefix="r40" component-url="/_astro/index.BLQV0jyi.js" component-export="FloatingHeroDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;FloatingHeroDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="position:relative;height:160px;background:linear-gradient(135deg, #f8f9fa, #e9ecef);border-radius:8px;overflow:hidden"><div style="position:absolute;left:15%;top:20%;font-size:28px;will-change:transform;user-select:none">🚀</div><div style="position:absolute;left:75%;top:15%;font-size:28px;will-change:transform;user-select:none">⭐</div><div style="position:absolute;left:60%;top:65%;font-size:28px;will-change:transform;user-select:none">🎨</div><div style="position:absolute;left:25%;top:70%;font-size:28px;will-change:transform;user-select:none">💡</div><div style="position:absolute;left:45%;top:30%;font-size:28px;will-change:transform;user-select:none">⚙️</div><div style="position:absolute;left:85%;top:50%;font-size:28px;will-change:transform;user-select:none">🌟</div><div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none"><span style="font-size:15px;font-weight:600;color:#495057;background:rgba(255,255,255,0.8);padding:6px 16px;border-radius:8px">Creative Studio</span></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">각 요소마다 다른 진폭·주파수·위상을 가진다</div></div><!--astro:end--></astro-island>
<h2 id="톱니파"><a href="#톱니파">톱니파</a></h2>
<p><code>sin</code>은 값이 올라갔다 내려오는 <strong>왕복</strong> 운동에 적합하다. 하지만 모든 반복이 왕복인 것은 아니다. 알림 배지의 펄스 링처럼 값이 0에서 1로 <strong>한 방향</strong>으로 진행한 뒤 처음으로 돌아가 다시 시작하는 패턴도 있다. 이것을 <strong>톱니파</strong><sup>sawtooth wave</sup>라고 부른다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> p</span><span style="color:#D73A49"> =</span><span style="color:#24292E"> (t </span><span style="color:#D73A49">%</span><span style="color:#24292E"> period) </span><span style="color:#D73A49">/</span><span style="color:#24292E"> period; </span><span style="color:#6A737D">// 항상 0~1, 주기마다 리셋</span></span></code></pre>
<p><code>t</code>를 <code>period</code>로 나눈 나머지를 구하면, 값은 0에서 1까지 선형으로 올라갔다가 즉시 0으로 떨어진다. 이 <code>p</code>를 스케일이나 투명도에 매핑하면 “퍼지면서 사라지는” 반복 효과가 만들어진다.</p>
<pre class="astro-code github-light" style="background-color:#fff;color:#24292e;overflow-x:auto" tabindex="0" data-language="js"><code><span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> scale</span><span style="color:#D73A49"> =</span><span style="color:#005CC5"> 1</span><span style="color:#D73A49"> +</span><span style="color:#24292E"> p </span><span style="color:#D73A49">*</span><span style="color:#005CC5"> 0.8</span><span style="color:#24292E">;   </span><span style="color:#6A737D">// 1 → 1.8로 커짐</span></span>
<span class="line"><span style="color:#D73A49">const</span><span style="color:#005CC5"> opacity</span><span style="color:#D73A49"> =</span><span style="color:#005CC5"> 1</span><span style="color:#D73A49"> -</span><span style="color:#24292E"> p;        </span><span style="color:#6A737D">// 1 → 0으로 사라짐</span></span></code></pre>
<astro-island uid="ZzpqJL" prefix="r41" component-url="/_astro/index.BLQV0jyi.js" component-export="PulseBadgeDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;PulseBadgeDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;justify-content:center;align-items:center;gap:40px;height:120px;background:#f8f9fa;border-radius:8px"><div style="position:relative"><div style="width:56px;height:56px;border-radius:14px;background:linear-gradient(135deg, #228be6, #339af0);display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(34,139,230,0.3)"><svg width="28" height="28" viewBox="0 0 24 24" fill="none"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z" fill="white"></path></svg></div><div style="position:absolute;top:-6px;right:-6px"><div style="position:absolute;top:50%;left:50%;width:22px;height:22px;border-radius:50%;border:2px solid #fa5252;transform:translate(-50%, -50%);pointer-events:none"></div><div style="width:22px;height:22px;border-radius:50%;background:#fa5252;color:#fff;font-size:11px;font-weight:700;display:flex;align-items:center;justify-content:center;border:2px solid #fff">3</div></div></div><canvas style="width:200px;height:60px;display:block"></canvas></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">톱니파 — 값이 0→1로 단방향 진행 후 리셋을 반복한다</div></div><!--astro:end--></astro-island>
<p>톱니파는 “시작 → 끝 → 즉시 리셋”이라는 단순한 구조 덕분에 펄스, 핑, 반복 프로그레스 같은 패턴에 널리 쓰인다. <code>sin</code>의 부드러운 왕복과 톱니파의 단방향 리셋 두 가지만으로도 대부분의 주기적 애니메이션을 표현할 수 있다.</p>
<h1 id="애니메이션-설계하기"><a href="#애니메이션-설계하기">애니메이션 설계하기</a></h1>
<p>지금까지 이징, 스프링, 삼각함수 같은 수학 도구를 살펴봤다. 하나의 도구로 해결되는 경우도 있지만, 현실의 애니메이션은 대부분 더 복잡하다. 예를 들어, 알림이 나타날 때 배경이 어두워지면서 카드가 올라오고, 내용이 드러나도록 만들고 싶다면 어떻게 해야할까?</p>
<p>복잡한 애니메이션을 설계하려면 먼저 두 가지를 이해해야 한다. 그래프를 어떻게 쪼개는지, 그리고 애니메이션의 상태가 무엇에 의존하는지다.</p>
<h2 id="그래프를-나눠라"><a href="#그래프를-나눠라">그래프를 나눠라</a></h2>
<p>복잡한 움직임은 하나의 수식으로 표현하기 어렵다. 이럴 때는 그래프를 <strong>구간별로 쪼개는</strong> 방법을 사용할 수 있다.</p>
<p>예를 들어, 지도 앱에서 핀이 제자리에서 통통 튀다 안착하는 애니메이션을 생각해보자. 물리 시뮬레이션으로도 비슷한 결과를 낼 수 있지만 자연스러운 움직임이 항상 좋은 애니메이션은 아니다. 두 번째 바운스의 높이를 의도적으로 줄이거나, 마지막 안착을 더 부드럽게 만들고 싶을 수 있다. 이럴 때 구간을 나누면 이런 세밀한 조정이 가능해진다. 각 구간은 단순한 그래프 조각이고 이들을 이어 붙이면 전체 애니메이션이 완성된다.</p>
<astro-island uid="ZupPWS" prefix="r42" component-url="/_astro/index.BLQV0jyi.js" component-export="BounceGraphDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;BounceGraphDemo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;align-items:center;gap:48px;padding:24px 0;flex-wrap:wrap"><div style="width:48px;height:80px;position:relative"><div style="position:absolute;bottom:3px;left:50%;transform:translateX(-50%);z-index:1"><svg width="28" height="40" viewBox="0 0 28 40" style="display:block"><path d="M14 0C6.27 0 0 6.27 0 14c0 10.5 14 26 14 26s14-15.5 14-26C28 6.27 21.73 0 14 0z" fill="#fa5252"></path><circle cx="14" cy="14" r="6" fill="#fff"></circle></svg></div><div style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);width:20px;height:6px;border-radius:50%;background:rgba(0,0,0,0.12)"></div></div><canvas style="width:100%;max-width:280px;aspect-ratio:280 / 160;display:block"></canvas></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:4px">핀 바운스 — 각 구간을 독립적으로 설계한 뒤 이어 붙인다</div></div><!--astro:end--></astro-island>
<p>이러한 그래프는 수학에서 구간별 함수<sup>piecewise function</sup>라 부르는 것과 같은 원리다. <strong>복잡한 움직임을 단순한 조각으로 나누고 각 조각을 개별적으로 설계한 뒤 다시 이어 붙이는 것</strong>이다.</p>
<h2 id="무엇에-의존하는가"><a href="#무엇에-의존하는가">무엇에 의존하는가</a></h2>
<p>그래프의 가로축이 꼭 시간일 필요는 없다. 이 부분을 좀 더 구체적으로 살펴보자. 애니메이션의 값이 <strong>무엇에 의존하는가</strong>를 파악하는 것은 설계의 출발점이다. 대표적으로 세 가지 유형이 있다.</p>
<p><strong>시간 기반</strong> 애니메이션은 가장 흔한 형태다. 시작 시점부터 시간이 흘러감에 따라 값이 변한다. 이전 상태에 시간 변화를 적용해 다음 상태를 만들어내는 것으로, <code>f(state, Δt) → nextState</code> 형태로 표현할 수 있다. 매 프레임마다 이 함수를 반복 적용하면 애니메이션이 진행된다.</p>
<p><strong>값 기반</strong> 애니메이션은 시간이 아닌 특정 값이 입력이 된다. 대표적인 예가 스크롤 기반 패럴랙스 효과다. 사용자가 스크롤을 내리는 만큼 요소의 위치나 투명도가 변한다. 스크롤 오프셋이 그래프의 가로축이 되는 셈이다. 마우스 위치, 센서 데이터 등 다양한 값이 가로축이 될 수 있다.</p>
<p><strong>이벤트 기반</strong> 애니메이션은 특정 트리거에 의해 값이 전환된다. 호버, 클릭, 데이터 로딩 완료 같은 이벤트가 발생하면 현재 값에서 다음 값으로의 전환 애니메이션이 시작된다. 이 경우 애니메이션은 이벤트에 의해 <strong>촉발</strong>되고, 전환 과정 자체는 시간 기반으로 동작하는 혼합 형태가 많다.</p>
<p>어떤 애니메이션을 설계할 때 가장 먼저 물어야 할 질문은 “이 애니메이션의 값은 무엇에 의존하는가?”이다. 이 질문에 답하면 그래프의 가로축이 정해지고 거기에 맞는 구현 방식을 선택할 수 있다.</p>
<p>그래프를 쪼개는 법과 값의 의존성을 파악했다면 이제 조각들을 <strong>조립</strong>할 차례다. 조립 방식에 따라 세 가지 패턴이 있다.</p>
<h2 id="파이프라이닝"><a href="#파이프라이닝">파이프라이닝</a></h2>
<p>가장 직관적인 조립 방법은 조각들을 <strong>순서대로 나란히 놓는</strong> 것이다. 이를 <strong>파이프라이닝</strong>이라 한다. 예를 들어, 알림이 나타나는 애니메이션을 설계한다면 다음과 같이 세 조각이 나온다.</p>
<ol>
<li>배경 어두워짐 — opacity 0 → 0.5, 200ms</li>
<li>카드 올라옴 — 위치 아래 → 제자리, 300ms, ease-out</li>
<li>내용 드러남 — opacity 0 → 1, 200ms</li>
</ol>
<p>각 조각은 독립적인 그래프지만 시간축 위에 순서대로 배치하면 파이프라인이 된다.</p>
<astro-island uid="Z11D734" prefix="r43" component-url="/_astro/index.BLQV0jyi.js" component-export="PipelineTimelineDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;PipelineTimelineDemo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;padding:18px 0"><canvas style="width:100%;max-width:400px;aspect-ratio:400 / 110;display:block"></canvas></div></div><!--astro:end--></astro-island>
<p>배치 전략은 다양하다. 반드시 이전 조각이 끝난 뒤에 시작할 필요는 없다.</p>
<ul>
<li><strong>순차</strong>: A가 끝나면 B 시작</li>
<li><strong>겹침</strong>: A의 80% 지점에서 B 시작. 조각 사이 끊김이 줄어든다</li>
<li><strong>동시</strong>: A와 B가 동시에 시작하되, 서로 다른 속성을 변화시킨다</li>
<li><strong>스태거</strong>: 같은 애니메이션을 여러 요소에 시간차를 두고 적용한다. 리스트 아이템이 하나씩 나타나는 것이 대표적이다</li>
</ul>
<p>파이프라이닝의 장점은 <strong>각 조각을 독립적으로 수정할 수 있다</strong>는 것이다. 카드가 올라오는 속도가 너무 빠르면 그 조각만 수정하면 된다. 전체 애니메이션을 처음부터 다시 설계할 필요가 없다.</p>
<astro-island uid="Z2ptTbE" prefix="r44" component-url="/_astro/index.BLQV0jyi.js" component-export="PipelineDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;PipelineDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="position:relative;height:160px;background:#f8f9fa;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center"><div style="position:absolute;inset:0;background:#000;opacity:0"></div><div style="position:relative;width:220px;background:#fff;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.12);padding:16px;opacity:0;transform:translateY(120px);will-change:transform, opacity"><div style="opacity:0"><div style="font-size:13px;font-weight:600;color:#212529;margin-bottom:4px">새 메시지</div><div style="font-size:12px;color:#868e96">안녕하세요! 확인해주세요.</div></div></div></div><div style="margin-top:12px"><div style="display:flex;gap:3px;position:relative;margin-bottom:6px"><div style="flex:200;height:6px;background:#228be6;border-radius:3px;opacity:0.25"></div><div style="flex:300;height:6px;background:#40c057;border-radius:3px;opacity:0.25"></div><div style="flex:200;height:6px;background:#fab005;border-radius:3px;opacity:0.25"></div><div style="position:absolute;top:-3px;left:0;width:3px;height:12px;background:#212529;border-radius:1.5px;opacity:0;will-change:left"></div></div><div style="display:flex;gap:3px"><div style="flex:200;font-size:10px;color:#228be6;text-align:center">배경</div><div style="flex:300;font-size:10px;color:#40c057;text-align:center">카드</div><div style="flex:200;font-size:10px;color:#fab005;text-align:center">내용</div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:8px">세 조각이 시간축 위에 순서대로 배치된다</div></div><!--astro:end--></astro-island>
<h2 id="상태-전환으로-설계하기"><a href="#상태-전환으로-설계하기">상태 전환으로 설계하기</a></h2>
<p>파이프라이닝이 어떠한 축을 기준으로 순서대로 배치하는 것이라면, <strong>상태 전환은 조건에 따라 다음 단계로 넘어가는 방식</strong>이다. 하나의 요소가 중간에 성격이 완전히 달라지는 여러 단계를 거칠 때 적합하다.</p>
<p>폭죽 애니메이션을 설계해보자. 하나의 파티클이 다음 상태를 거친다.</p>



































<table><thead><tr><th>상태</th><th>변하는 것</th><th>그래프</th><th>전환 조건</th></tr></thead><tbody><tr><td>발사</td><td>높이 ↑</td><td>가속 (ease-in)</td><td>속도 = 0 → 폭발</td></tr><tr><td>폭발</td><td>파티클 분리</td><td>순간 전환</td><td>즉시 → 확산</td></tr><tr><td>확산</td><td>반경 ↑, 속도 ↓</td><td>감속 + 중력</td><td>시간 경과 → 소멸</td></tr><tr><td>소멸</td><td>opacity ↓</td><td>선형 감소</td><td>opacity = 0 → 제거</td></tr></tbody></table>
<p>각 상태는 서로 다른 그래프를 가진다. 발사는 시간-높이, 확산은 시간-반경, 소멸은 시간-투명도다. 하나의 수식으로 표현하기는 어렵지만 상태별로 끊으면 각 조각은 단순하다.</p>
<p>핵심은 <strong>전환 조건을 명확히 정의하는 것</strong>이다. “속도가 0이 되면 폭발”, “투명도가 0이 되면 제거”처럼 다음 상태로 넘어가는 트리거를 명시하면 복잡한 애니메이션도 상태 머신처럼 관리할 수 있다. 따라서 다음과 같이 다이어그램으로 표현할 수도 있다.</p>
<astro-island uid="Z2mUsFg" prefix="r45" component-url="/_astro/index.BLQV0jyi.js" component-export="FireworkStateDiagram" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;FireworkStateDiagram&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;padding:12px 0"><canvas style="width:100%;max-width:460px;aspect-ratio:460 / 72;display:block"></canvas></div></div><!--astro:end--></astro-island>
<p>파이프라이닝과의 차이는 <strong>언제가 아니라 어떤 조건에서</strong>가 중심이라는 점이다. 시간이 아닌 상태 값에 의해 전환이 결정되므로, 물리 시뮬레이션이나 사용자 인터랙션처럼 결과를 미리 예측하기 어려운 상황에서 자연스럽게 들어맞는다.</p>
<astro-island uid="ZhFsbN" prefix="r46" component-url="/_astro/index.BLQV0jyi.js" component-export="FireworkDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;FireworkDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><canvas style="width:100%;height:250px;display:block;border-radius:8px"></canvas><div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px"><span style="font-size:11px;color:#adb5bd">발사 → 폭발 → 확산 → 소멸</span><span style="font-size:12px;color:#228be6;font-weight:600;padding:2px 8px;background:#e7f5ff;border-radius:4px">발사</span></div></div><!--astro:end--></astro-island>
<h2 id="속성-분리"><a href="#속성-분리">속성 분리</a></h2>
<p>간혹 여러 속성이 동시에 변화해야 할 때도 있다. 이런 경우에는 <strong>여러 속성을 독립적인 트랙으로 분리</strong>하는 것이 좋다.</p>
<p>요금제 카드를 클릭해서 선택하는 UI를 예로 들어보자. 카드를 클릭하면 선택했음을 알리기 위해 테두리가 파란색으로 바꿀 필요가 있다. 그리고 강조를 위해 카드를 살짝 커지게 만들 필요도 있다. 더불어 사용자가 관심을 가지는 상세 내용이 드러나도록 묘사할 필요도 있다. 세 가지 변화가 동시에 일어나지만 각각 필요로 하는 움직임의 성격은 다를 것이다.</p>
<p>이들을 하나의 수식으로 묶으면 각각의 요구를 충족할 수 없다. 대신 각 속성을 독립적인 트랙으로 분리하면 된다. 다음 예제를 확인해보자.</p>
<astro-island uid="Zmitfl" prefix="r47" component-url="/_astro/index.BLQV0jyi.js" component-export="PropertySplitDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;PropertySplitDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;justify-content:center;padding:24px 0;background:#f8f9fa;border-radius:8px"><div style="width:240px;padding:16px;border-radius:12px;border:1px solid #dee2e6;background:#fff;cursor:pointer;will-change:transform;user-select:none;position:relative"><div style="position:absolute;top:12px;right:12px;width:20px;height:20px;border-radius:50%;background:#228be6;display:flex;align-items:center;justify-content:center;opacity:0;will-change:opacity, transform"><svg width="12" height="12" viewBox="0 0 12 12"><path d="M2 6l3 3 5-5" stroke="#fff" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><div style="font-size:14px;font-weight:600;color:#212529;margin-bottom:4px">Pro 플랜</div><div style="font-size:12px;color:#868e96">월 29,000원</div><div style="margin-top:10px;padding-top:10px;border-top:1px solid #f1f3f5;opacity:0;will-change:opacity, transform"><div style="font-size:11px;color:#495057;line-height:1.6">무제한 프로젝트<br/>팀 협업 기능<br/>우선 지원</div></div></div></div><div style="margin-top:16px"><div style="display:flex;align-items:center;gap:8px;margin-bottom:6px"><span style="font-size:11px;color:#868e96;width:48px;text-align:right;flex-shrink:0">테두리</span><div style="flex:1;height:6px;background:#f1f3f5;border-radius:3px;overflow:hidden"><div style="height:100%;background:#228be6;border-radius:3px;width:0%;will-change:width"></div></div><span style="font-size:10px;color:#adb5bd;width:100px;flex-shrink:0">150ms, ease-out</span></div><div style="display:flex;align-items:center;gap:8px;margin-bottom:6px"><span style="font-size:11px;color:#868e96;width:48px;text-align:right;flex-shrink:0">크기</span><div style="flex:1;height:6px;background:#f1f3f5;border-radius:3px;overflow:hidden"><div style="height:100%;background:#40c057;border-radius:3px;width:0%;will-change:width"></div></div><span style="font-size:10px;color:#adb5bd;width:100px;flex-shrink:0">스프링</span></div><div style="display:flex;align-items:center;gap:8px"><span style="font-size:11px;color:#868e96;width:48px;text-align:right;flex-shrink:0">상세</span><div style="flex:1;height:6px;background:#f1f3f5;border-radius:3px;overflow:hidden"><div style="height:100%;background:#fab005;border-radius:3px;width:0%;will-change:width"></div></div><span style="font-size:10px;color:#adb5bd;width:100px;flex-shrink:0">400ms, ease-out</span></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:10px">카드를 클릭하세요 — 세 속성이 각자의 곡선으로 독립 변화한다</div></div><!--astro:end--></astro-island>
<p>속성 분리의 핵심은 <strong>각 트랙이 서로를 몰라도 된다는 것</strong>이다. 테두리 트랙을 수정해도 크기나 상세 내용에 영향이 없다. 이 독립성 덕분에 하나의 속성만 미세 조정하거나 새 속성을 추가하는 것이 쉬워진다.</p>
<h2 id="랜덤성"><a href="#랜덤성">랜덤성</a></h2>
<p>앞서 상태 전환 부분에서 폭죽 예제를 살펴보았다. 만약 모든 파티클이 정확히 같은 속도, 같은 각도 간격으로 퍼진다면 어떨까? 기하학적으로는 정확하지만 자연스럽지는 않다. 현실의 폭죽은 조금씩 불규칙하다. 이 불규칙함이 오히려 자연스러움을 만든다.</p>
<p>애니메이션에 <strong>랜덤성</strong>을 더하면 기계적인 느낌을 벗어날 수 있다. 파티클의 속도에 ±20% 편차를 주거나, 각도에 약간의 흔들림을 추가하거나, 시작 타이밍을 미세하게 어긋나게 하는 것이다.</p>
<p>하지만 여기서 중요한 원칙이 있다. <strong>랜덤은 진짜 랜덤이면 안 된다.</strong> 완전한 무작위는 예측 불가능하고 의도하지 않은 결과를 만든다. 예를 들어, 파티클이 전부 한쪽으로 쏠리거나 크기가 너무 극단적으로 나올 수 있다.</p>
<astro-island uid="1ibrCg" prefix="r48" component-url="/_astro/index.BLQV0jyi.js" component-export="RandomComparisonDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;RandomComparisonDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="display:flex;gap:12px"><div style="flex:1"><canvas style="width:100%;height:200px;display:block;border-radius:8px"></canvas><div style="font-size:12px;font-weight:600;color:#868e96;text-align:center;margin-top:8px">순수 랜덤</div><div style="font-size:10px;color:#adb5bd;margin-top:6px;line-height:1.7;padding-left:4px">속도 <span style="color:#868e96">0 ~ 5</span><br/>크기 <span style="color:#868e96">1 ~ 9</span><br/>색상 <span style="color:#868e96">0° ~ 360°</span><br/>분포 <span style="color:#868e96">무작위</span></div></div><div style="flex:1"><canvas style="width:100%;height:200px;display:block;border-radius:8px"></canvas><div style="font-size:12px;font-weight:600;color:#868e96;text-align:center;margin-top:8px">통제된 랜덤</div><div style="font-size:10px;color:#adb5bd;margin-top:6px;line-height:1.7;padding-left:4px">속도 <span style="color:#868e96">2 ~ 3.5</span><br/>크기 <span style="color:#868e96">2.5 ~ 4</span><br/>색상 <span style="color:#868e96">기준 hue ± 20°</span><br/>분포 <span style="color:#868e96">균등 배치 + 미세 편차</span></div></div></div></div><!--astro:end--></astro-island>
<p>애니메이션을 <strong>의도한 것</strong>과 <strong>의도하지 않은 것</strong>으로 나눠 생각하면 도움이 된다. 파티클이 위로 올라가는 것은 의도한 움직임이고, 각 파티클의 미세한 속도 차이는 의도적으로 넣은 비의도적 요소다. 설계자는 “어디까지를 통제하고, 어디부터를 랜덤에 맡길 것인가”를 결정해야 한다. 이 경계를 잘 설정하면 질서와 자연스러움이 공존하는 애니메이션을 만들 수 있다.</p>
<h2 id="양방향성-고려"><a href="#양방향성-고려">양방향성 고려</a></h2>
<p>지금까지 살펴본 애니메이션은 대부분 <strong>한 방향</strong>으로 흘렀다. 시작에서 끝으로, 0에서 1로. 하지만 스크롤에 반응하는 애니메이션이나 드래그 인터랙션처럼 <strong>사용자가 진행 방향을 바꿀 수 있는</strong> 경우가 있다. 스크롤을 내리면 요소가 나타나고, 다시 올리면 사라진다. 이런 애니메이션은 설계할 때 역재생을 고려해야 한다.</p>
<p>다음 예제를 살펴보면 스크롤에 반응하는 패럴랙스 효과가 어떻게 양방향으로 설계되는지 볼 수 있다. 요소가 스크롤에 따라 나타나고 사라지는 애니메이션이지만, 스크롤 방향이 바뀌어도 자연스럽게 이어진다.</p>
<astro-island uid="QC2Lz" prefix="r49" component-url="/_astro/index.BLQV0jyi.js" component-export="BidirectionalDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;BidirectionalDemo&quot;,&quot;value&quot;:true}" await-children><div style="border:1px solid #dee2e6;border-radius:8px;padding:20px;margin:24px 0;background:#fff"><div style="height:300px;overflow-y:auto;border-radius:8px;background:#f8f9fa;position:relative"><div style="position:sticky;top:0;left:0;width:100%;height:100%;background:#000;opacity:0;pointer-events:none;z-index:1;margin-bottom:-300px"></div><div style="height:800px;position:relative;z-index:2"><div style="font-size:12px;color:#adb5bd;text-align:center;padding-top:24px">↓ 스크롤</div><div style="height:320px"></div><div style="max-width:240px;margin:0 auto;padding:20px;background:#fff;border-radius:12px;box-shadow:0 4px 8px rgba(0,0,0,0.04);opacity:0;transform:translateY(60px) scale(0.7) rotate(6deg);will-change:transform, opacity, box-shadow"><div style="width:36px;height:36px;border-radius:8px;background:linear-gradient(135deg, #228be6, #845ef7);margin-bottom:12px"></div><div style="font-size:14px;font-weight:600;color:#212529;margin-bottom:6px">새로운 알림</div><div style="font-size:12px;color:#868e96;line-height:1.5">스크롤 위치가 곧 애니메이션의 진행도가 된다. 올리면 자연스럽게 되돌아간다.</div></div><div style="height:280px"></div><div style="font-size:12px;color:#adb5bd;text-align:center">↑ 다시 올려보세요</div></div></div><div style="display:flex;align-items:center;gap:8px;margin-top:12px"><div style="flex:1;height:4px;background:#f1f3f5;border-radius:2px;overflow:hidden"><div style="height:100%;background:#228be6;border-radius:2px;width:0%;will-change:width"></div></div><span style="font-size:11px;color:#868e96;width:32px;text-align:right;font-variant-numeric:tabular-nums">0%</span></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:8px">스크롤 위치가 곧 진행도 — 올리면 자연스럽게 되돌아간다</div></div><!--astro:end--></astro-island>
<p>패럴랙스와 같은 값 기반 애니메이션은 양방향성을 고려하기가 상대적으로 쉽다. 그래프의 가로축이 스크롤 오프셋이기 때문에, 방향이 바뀌어도 같은 그래프를 역방향으로 따라가면 된다. 하지만 이벤트 기반 애니메이션처럼 버튼 클릭으로 나타나고 사라지는 경우는 좀 더 신경 써야 한다. 양방향성을 고려하지 않으면 다음과 같은 문제가 생긴다.</p>
<ul>
<li><strong>점프</strong>: 나타나는 도중에 숨기기를 누르면, 현재 위치를 무시하고 처음부터 사라지는 애니메이션이 시작된다. 위치가 순간이동하면서 뚝 끊긴다</li>
<li><strong>동일한 그래프</strong>: 나타날 때와 사라질 때 같은 이징 그래프를 사용하면 움직임이 어색해진다. 예를 들어, ease-in으로 나타났다면 사라질 때는 ease-out을 써야 자연스럽다.</li>
</ul>
<p>양방향성을 제대로 고려하면 방향이 바뀌는 순간 <strong>현재 상태에서 이어서</strong> 반전된다. 아래 예제에서 나타나는 도중에 빠르게 토글해보면 차이를 느낄 수 있다.</p>
<astro-island uid="1fxuaD" prefix="r50" component-url="/_astro/index.BLQV0jyi.js" component-export="BidirectionalCompareDemo" renderer-url="/_astro/client.C9fCgUO1.js" props="{}" ssr client="visible" opts="{&quot;name&quot;:&quot;BidirectionalCompareDemo&quot;,&quot;value&quot;:true}" await-children><div style="margin:24px 0"><div style="display:flex;justify-content:center;margin-bottom:16px"><button style="padding:8px 20px;border:1px solid #dee2e6;border-radius:6px;background:#fff;color:#495057;cursor:pointer;font-size:13px">보이기</button></div><div style="display:flex;gap:16px"><div style="flex:1;background:#f8f9fa;border-radius:8px;padding:12px"><div style="font-size:11px;color:#868e96;text-align:center;margin-bottom:8px">고려하지 않은 경우</div><div style="height:80px;display:flex;align-items:center;justify-content:center"><div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg, #228be6, #845ef7);opacity:0;transform:translateY(30px) scale(0.8)"></div></div></div><div style="flex:1;background:#f8f9fa;border-radius:8px;padding:12px"><div style="font-size:11px;color:#868e96;text-align:center;margin-bottom:8px">고려한 경우</div><div style="height:80px;display:flex;align-items:center;justify-content:center"><div style="width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg, #228be6, #845ef7);opacity:0;transform:translateY(30px) scale(0.8)"></div></div></div></div><div style="font-size:11px;color:#adb5bd;text-align:center;margin-top:8px">나타나는 도중에 빠르게 토글해보세요</div></div><!--astro:end--></astro-island>
<h1 id="정말-복잡한-애니메이션은"><a href="#정말-복잡한-애니메이션은">정말 복잡한 애니메이션은?</a></h1>
<p>지금까지 다룬 기법으로 꽤 많은 애니메이션을 설계할 수 있지만 한계는 분명히 존재한다. 캐릭터가 걷고 뛰는 동작, 손으로 그린 듯한 모핑, 수십 개의 레이어가 정교하게 맞물리는 인트로와 같은 애니메이션을 코드만으로 표현하는 것은 현실적이지 않다.</p>
<p>이런 경우에는 <strong>전문 도구</strong>를 사용하는 것이 맞다. After Effects로 만든 애니메이션을 <a href="https://airbnb.io/lottie/" rel="noopener noreferrer" target="_blank">Lottie</a>로 내보내거나, <a href="https://rive.app/" rel="noopener noreferrer" target="_blank">Rive</a>처럼 인터랙티브 애니메이션에 특화된 도구를 쓰는 방식이다. 혹은 아예 <strong>영상</strong>으로 제작해서 재생하는 것도 방법이다. 코드로 모든 것을 해결하려는 것보다 적절한 도구를 선택하는 것이 더 나은 결과를 만든다.</p>
<figure><img src="/images/2026-02-18-how-to-design-animation/lottie.gif" alt="Lottie를 사용한 복잡한 애니메이션" loading="lazy" width="100%" style="cursor:default;margin:0 auto;display:block"/><figcaption>Lottie를 사용한 복잡한 애니메이션</figcaption></figure>
<p>반대로 말하면 코드로 작성하는 애니메이션의 강점은 <strong>실시간 인터랙션</strong>에 있다. 사용자의 입력에 즉각 반응하고 상태에 따라 동적으로 변하는 움직임은 미리 만들어 둔 영상으로는 구현하기 어렵다. 이 글에서 다룬 기법들이 빛을 발하는 지점이 바로 여기다.</p>
<h1 id="마치며"><a href="#마치며">마치며</a></h1>
<p>애니메이션을 구현할 때 막막했던 경험이 있다면, 이 글이 “어디서부터 시작할지”를 찾는 데 도움이 되었기를 바란다. 결국 애니메이션 설계의 핵심은 <strong>분해</strong>다. 어떤 움직임이든 쪼개면 단순해지고 단순한 조각은 그래프로 그릴 수 있다. 이 과정을 의식적으로 연습하면 머릿속의 움직임을 코드로 옮기는 거리가 점점 가까워질 것이다.</p>  </div> <div> <div class="mt-1 w-full"> <div class="mr-1 mb-1 inline-flex items-center rounded-[50px] border border-[#dfe3e8] px-2 text-[10px] text-[#888]" style="height: 20px;"> animation </div><div class="mr-1 mb-1 inline-flex items-center rounded-[50px] border border-[#dfe3e8] px-2 text-[10px] text-[#888]" style="height: 20px;"> design </div><div class="mr-1 mb-1 inline-flex items-center rounded-[50px] border border-[#dfe3e8] px-2 text-[10px] text-[#888]" style="height: 20px;"> math </div> </div> <div class="flex items-center py-6" data-astro-cid-k7qsseos> <div class="shrink-0 basis-[80px]" data-astro-cid-k7qsseos> <img class="h-[80px] w-[80px] object-cover" style="border-radius: 50%;" src="/images/about/avatar.jpg" data-astro-cid-k7qsseos> </div> <div class="ml-8 flex-1 text-base" data-astro-cid-k7qsseos> <div data-astro-cid-k7qsseos>
Written by <a href="/about/" class="name-gradient font-bold no-underline" data-astro-cid-k7qsseos>
@kciter
</a> </div> <div class="text-sm font-light leading-snug" data-astro-cid-k7qsseos>가치있는 지식이 되기를 바랍니다</div> <div class="-ml-1 [&_a]:text-sm [&_a]:text-[#888]" data-astro-cid-k7qsseos> <a href="https://github.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="GitHub" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.44 9.8 8.2 11.38.6.12.83-.26.83-.57v-2.2c-3.34.73-4.04-1.44-4.04-1.44-.55-1.38-1.33-1.75-1.33-1.75-1.09-.74.08-.73.08-.73 1.2.09 1.84 1.24 1.84 1.24 1.07 1.83 2.8 1.3 3.49 1 .1-.78.42-1.3.76-1.6-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.13-.3-.54-1.52.12-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6.02 0c2.28-1.55 3.28-1.23 3.28-1.23.66 1.66.25 2.88.12 3.18.77.84 1.24 1.91 1.24 3.22 0 4.61-2.81 5.63-5.48 5.92.43.37.81 1.1.81 2.22v3.29c0 .31.22.7.83.57C20.57 21.8 24 17.3 24 12c0-6.63-5.37-12-12-12z"/></svg></a><a href="https://www.facebook.com/sunhyoup.lee" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="Facebook" style="--hover-color: #3d5b99; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M24 12.07C24 5.41 18.63 0 12 0S0 5.41 0 12.07c0 6.02 4.39 11.02 10.13 11.93v-8.44H7.08v-3.49h3.04V9.41c0-3.02 1.79-4.68 4.53-4.68 1.31 0 2.68.24 2.68.24v2.97h-1.51c-1.49 0-1.95.93-1.95 1.88v2.26h3.33l-.53 3.49h-2.8v8.44C19.61 23.09 24 18.09 24 12.07z"/></svg></a><a href="https://www.linkedin.com/in/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="LinkedIn" style="--hover-color: #0073a4; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M20.45 20.45h-3.55v-5.57c0-1.33-.02-3.04-1.85-3.04-1.85 0-2.14 1.45-2.14 2.94v5.67H9.36V9h3.41v1.56h.05c.48-.9 1.64-1.85 3.37-1.85 3.6 0 4.27 2.37 4.27 5.46v6.28zM5.34 7.43a2.06 2.06 0 1 1 0-4.12 2.06 2.06 0 0 1 0 4.12zM7.12 20.45H3.56V9h3.56v11.45zM22.22 0H1.77C.79 0 0 .77 0 1.72v20.56C0 23.23.79 24 1.77 24h20.45C23.2 24 24 23.23 24 22.28V1.72C24 .77 23.2 0 22.22 0z"/></svg></a><a href="https://twitter.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="X (Twitter)" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a><a href="/feed.xml" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="RSS Feed" style="--hover-color: #ff6600; transition: color .5s;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M6.18 15.64a2.18 2.18 0 1 1 0 4.36 2.18 2.18 0 0 1 0-4.36zM4 4.44v3.57A12.01 12.01 0 0 1 15.99 20h3.57A15.57 15.57 0 0 0 4 4.44zM4 10.1v3.57c3.5 0 6.33 2.84 6.33 6.33h3.57c0-5.47-4.43-9.9-9.9-9.9z"/></svg></a> </div> </div> </div>  <div class="mb-2" data-astro-cid-4kgnabjz><div class="my-2 text-[1.3em] font-bold text-[#454f5b]" data-astro-cid-4kgnabjz>
이 글을 후원해주신 고마운 분들
</div><div class="flex" data-astro-cid-4kgnabjz><div class="sponsors flex flex-1" data-astro-cid-4kgnabjz><a href="https://github.com/ibcylon" target="_blank" class="mr-1" style="text-decoration: none;" data-astro-cid-4kgnabjz><img src="https://avatars.githubusercontent.com/u/25360781?u=2c87bc8941f9dfe019e027cb22712e124f88a709&v=4" alt="ibcylon" class="relative h-9 w-9 overflow-hidden" style="border-radius: 50%;" data-astro-cid-4kgnabjz></a><a href="https://github.com/18-12847" target="_blank" class="mr-1" style="text-decoration: none;" data-astro-cid-4kgnabjz><img src="https://avatars.githubusercontent.com/u/118495919?u=f2b649c2058f423f96879c91dd5115c90fdc3354&v=4" alt="18-12847" class="relative h-9 w-9 overflow-hidden" style="border-radius: 50%;" data-astro-cid-4kgnabjz></a><a href="https://github.com/honux77" target="_blank" class="mr-1" style="text-decoration: none;" data-astro-cid-4kgnabjz><img src="https://avatars.githubusercontent.com/u/2168702?u=52a017f8024e27c8c3b749e7daab81e1be6da93d&v=4" alt="honux77" class="relative h-9 w-9 overflow-hidden" style="border-radius: 50%;" data-astro-cid-4kgnabjz></a><a href="https://github.com/Jeewhan" target="_blank" class="mr-1" style="text-decoration: none;" data-astro-cid-4kgnabjz><img src="https://avatars.githubusercontent.com/u/14256139?u=59386eab9b64e21b89c4c587e92c969217a9c417&v=4" alt="Jeewhan" class="relative h-9 w-9 overflow-hidden" style="border-radius: 50%;" data-astro-cid-4kgnabjz></a></div><a href="https://github.com/sponsors/kciter" target="_blank" class="flex h-8 w-[120px] cursor-pointer items-center justify-center rounded-[7px] border border-[#e1e4e8] bg-[#fafbfc] text-sm transition-all hover:bg-[#f0f3f6]" style="text-decoration: none;" data-astro-cid-4kgnabjz><svg height="14" viewBox="0 0 16 16" version="1.1" width="14" class="mr-1 fill-red-500" data-astro-cid-4kgnabjz><path d="m8 14.25.345.666a.75.75 0 0 1-.69 0l-.008-.004-.018-.01a7.152 7.152 0 0 1-.31-.17 22.055 22.055 0 0 1-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.066 22.066 0 0 1-3.744 2.584l-.018.01-.006.003h-.002ZM4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.58 20.58 0 0 0 8 13.393a20.58 20.58 0 0 0 3.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.749.749 0 0 1-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5Z" data-astro-cid-4kgnabjz></path></svg><span data-astro-cid-4kgnabjz>Sponsor</span></a></div></div> <div id="comments"> <astro-island uid="liNcb" prefix="r53" component-url="/_astro/Giscus.BCCeZi7E.js" component-export="default" renderer-url="/_astro/client.C9fCgUO1.js" props="{&quot;repo&quot;:[0,&quot;kciter/kciter.github.io&quot;],&quot;theme&quot;:[0,&quot;light&quot;]}" ssr client="visible" opts="{&quot;name&quot;:&quot;Giscus&quot;,&quot;value&quot;:true}" await-children><div></div><!--astro:end--></astro-island> </div> </div> <div class="pt-8 pb-8" data-astro-cid-llggujpl> <div class="grid grid-cols-3 gap-5 max-[30rem]:grid-cols-1" data-astro-cid-llggujpl> <a href="/posts/principles-of-debugging/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2024-03-16-principles-of-debugging/thumbnail.png" alt="디버깅 원칙" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>디버깅 원칙</div> <small data-astro-cid-llggujpl>2024-03-16</small> </a><a href="/posts/type-driven-development/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2024-01-21-type-driven-development/thumbnail.png" alt="Type-Driven Development" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>Type-Driven Development</div> <small data-astro-cid-llggujpl>2024-01-21</small> </a><a href="/posts/modeling-series-conditional-tree/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png" alt="모델링 시리즈: 조건 트리" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>모델링 시리즈: 조건 트리</div> <small data-astro-cid-llggujpl>2025-04-23</small> </a><a href="/posts/effective-work/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2023-07-10-effective-work/thumbnail.png" alt="갓생사는 방법론" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>갓생사는 방법론</div> <small data-astro-cid-llggujpl>2023-07-10</small> </a><a href="/posts/using-kotlin-script/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2025-01-19-using-kotlin-script/thumbnail.png" alt="Kotlin Script 활용하기" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>Kotlin Script 활용하기</div> <small data-astro-cid-llggujpl>2025-01-19</small> </a><a href="/posts/render-delegation-react-component/" class="related-post block scale-100 no-underline transition-all duration-[333ms] ease-[ease]" style="text-decoration: none;" data-astro-cid-llggujpl> <img src="/images/2024-02-18-render-delegation-react-component/thumbnail.png" alt="Render Delegation하는 React 컴포넌트 만들기" loading="lazy" class="block w-full object-cover shadow-[0_0_10px_2px_rgba(0,0,0,0.05)]" style="aspect-ratio: 16/9;" data-astro-cid-llggujpl> <div class="mt-3 text-xl leading-6 font-thin" data-astro-cid-llggujpl>Render Delegation하는 React 컴포넌트 만들기</div> <small data-astro-cid-llggujpl>2024-02-18</small> </a> </div> </div>  </div> <footer class="m-8 text-center text-[#999]"> <div> <a href="https://github.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="GitHub" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.44 9.8 8.2 11.38.6.12.83-.26.83-.57v-2.2c-3.34.73-4.04-1.44-4.04-1.44-.55-1.38-1.33-1.75-1.33-1.75-1.09-.74.08-.73.08-.73 1.2.09 1.84 1.24 1.84 1.24 1.07 1.83 2.8 1.3 3.49 1 .1-.78.42-1.3.76-1.6-2.67-.3-5.47-1.33-5.47-5.93 0-1.31.47-2.38 1.24-3.22-.13-.3-.54-1.52.12-3.18 0 0 1-.32 3.3 1.23a11.5 11.5 0 0 1 6.02 0c2.28-1.55 3.28-1.23 3.28-1.23.66 1.66.25 2.88.12 3.18.77.84 1.24 1.91 1.24 3.22 0 4.61-2.81 5.63-5.48 5.92.43.37.81 1.1.81 2.22v3.29c0 .31.22.7.83.57C20.57 21.8 24 17.3 24 12c0-6.63-5.37-12-12-12z"/></svg></a><a href="https://www.facebook.com/sunhyoup.lee" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="Facebook" style="--hover-color: #3d5b99; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M24 12.07C24 5.41 18.63 0 12 0S0 5.41 0 12.07c0 6.02 4.39 11.02 10.13 11.93v-8.44H7.08v-3.49h3.04V9.41c0-3.02 1.79-4.68 4.53-4.68 1.31 0 2.68.24 2.68.24v2.97h-1.51c-1.49 0-1.95.93-1.95 1.88v2.26h3.33l-.53 3.49h-2.8v8.44C19.61 23.09 24 18.09 24 12.07z"/></svg></a><a href="https://www.linkedin.com/in/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="LinkedIn" style="--hover-color: #0073a4; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M20.45 20.45h-3.55v-5.57c0-1.33-.02-3.04-1.85-3.04-1.85 0-2.14 1.45-2.14 2.94v5.67H9.36V9h3.41v1.56h.05c.48-.9 1.64-1.85 3.37-1.85 3.6 0 4.27 2.37 4.27 5.46v6.28zM5.34 7.43a2.06 2.06 0 1 1 0-4.12 2.06 2.06 0 0 1 0 4.12zM7.12 20.45H3.56V9h3.56v11.45zM22.22 0H1.77C.79 0 0 .77 0 1.72v20.56C0 23.23.79 24 1.77 24h20.45C23.2 24 24 23.23 24 22.28V1.72C24 .77 23.2 0 22.22 0z"/></svg></a><a href="https://twitter.com/kciter" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="X (Twitter)" style="--hover-color: #343434; transition: color .5s; margin-right: 5px;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a><a href="/feed.xml" target="_blank" rel="noopener noreferrer" class="social-icon inline-block p-[5px] no-underline" aria-label="RSS Feed" style="--hover-color: #ff6600; transition: color .5s;" data-astro-cid-yxtifmrq><svg class="inline-block h-4 w-4" viewBox="0 0 24 24" fill="currentColor" data-astro-cid-yxtifmrq><path d="M6.18 15.64a2.18 2.18 0 1 1 0 4.36 2.18 2.18 0 0 1 0-4.36zM4 4.44v3.57A12.01 12.01 0 0 1 15.99 20h3.57A15.57 15.57 0 0 0 4 4.44zM4 10.1v3.57c3.5 0 6.33 2.84 6.33 6.33h3.57c0-5.47-4.43-9.9-9.9-9.9z"/></svg></a> </div> <div class="mt-4 mb-4 font-['Quattrocento_Sans',sans-serif] text-[0.8rem] text-[#9a9a9a]"> <a href="/about/" class="p-2.5 text-[#999] hover:text-[#333]" style="text-decoration: none;">
kciter.so | devlog by Sunhyoup Lee
</a> </div> </footer> </div> </body></html> <script type="module">document.querySelectorAll(".post-container a[data-footnote-ref]").forEach(o=>{const e=o.getAttribute("href")?.slice(1);if(!e)return;const r=document.getElementById(e);if(!r)return;const t=r.textContent?.replace("↩","").trim()||"";o.setAttribute("data-tooltip",t)});document.querySelectorAll(".code-tabs").forEach(o=>{const e=Array.from(o.querySelectorAll(":scope > pre"));if(e.length<2)return;const r=o.getAttribute("data-labels")?.split(",").map(a=>a.trim()),t=document.createElement("div");t.className="code-tabs-bar",e.forEach((a,s)=>{const n=r?.[s]||a.getAttribute("data-language")||"code",c=document.createElement("button");c.textContent=n,r?.[s]&&c.classList.add("has-filename"),s===0&&c.classList.add("active"),c.addEventListener("click",()=>{t.querySelectorAll("button").forEach(l=>l.classList.remove("active")),e.forEach(l=>l.classList.remove("active")),c.classList.add("active"),e[s].classList.add("active")}),t.appendChild(c)}),e[0].classList.add("active"),o.prepend(t)});const i=document.querySelectorAll(".toc .toc-list a");if(i.length>0){const e=Array.from(i).map(t=>t.getAttribute("href")?.slice(1)).filter(Boolean).map(t=>document.getElementById(t)).filter(Boolean),r=new IntersectionObserver(t=>{for(const a of t)if(a.isIntersecting){const s=a.target.id;i.forEach(n=>{n.classList.toggle("active",n.getAttribute("href")===`#${s}`)})}},{rootMargin:"0px 0px -70% 0px",threshold:0});e.forEach(t=>r.observe(t))}</script>