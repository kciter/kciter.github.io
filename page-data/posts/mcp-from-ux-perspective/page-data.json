{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-04-10-mcp-from-ux-perspective-mdx","path":"/posts/mcp-from-ux-perspective/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n항상 떠들썩한 IT 업계에서 최근 가장 뜨거운 화두는 단연코 MCP(Model Context Protocol)라고 할 수 있습니다. 이 MCP에 대해서는 놀랍다, 재밌다 같은 감상부터 생산성 증대, 새로운 방식의 툴링 등 긍정적인 의견과 그냥 API를 OpenAPI처럼 열어둔 것에 불과하다던가 보안 이슈가 있다던가 하는 부정적인 의견도 많습니다.\n\n저 또한 MCP를 직접 만들어보며 굉장히 흥미롭다고 생각했고, 이번 글에서는 기술적인 것보다 UX(사용자 경험)라는 조금 다른 관점에서 이야기해보려 합니다.\n\n# 전산화 시대의 UX\n\n조금 과거로 돌아가보면, 전산화 시대는 컴퓨터가 등장하면서 시작됐습니다. 이 시기에는 컴퓨터가 단순히 계산을 수행하는 도구로 사용되었고, 사용자와의 상호작용은 주로 명령어 입력과 결과 출력으로 이루어졌습니다. 이때의 UX는 사용자가 명령어를 정확히 입력해야만 원하는 결과를 얻을 수 있었고, 이는 사용자에게 큰 부담이었습니다.\n\n시간이 지나 GUI[^1]가 등장하면서 사용자와의 상호작용 방식이 변화했습니다. 이 당시의 UX는 **사용자에게 원하는 것을 제공하기 위해 프로세스를 이해하고 따라가도록 요구**했습니다. 그러다보니 전체 프로세스가 어떻게 이뤄지는지, 사용자가 현재 어떤 프로세스에 위치하는지에 대해 정확히 알려줄 필요가 있었습니다. 예를 들어, 오늘날 사용자가 스마트폰 앱을 통해 음식 배달을 하기 위해선 1) 먹을 것을 검색하고, 2) 품목과 수량을 정하고, 3) 결제하는 절차를 사용자가 알아야 합니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/stepper-ux.png\" caption=\"프로세스 기반 UX\" />\n\n이렇게 GUI가 등장하고 계속된 실험과 통계로 사용자 경험은 크게 향상됐지만, 여전히 사용자는 어느정도 시스템의 동작 원리를 이해해야 했고 이는 서비스를 이용할 때 가장 부담스러운 요소입니다. 지금에와서는 많은 사용자들이 이러한 UX에 학습되어 있기에 **대부분의 서비스가 표준적인 GUI를 제공하는 방식으로 UX를 설계**[^2]합니다. 하지만 이러한 GUI에 익숙하지 않은 노인 세대 등 IT 취약 계층은 여전히 서비스 사용에 불편함을 느끼고 있습니다. 즉, **전산화 시대의 UX는 사용자에게 시스템의 동작 원리를 이해하도록 요구하는 UX**입니다.\n\n# 좋은 UX란 무엇인가?\n\n그럼에도 불구하고 서비스를 만드는 많은 사람들이 세대 불문하고 사용하기 편한 UX를 제공하기 위해 노력했습니다. 이를 위해 사용자가 원하는 것을 정확히 파악하려 노력하고 A/B 테스트나 사용자 행동 통계 분석 등 다양한 방법이 사용되었습니다.\n\n그 중에서도 토스는 UX로 굉장히 좋은 이야기를 많이 듣습니다. 개인적으로 토스가 제공하는 UX의 핵심은 **자연스럽게 경계를 허무는 것**에 있다고 생각합니다. 토스의 UX는 사용자가 큰 노력 없이 원하는 것을 얻을 수 있도록 **최소한의 복잡성만을 남기도록 절차를 통합**했습니다. 최적의 UX를 위해선 정말 수많은 케이스와 사용 사례를 접해야하고 이는 분명 많은 실험을 통해 구조적으로 도출된 결과[^3]입니다. 역설적으로 경계를 허물기 위해 구조적으로 접근하다니 정말 재밌는 일입니다. 이러한 관점에서 궁극적으로 좋은 UX란 무엇일까요?\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/toss.png\" caption=\"토스\" />\n\n현실 세계의 UX를 생각해봅시다. 우리는 맥도날드에서 메뉴를 주문할 때 직원에게 \"더블쿼터치즈버거 세트 하나 주세요\"라고 말합니다. 이때 우리는 직원이 어떤 메뉴를 제공하는지, 어떤 세트가 있는지, 가격은 얼마인지 등을 고려하지 않습니다. 단순히 \"더블쿼터치즈버거 세트\"라는 자연어로 대화합니다. 그리고 직원은 이를 이해하고 주문을 처리합니다.\n\n간혹 문제가 생길 수도 있습니다. 예를 들어, 주문한 메뉴가 품절인 경우에는 직원이 \"죄송하지만 더블쿼터치즈버거 세트는 품절입니다\"라고 말합니다. 이때 우리는 \"그럼 다른 메뉴로 바꿔주세요\"라고 대답합니다. 이 방식이 기존 **전산화 UX와 다른점은 사용자가 미리 상태를 인지하지 않아도 된다는 점**입니다. 그리고 이러한 과정에 절차의 경계는 명확하지 않지만 별도의 학습 없이도 어떤 상태인지를 확실히 인지할 수 있습니다. 따라서 **좋은 UX는 사용자가 큰 노력 없이 자신이 아는 지식만으로 이용할 수 있는 것**이라고 생각합니다.\n\n이를 기술적으로 해석해봅시다. 사람은 대화할 때 상대방의 말을 듣고 이해한 후, 자신의 생각을 말합니다. 이때 사람은 상대방이 어떤 말을 했는지, 어떤 의도를 가지고 있는지 등을 고려하여 대화를 진행합니다. 이를 기술적 관점에서 바라보면 결국 확률적으로 가장 좋은 답변을 선택하는 것에 가깝습니다. 하지만 지금까지는 기술적인 한계로 인해 이러한 UX를 제공하기 어려웠습니다.\n\n# MCP의 탄생과 새로운 UX\n\n지금은 이야기가 달라졌습니다. 본래 기계적인 것은 사람과 거리가 멀었지만, LLM 기반 AI가 나오면서 사람과 기계 간의 소통 방식이 변화했습니다. LLM은 자연어를 이해하고 생성할 수 있는 능력을 가지고 있어 사용자가 자연스럽게 기계와 소통할 수 있도록 도와줍니다.\n\n다만 LLM은 굉장히 광범위한 범위에서 대화를 진행하기 때문에 적절한 맥락을 제공할 필요가 있었습니다. 또한, 특정 데이터를 알기 위해서는 사용자가 명시적으로 프롬프트로 제공해야 했고, 앞서 예시로 설명한 음식 주문과 같은 기능을 실현할 수는 없었습니다.\n\n하지만 **MCP가 등장하고 나서는 LLM이 스스로 상황을 이해하고, 필요한 프로세스를 MCP 툴을 통해 진행**할 수 있게 되었습니다. 이로인해 기존 전통적인 전산화 UX의 경계는 완전히 허물어졌습니다. 사용자는 더 이상 시스템의 동작 원리를 이해할 필요가 없고, 단순히 자연어로 질문하면 됩니다. 예를 들어, \"만두 주문해줘\"라고 말하면 LLM이 자동으로 필요한 정보를 수집하고 주문을 진행할 수 있습니다. 이에 대한 시나리오를 간단하게 구현해봤을 때 다음과 같이 진행할 수 있었습니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/mcp-ux.png\" caption=\"MCP를 이용한 주문 배달 시나리오\" expandable />\n\n정말 대화하는 것처럼 자연스럽게 주문, 결제까지 진행할 수 있었습니다. 이때 사용자로서 전혀 시스템에 대한 이해가 필요하지 않았습니다. 사용자는 더 이상 복잡한 명령어를 입력하거나 프로세스를 이해할 필요 없이, 자연어로 질문하고 대답을 받을 수 있습니다. 즉, **사람과 시스템의 경계를 허물어버린 것**입니다.\n\n# 악용될 여지는?\n\n기존 UX에도 다크 패턴이 존재했습니다. 다크 패턴은 사용자가 실수로 잘못된 행동을 하도록 유도하여, 시스템이 원하는 방향으로 사용자를 이끌어가는 UX입니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/ux-dark-pattern.png\" caption=\"사용자의 실수를 유도하는 다크 패턴\" />\n\nMCP 기반 UX는 기존 전산화 UX보다 훨씬 자연스럽고 인간적인 상호작용을 제공합니다. 그러나 아이러니하게도, 이 자연스러움이 **악용되면 더 교묘한 UX 다크 패턴**으로 발전할 수도 있습니다. 예를 들어, 사용자가 \"저렴한 만두 추천해줘\"라고 말했을 때, LLM이 고의적으로 수수료가 높은 제휴 음식점을 추천할 수 있습니다. 이 경우 사용자는 시스템이 **중립적인 추천을 했다고 착각하지만**, 실제로는 시스템이 은밀하게 의도한 방향으로 행동을 유도받은 셈입니다.\n\n또한, 자연어 인터페이스에서는 선택지가 명시적으로 보이지 않기 때문에 사용자가 **다른 옵션의 존재 자체를 인식하지 못할 가능성**도 큽니다. 예전에는 'A와 B 중에서 선택하세요'라고 명확하게 보여주었다면, 이제는 시스템이 A만 말해주는 것이죠. 이처럼 **선택의 맥락을 숨기는 다크 패턴**이 등장할 수도 있습니다.\n\n# 마치며\n\n정리하자면 MCP는 기존 전산화 UX의 경계를 허물고, 사용자가 시스템과 자연스럽게 상호작용할 수 있는 새로운 UX를 제공합니다. 이는 사용자가 시스템의 동작 원리를 이해하지 않고도 원하는 작업을 수행할 수 있도록 도와줍니다. 하지만 이러한 변화는 긍정적인 면만 있는 것은 아닙니다. MCP 기반 UX는 다크 패턴을 더욱 교묘하게 만들 수 있는 가능성도 내포하고 있다고 생각합니다.\n\nMCP에 대해서는 아직도 많은 이야기가 오가고 있습니다. 앞으로 다른 방향으로 진화할 수도 있고, MCP 대신 다른 표준으로 대체될 수도 있습니다. 하지만 MCP는 기술적인 의의보다는 새로운 사용자 경험 표준에 대한 가능성을 보여주었다고 생각합니다.\n\n[^1]: Graphical User Interface\n[^2]: 제이콥의 법칙\n[^3]: 테슬러의 법칙\n","tableOfContents":{"items":[{"url":"#전산화-시대의-ux","title":"전산화 시대의 UX"},{"url":"#좋은-ux란-무엇인가","title":"좋은 UX란 무엇인가?"},{"url":"#mcp의-탄생과-새로운-ux","title":"MCP의 탄생과 새로운 UX"},{"url":"#악용될-여지는","title":"악용될 여지는?"},{"url":"#마치며","title":"마치며"}]},"excerpt":"항상 떠들썩한 IT 업계에서 최근 가장 뜨거운 화두는 단연코 MCP(Model Context Protocol)라고 할 수 있습니다. 이 MCP에 대해서는 놀랍다, 재밌다 같은 감상부터 생산성 증대, 새로운 방식의 툴링 등 긍정적인 의견과 그냥…","fields":{"slug":"/posts/mcp-from-ux-perspective","date":"2025-04-10"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","categories":"article","tags":["ai","mcp","ux"],"image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}}]}},"pageContext":{"slug":"/posts/mcp-from-ux-perspective","frontmatter":{"title":"UX 관점에서 바라보는 MCP","categories":"article","tags":["ai","mcp","ux"],"image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}