{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-05-02-modeling-series-measure-mdx","path":"/posts/modeling-series-measure/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n# 들어가며\n\n소프트웨어는 다양한 데이터를 다루는 복잡한 시스템이다. 이러한 데이터는 단순히 숫자나 문자열로 표현되는 것이 아니라, 그 자체로 의미를 가지며, 이를 잘 이해하고 활용하는 것이 소프트웨어 개발의 핵심이다. 이번 글에서는 이러한 데이터의 양이나 크기를 정량적으로 표현하는 방법인 측도(Measure)에 대해 알아보겠다.\n\n먼저 측도라는 단어가 생소하게 느껴질 수 있다. 측도는 데이터의 양이나 크기를 정량적으로 표현하는 방법을 말한다. 수학적으로는 개수, 길이, 넓이, 부피 등의 개념을 추상화한 것을 말한다. 예를 들어, 마리, 권, 그루, 다스와 같은 수량 개념부터 cm, kg, mL와 같은 단위, 달러나 엔과 같은 화폐까지 모두 측도의 일종이다. 좀 더 나아간다면 바퀴, 번과 같은 횟수 개념도 측도로 볼 수 있다. \n\n이러한 측도는 비즈니스 관점에서 중요하다. 물건을 판매한다면 가격과 수량을 표현해야 하고, 글로벌 서비스를 한다면 다양한 화폐 단위를 다룰 수 있어야 한다. 또한, 단위 변환과 연산에 대한 고려도 필요하다. 예를 들어, 미국에서 판매되는 제품의 가격을 한국 원화로 변환해야 하거나, 세금이나 수수료 등을 고려하여 계산해줄 수도 있다.\n\n이번 글에서는 측도 개념을 어떻게 모델링할 수 있는지에 대해 알아보겠다.\n\n# 추상화된 것을 구체화하기\n\n우리는 숫자를 코드로 표현하고 싶을 때 `Int`나 `Float`와 같은 기본 자료형을 사용한다. 하지만 이러한 기본 자료형은 단순히 숫자일 뿐, 그 자체로 의미를 가지지 않는다. 예를 들어, `100`이라는 숫자는 단순한 정수일 뿐이라 무게인지 길이인지 알 수 없다. 그래서 보통 다음과 같이 변수명에 의존하여 의미를 부여한다.\n\n```kotlin\nval weight: Int = 100 // 무게\nval length: Int = 100 // 길이\n```\n\n하지만 이러한 방식은 실수할 여지가 많다. `Int`라는 타입은 아무 숫자나 받을 수 있기 때문에, 잘못된 값을 넣을 수도 있다. 이를 방지하기 위해서 코드 리뷰나 테스트를 통해 확인할 수 있지만, 이런 단순한 문제로 생산성을 떨어뜨리는 것은 바람직하지 않다. 따라서 실수를 방지하기 위해 별도 타입을 만들 수 있다. 예를 들어, 무게를 표현하기 위해 `Weight`라는 클래스를 만들고, 이를 사용하여 무게를 표현할 수 있다.\n\n```kotlin\nclass Weight(val value: Int) {\n  init {\n    require(value >= 0) { \"Weight must be positive\" }\n  }\n}\nval weight = Weight(100) // 무게\n```\n\n위와 같이 `Weight`라는 클래스를 만들면, 무게를 표현할 때는 항상 `Weight` 타입을 사용해야 하므로 실수를 방지할 수 있다. 또한, 클래스에 다양한 연산을 추가하여 무게에 대한 연산을 쉽게 수행할 수 있다.\n\n```kotlin\nclass Weight(val value: Int) {\n  init {\n    require(value >= 0) { \"Weight must be positive\" }\n  }\n\n  operator fun plus(other: Weight): Weight {\n    return Weight(value + other.value)\n  }\n\n  operator fun minus(other: Weight): Weight {\n    return Weight(value - other.value)\n  }\n\n  operator fun times(scalar: Int): Weight {\n    return Weight(value * scalar)\n  }\n\n  operator fun div(scalar: Int): Weight {\n    return Weight(value / scalar)\n  }\n}\nval weight1 = Weight(100)\nval weight2 = Weight(200)\nval totalWeight = weight1 + weight2 // 300\nval halfWeight = weight1 / 2 // 50\n```\n\n이러한 객체를 DDD(도메인 주도 설계)에서는 **값 객체(Value Object)**라고 부른다. 값 객체는 불변성을 가지며, 그 자체로 의미를 가지는 객체이다. 즉, 값 객체는 단순히 숫자나 문자열을 감싸는 것이 아니라, 그 자체로 의미를 가지는 객체이다. 따라서 값 객체를 사용하면 코드의 가독성을 높이고, 실수를 방지할 수 있다.\n\n측도에 대한 모델링은 이런 개념에서 시작된다. 추상화된 값을 구체화하여 의미를 부여하고, 이를 통해 코드의 가독성을 높이고 실수를 방지하며, 비즈니스에 필요한 다양한 연산을 추가할 수 있다.\n\n# 측도 모델링\n\n앞서 구현한 값 객체를 이용할 수도 있지만, 조금 더 범용적으로 모델을 만드는 것도 가능하다. 단순히 무게나 길이와 같은 개별 타입을 만드는 것이 아니라, 모든 측도에 공통으로 적용할 수 있는 추상화된 모델을 구현해보자.\n\n## 값과 단위\n\n측도 시스템을 구현할 때 가장 기본이 되는 것은 '값(Value)'과 '단위(Unit)'의 개념이다. 모든 측도는 값과 단위의 조합으로 표현할 수 있다. 예를 들어 \"5kg\"는 값이 5이고 단위가 킬로그램인 측도이다.\n\n그리고 단위는 연관성이 있는 단위들끼리 변환이 가능하다. 예를 들어 킬로그램(kg)과 그램(g)은 서로 변환이 가능하다. 이러한 단위 간의 변환을 지원하기 위해서는 별도로 단위계를 정의할 수 있어야 한다. 이와 같은 요구사항을 기반으로 다음과 같이 다이어그램을 그려볼 수 있다.\n\n<Image src=\"/images/2025-05-02-modeling-series-measure/measure-diagram.png\" maxWidth=\"340px\" />\n\n우리는 전체 측도 모델에 대한 기본 구조를 위와 같이 정의할 것이다. `Measure`는 모든 측도를 표현하는 모델이며, `Unit`은 단위를 표현하는 모델이다. 그리고 `UnitSystem`은 특정 종류의 측도에 사용할 수 있는 모든 단위들의 집합을 관리하는 시스템이다. 이 구조를 기반으로 측도 모델을 구현해보자.\n\n```kotlin\ninterface Measure<T : Measure<T>> : Comparable<T> {\n  val value: BigDecimal\n  val unit: MeasurementUnit<T>\n  \n  fun convertTo(targetUnit: MeasurementUnit<T>): T\n  fun add(other: T): T\n  fun subtract(other: T): T\n  fun multiply(factor: BigDecimal): T\n  fun divide(divisor: BigDecimal): T\n}\n```\n\n위 코드에서 `Measure` 인터페이스는 `T`라는 제네릭 타입을 사용하며, 이는 자기 자신의 타입을 참조한다. 이러한 설계는 F-bounded polymorphism 패턴으로, 자기 자신의 타입을 참조하여 타입 안전성을 보장한다. 예를 들어 `Weight`라는 클래스가 `Measure<Weight>`를 구현한다면, `add` 메서드는 `Weight` 타입만 받을 수 있다.\n\n또한 모든 측도는 `Comparable`을 구현하여 비교 가능하도록 했다. 예를 들어 \"5kg\"과 \"3kg\"를 비교하여 어느 것이 더 무거운지 판단할 수 있다.\n\n다음으로 단위를 표현하는 인터페이스를 살펴보자.\n\n```kotlin\ninterface Unit<T : Measure<T>> {\n  val symbol: String\n  val name: String\n  \n  fun convert(value: BigDecimal, toUnit: Unit<T>): BigDecimal\n  fun create(value: BigDecimal): T\n}\n```\n\n`Unit` 인터페이스는 단위의 기호(symbol)와 이름(name)을 가지며, 단위 간 변환(convert)과 새로운 측도 생성(create) 기능을 제공한다. 예를 들어 킬로그램(kg)에서 파운드(lb)로 변환하거나, 5kg의 새로운 무게 객체를 생성할 수 있다.\n\n마지막으로, 특정 종류의 측도에 사용할 수 있는 모든 단위들의 집합을 관리하는 시스템 인터페이스를 정의한다.\n\n```kotlin\ninterface UnitSystem<T : Measure<T>> {\n  val baseUnit: MeasurementUnit<T>\n  val availableUnits: Set<MeasurementUnit<T>>\n  \n  fun getUnitBySymbol(symbol: String): MeasurementUnit<T>?\n  fun getUnitByName(name: String): MeasurementUnit<T>?\n}\n```\n\n`UnitSystem`은 모든 변환의 기준이 되는 기본 단위(baseUnit)와 사용 가능한 모든 단위들(availableUnits)을 관리한다. 또한 기호나 이름으로 단위를 찾는 메서드도 제공한다.\n\n위에서 정의한 인터페이스를 기반으로 추상 클래스를 구현해보자. 추상 클래스는 인터페이스의 공통 기능을 구현하여 중복 코드를 줄이고, 향후 구현할 구체적인 측도 클래스에서 필요한 기능만 구현할 수 있도록 한다.\n\n```kotlin\nabstract class AbstractMeasure<T : Measure<T>>(\n  override val value: BigDecimal,\n  override val unit: MeasurementUnit<T>\n) : Measure<T> {\n  override fun convertTo(targetUnit: MeasurementUnit<T>): T {\n      if (unit == targetUnit) {\n          @Suppress(\"UNCHECKED_CAST\")\n          return this as T\n      }\n      \n      val convertedValue = unit.convert(value, targetUnit)\n      return targetUnit.create(convertedValue)\n  }\n\n  override fun compareTo(other: T): Int {\n      val baseValue = unit.convert(value, getUnitSystem().baseUnit)\n      val otherBaseValue = other.unit.convert(other.value, getUnitSystem().baseUnit)\n      return baseValue.compareTo(otherBaseValue)\n  }\n  \n  // 다른 연산 메서드들...\n  \n  abstract fun getUnitSystem(): UnitSystem<T>\n}\n```\n\n`AbstractMeasure` 클래스는 `convertTo` 메서드를 구현하여 다른 단위로 변환할 수 있게 하고, `compareTo` 메서드를 구현하여 서로 다른 단위의 측도도 비교할 수 있게 한다. 예를 들어 kg과 lb 단위의 무게를 비교할 수 있다.\n\n## 수량\n\n이제 측도의 값과 단위에 대한 기본 인터페이스를 정의했으니, 이를 활용하여 실제로 수량(Quantity)을 어떻게 표현할 수 있는지 알아볼 것이다.\n\n측도 모델에 기반한 수량 모델은 값과 단위의 개념을 기반으로, 실제 세계의 다양한 측정값을 프로그래밍적으로 표현할 수 있게 해준다. 보통 이러한 수량 모델은 변환에 있어 공식이 정해져 있는 물리적 수량(개수, 무게, 길이, 부피 등)에 사용된다.\n\n수량을 구현하기 위해 `Measure` 인터페이스를 구현하는 추상 클래스인 `Quantity`를 먼저 살펴보자. 이 클래스는 모든 종류의 물리적 수량(무게, 길이, 부피 등)의 공통 기능을 제공한다.\n\n```kotlin\nabstract class Quantity<T : Measure<T>>(\n  override val value: BigDecimal,\n  override val unit: Unit<T>\n) : AbstractMeasure<T>(value, unit) {\n  // 포맷팅을 위한 메서드\n  fun format(precision: Int = 2): String {\n    val roundedValue = value.setScale(precision, RoundingMode.HALF_UP)\n    return \"$roundedValue ${unit.symbol}\"\n  }\n  \n  // toString 재정의\n  override fun toString(): String = \"${value} ${unit.symbol}\"\n  \n  // 동등성 비교\n  override fun equals(other: Any?): Boolean {\n    if (this === other) return true\n    if (other !is Measure<*>) return false\n    \n    @Suppress(\"UNCHECKED_CAST\")\n    other as T\n    \n    return try {\n      compareTo(other) == 0\n    } catch (e: ClassCastException) {\n      false\n    }\n  }\n    \n  // 해시코드 생성\n  override fun hashCode(): Int {\n    val baseValue = unit.convert(value, getUnitSystem().baseUnit)\n    return baseValue.hashCode()\n  }\n}\n```\n\n이제 이 추상 클래스를 바탕으로 구체적인 수량 타입들을 구현할 수 있다. 여기서는 무게(Weight)를 예로 들어보자.\n\n```kotlin\nclass Weight private constructor(\n  value: BigDecimal,\n  unit: WeightUnit\n) : Quantity<Weight>(value, unit) {\n  companion object {\n    // 팩토리 메서드: 기본 생성\n    fun of(value: BigDecimal, unit: WeightUnit): Weight = Weight(value, unit)\n    fun of(value: Double, unit: WeightUnit): Weight = of(BigDecimal.valueOf(value), unit)\n    fun of(value: Int, unit: WeightUnit): Weight = of(BigDecimal.valueOf(value.toLong()), unit)\n    \n    // 편의 메서드: 특정 단위로 생성\n    fun kilograms(value: Double): Weight = of(value, WeightSystem.KILOGRAM)\n    fun grams(value: Double): Weight = of(value, WeightSystem.GRAM)\n    fun pounds(value: Double): Weight = of(value, WeightSystem.POUND)\n    fun ounces(value: Double): Weight = of(value, WeightSystem.OUNCE)\n  }\n  \n  override fun getUnitSystem(): UnitSystem<Weight> = WeightSystem\n}\n```\n\n앞서 정의한 `Quantity` 클래스를 상속받아 `Weight` 클래스를 구현했다. 이후 편의를 위해 팩토리 메서드를 구현해 다양한 단위로 무게를 생성할 수 있도록 했다. 예를 들어 `Weight.kilograms(5.0)`은 5kg의 무게 객체를 생성한다.\n\n이어서 무게 단위를 정의하는 `WeightUnit` 클래스를 구현해보자.\n\n```kotlin\nclass WeightUnit(\n  override val symbol: String,\n  override val name: String,\n  private val conversionFactor: BigDecimal // 기본 단위(kg)에 대한 변환 계수\n) : Unit<Weight> {\n  override fun convert(value: BigDecimal, toUnit: Unit<Weight>): BigDecimal {\n    return value.multiply(conversionFactor).divide(toUnit.conversionFactor)\n  }\n\n  override fun create(value: BigDecimal): Weight {\n    return Weight(value, this)\n  }\n}\n```\n\n여기서 `conversionFactor`는 해당 단위를 기본 단위(킬로그램)로 변환할 때 곱하는 계수이다. 예를 들어 그램은 킬로그램의 1/1000이므로, 그램의 conversionFactor는 0.001이 된다.\n\n마지막으로 무게 단위계를 구현해보자.\n\n```kotlin\nobject WeightSystem : UnitSystem<Weight> {\n  val KILOGRAM = WeightUnit(\"kg\", \"Kilogram\", BigDecimal.ONE)\n  val GRAM = WeightUnit(\"g\", \"Gram\", BigDecimal(0.001))\n  val MILLIGRAM = WeightUnit(\"mg\", \"Milligram\", BigDecimal(0.000001))\n  val TON = WeightUnit(\"t\", \"Ton\", BigDecimal(1000))\n  val POUND = WeightUnit(\"lb\", \"Pound\", BigDecimal(0.45359237))\n  val OUNCE = WeightUnit(\"oz\", \"OUNCE\", BigDecimal(0.028349523125))\n\n  override val baseUnit: Unit<Weight> = KILOGRAM\n  override val availableUnits: Set<Unit<Weight>> = setOf(KILOGRAM, GRAM, POUND, OUNCE)\n\n  override fun getUnitBySymbol(symbol: String): Unit<Weight>? {\n    return availableUnits.find { it.symbol == symbol }\n  }\n\n  override fun getUnitByName(name: String): Unit<Weight>? {\n    return availableUnits.find { it.name == name }\n  }\n}\n```\n\n`WeightSystem`은 싱글톤 객체로 구현해서 애플리케이션 전체에서 단 하나의 인스턴스만 존재하도록 만들었다. 이를 통해 단위 정의의 일관성을 보장하고 메모리 사용을 최적화할 수 있다. 이제 이를 사용한 예제 코드를 살펴보자.\n\n```kotlin\n// 무게 생성\nval weight1 = Weight.kilograms(75.5)\nval weight2 = Weight.pounds(150.0)\n\n// 단위 변환\nval weight2InKg = weight2.convertTo(WeightSystem.KILOGRAM)\nprintln(\"150 pounds = ${weight2InKg}\") // \"150 pounds = 68.0388555 kg\"\n\n// 무게 덧셈\nval totalWeight = weight1.add(weight2)\nprintln(\"Total weight: $totalWeight\") // \"Total weight: 143.5388555 kg\"\n\n// 무게 비교\nval isHeavier = weight1 > weight2\nprintln(\"Is 75.5 kg heavier than 150 pounds? $isHeavier\") // true\n```\n\n이와 같은 방식으로 무게 외에도 다양한 측도를 구현할 수 있다. 예를 들어 거리를 표현하는 `Distance` 클래스, 부피를 표현하는 `Volume` 클래스 등을 구현할 수 있다. 각 클래스는 `Measure` 인터페이스를 구현하고, 단위와 단위계도 각각 정의하면 된다.\n\n각 수량 타입은 고유한 단위 시스템과 단위 간 변환 규칙을 가지지만, 기본적인 구조와 연산 방식은 동일하게 유지된다. 이는 객체지향 설계의 다형성과 상속을 잘 활용한 예시이다.\n\n## 화폐\n\n앞서 구현한 수량 모델으로 해결할 수 없는 단위도 있다. 그 중 하나가 화폐이다. 화폐는 단순히 수량과 단위의 조합인 동시에, 환율이라는 특수한 변환 관계를 가지고 있다. 또한 비즈니스 애플리케이션에서 가장 많이 사용되는 측도 중 하나이다. 이번에는 앞서 구현한 측도 시스템을 바탕으로 화폐를 어떻게 모델링할 수 있는지 살펴보자.\n\n먼저 화폐는 일반적인 물리적 수량과 달리 몇 가지 고유한 특성을 가지고 있다.\n\n* **다양한 통화 지원**<br />글로벌 서비스를 제공하는 애플리케이션은 여러 통화를 지원해야 한다.\n* **특별한 포맷팅 요구사항**<br />화폐는 통화 기호(₩, $, €)와 함께 표시되며, 국가나 지역에 따라 다른 표기법을 사용한다.\n* **정밀한 계산 필요성**<br />금융 계산은 반올림 오차에 매우 민감하므로, 정확한 계산 로직이 필요하다.\n* **변동성 있는 변환 관계**<br />킬로그램과 파운드의 변환 관계는 항상 고정되어 있지만, 달러와 유로의 환율은 시시각각 변한다.\n\n이러한 특성을 반영하여 화폐를 모델링할 때는 다음과 같은 요소를 고려해야 한다.\n\n* **화폐 단위**: 각 통화의 단위를 정의한다. 예를 들어, 원화(KRW), 달러(USD), 유로(EUR) 등이 있다.\n* **환율**: 각 통화 간의 변환 관계를 정의한다. 이는 고정된 값이 아니라, 외부 API를 통해 실시간으로 가져올 수 있다.\n* **화폐 포맷팅**: 각 통화에 맞는 포맷팅 규칙을 정의한다. 예를 들어, 원화는 \"₩1,000\"과 같이 표시하고, 달러는 \"$1,000.00\"과 같이 표시한다.\n* **정밀도**: 화폐는 소수점 이하의 자릿수가 중요하므로, 이를 고려한 정밀한 계산이 필요하다.\n\n이를 고려하여 화폐 모델을 구현해보자. 먼저 화폐를 표현하는 `Money` 클래스를 정의해보자.\n\n```kotlin\nclass Money private constructor(\n  value: BigDecimal,\n  unit: CurrencyUnit\n) : AbstractMeasure<Money>(value, unit) {\n  companion object {\n    // 팩토리 메서드\n    fun of(value: BigDecimal, currency: CurrencyUnit): Money = Money(value, currency)\n    fun of(value: Double, currency: CurrencyUnit): Money = of(BigDecimal.valueOf(value), currency)\n    fun of(value: Int, currency: CurrencyUnit): Money = of(BigDecimal.valueOf(value.toLong()), currency)\n    \n    // 주요 통화별 편의 메서드\n    fun usd(value: Double): Money = of(value, CurrencySystem.USD)\n    fun eur(value: Double): Money = of(value, CurrencySystem.EUR)\n    fun jpy(value: Double): Money = of(value, CurrencySystem.JPY)\n    fun krw(value: Double): Money = of(value, CurrencySystem.KRW)\n  }\n  \n  // 통화 단위에 더 직관적으로 접근하기 위한 속성\n  val currency: CurrencyUnit\n    get() = unit as CurrencyUnit\n  \n  // 화폐 포맷팅\n  fun format(locale: Locale = Locale.getDefault()): String {\n    val formatter = NumberFormat.getCurrencyInstance(locale).apply {\n      currency = java.util.Currency.getInstance(this@Money.currency.code)\n    }\n    return formatter.format(value)\n  }\n  \n  // 간단한 포맷팅\n  fun formatSimple(): String = \"${currency.symbol}$value\"\n  \n  override fun getUnitSystem(): UnitSystem<Money> = CurrencySystem\n  \n  // 화폐 연산에 특화된 메서드들\n  fun percentage(percent: Double): Money {\n    val factor = BigDecimal.valueOf(percent).divide(BigDecimal(\"100\"), 10, RoundingMode.HALF_UP)\n    return multiply(factor)\n  }\n  \n  fun addPercentage(percent: Double): Money {\n    val factor = BigDecimal.ONE.add(BigDecimal.valueOf(percent).divide(BigDecimal(\"100\"), 10, RoundingMode.HALF_UP))\n    return multiply(factor)\n  }\n}\n```\n\n`Money` 클래스를 구현하며 기본적인 측도 기능을 상속받으면서 화폐에 특화된 기능을 추가했다. 먼저 `currency` 필드를 통해 확장된 `Unit` 타입인 `CurrencyUnit`에 접근할 수 있도록 했다. 그리고 `format` 메서드를 통해 지역화된 화폐 포맷팅을 지원하며, 세금이나 할인율과 같은 퍼센트 기반 연산을 쉽게 수행할 수 있는 메서드를 제공했다.\n\n다음으로 화폐 단위를 정의하는 `CurrencyUnit` 클래스를 구현해보자.\n\n```kotlin\nclass CurrencyUnit(\n  override val symbol: String,\n  override val name: String,\n  val code: String, // ISO 통화 코드 (예: USD, EUR)\n  var exchangeRate: BigDecimal // 기준 통화(예: USD)에 대한 환율, 변할 수 있음\n) : Unit<Money> {\n  override fun convert(value: BigDecimal, toUnit: Unit<Money>): BigDecimal {\n    toUnit as CurrencyUnit\n    \n    // 기본 통화로 변환 후 대상 통화로 변환\n    val valueInBaseUnit = value.divide(exchangeRate, 10, RoundingMode.HALF_UP)\n    return valueInBaseUnit.multiply(toUnit.exchangeRate)\n  }\n  \n  override fun create(value: BigDecimal): Money = Money.of(value, this)\n}\n```\n\n`CurrencyUnit`은 일반적인 단위 정보(기호, 이름) 외에도 ISO 통화 코드와 환율을 추가로 저장한다. 그리고 `convert` 메서드에서는 일반적인 물리적 단위와 달리, 직접적인 변환이 아닌 USD와 같은 기준 통화를 경유한 변환을 수행한다. 이는 금융 시스템에서 일반적으로 사용되는 방식으로, 모든 통화 쌍에 대한 환율을 개별적으로 관리하지 않고, 기준 통화에 대한 환율만 관리하는 방식이다.\n\n마지막으로 통화 단위들을 관리하는 `CurrencySystem`을 구현해보자.\n\n```kotlin\nobject CurrencySystem : AbstractUnitSystem<Money>() {\n  // 주요 통화 정의\n  val USD = CurrencyUnit(\"$\", \"US Dollar\", \"USD\", BigDecimal.ONE)\n  val EUR = CurrencyUnit(\"€\", \"Euro\", \"EUR\", BigDecimal(\"1.09\"))\n  val GBP = CurrencyUnit(\"£\", \"British Pound\", \"GBP\", BigDecimal(\"1.27\"))\n  val JPY = CurrencyUnit(\"¥\", \"Japanese Yen\", \"JPY\", BigDecimal(\"0.0067\"))\n  val KRW = CurrencyUnit(\"₩\", \"Korean Won\", \"KRW\", BigDecimal(\"0.00074\"))\n  \n  override val baseUnit: Unit<Money> = USD  // 기준 통화: USD\n  \n  override val availableUnits: Set<Unit<Money>> = setOf(\n    USD, EUR, GBP, JPY, KRW\n  )\n  \n  // 통화 코드로 통화 단위 찾기\n  fun getUnitByCode(code: String): CurrencyUnit? {\n    return availableUnits.find { \n      (it as CurrencyUnit).code.equals(code, ignoreCase = true)\n    } as CurrencyUnit?\n  }\n  \n  // 환율 업데이트\n  fun updateExchangeRate(currencyCode: String, newRate: BigDecimal) {\n    val currency = getUnitByCode(currencyCode) ?: \n      throw IllegalArgumentException(\"Unknown currency code: $currencyCode\")\n        \n    currency.exchangeRate = newRate\n  }\n}\n```\n\n`CurrencySystem`은 주요 통화들을 정의하고, 기준 통화와 사용 가능한 통화 단위들을 관리한다. 또한 통화 코드로 단위를 찾는 메서드와 환율을 업데이트하는 메서드를 제공한다.  여기서는 단순화를 위해 환율 정보를 하드코딩된 값으로 사용했지만, 실제 애플리케이션에서는 외부 API를 통해 실시간으로 가져와서 최신 환율을 반영해야 한다. 예를 들어, [Open Exchange Rates](https://openexchangerates.org/)와 같은 서비스를 사용하여 환율 정보를 가져올 수 있다. 여기서 환율 정보를 가져오는 구현은 생략한다.\n\n이제 `Money` 클래스를 사용하여 화폐를 표현하고, 다양한 연산을 수행할 수 있다. 예를 들어, 다음과 같이 화폐 객체를 생성하고 연산을 수행할 수 있다.\n\n```kotlin\n// 화폐 생성\nval usd100 = Money.usd(100.0)\nval eur50 = Money.eur(50.0)\n\n// 간단한 포맷팅\nprintln(\"USD amount: ${usd100.formatSimple()}\")  // \"USD amount: $100.0\"\n\n// 지역화된 포맷팅\nprintln(\"EUR amount in US format: ${eur50.format(Locale.US)}\")  // \"EUR amount in US format: €50.00\"\nprintln(\"EUR amount in German format: ${eur50.format(Locale.GERMANY)}\")  // \"EUR amount in German format: 50,00 €\"\n\n// 통화 변환\nval eurToUsd = eur50.convertTo(CurrencySystem.USD)\nprintln(\"50 EUR = ${eurToUsd.formatSimple()}\")  // \"50 EUR = $54.5\"\n\n// 화폐 연산\nval total = usd100.add(eur50.convertTo(CurrencySystem.USD))\nprintln(\"Total: ${total.formatSimple()}\")  // \"Total: $154.5\"\n\n// 퍼센트 계산 (세금, 할인 등)\nval tax = usd100.percentage(8.0)  // 8% 세금\nprintln(\"8% tax on $100: ${tax.formatSimple()}\")  // \"8% tax on $100: $8.0\"\n\nval withTax = usd100.addPercentage(8.0)  // 세금 포함 금액\nprintln(\"$100 with 8% tax: ${withTax.formatSimple()}\")  // \"$100 with 8% tax: $108.0\"\n```\n\n이런 방식을 통해 수량 모델과는 다르게, 화폐라는 특수한 모델에 대해서도 대응이 가능하다. 보통 특수한 측도는 다음과 같은 특성을 가진다.\n\n* 비선형 변환: 단순한 곱셈/나눗셈이 아닌 복잡한 변환 공식이 필요하다.\n* 특별한 의미론: 덧셈, 뺄셈 등 연산의 의미가 일반 측도와 다를 수 있다.\n* 도메인 특화 로직: 각 도메인에 특화된 추가 기능이 필요하다.\n* 문화적/지역적 차이: 같은 측도도 문화권이나 지역에 따라 다른 표현 방식을 가질 수 있다.\n\n화폐 외에도 데이터 크기(KB, MB, GB 등), 시간, 온도, 주파수 등은 일반적인 물리적 수량과는 다른 변환 관계나 연산을 가지므로, 수량 모델이 아닌 별도의 모델이 필요하다.\n\n# 수학적 측도\n\n앞서 다룬 일상적인 단위 외에 수학적 측도는 물리적 수량과는 다른 개념으로, 비율(Ratio)이나 각도(Angle), 지수(Exponent) 등과 같은 수학적 개념을 표현하는 데 사용된다.\n\n수학적 측도는 기존 측도를 이용하여 연산 후 결과를 표현하는 데 사용된다. 예를 들어, 비율은 두 수량 간의 관계를 나타내며, 각도는 회전이나 기울기를 나타낸다. 이러한 측도는 일반적으로 물리적 수량과는 다른 연산 규칙을 가지므로, 별도의 모델로 구현하는 것이 좋다.\n\n먼저 비율을 살펴보자. 비율은 두 수량 간의 관계를 나타내는 값으로, 일반적으로 분수 형태로 표현된다. 이를 표현할 수 있는 `Ratio`를 구현해보자.\n\n```kotlin\nclass RatioUnit(\n    override val symbol: String,\n    override val name: String,\n    val conversionFactor: BigDecimal  // 십진수(decimal) 기준 변환 계수\n) : Unit<Ratio> {\n  override fun convert(value: BigDecimal, toUnit: Unit<Ratio>): BigDecimal {\n    toUnit as RatioUnit\n    \n    // 기본 단위(십진수)로 변환 후 목표 단위로 변환\n    val valueInDecimal = value.multiply(conversionFactor)\n    return valueInDecimal.divide(toUnit.conversionFactor, 10, RoundingMode.HALF_UP)\n  }\n  \n  override fun create(value: BigDecimal): Ratio = Ratio.of(value, this)\n}\n\nclass Ratio private constructor(\n  value: BigDecimal,\n  unit: RatioUnit\n) : AbstractMeasure<Ratio>(value, unit) {\n  companion object {\n    fun of(value: BigDecimal, unit: RatioUnit): Ratio = Ratio(value, unit)\n    fun of(value: Double, unit: RatioUnit): Ratio = of(BigDecimal.valueOf(value), unit)\n    \n    // 편의 메서드\n    fun decimal(value: Double): Ratio = of(value, RatioSystem.DECIMAL)\n    fun percentage(value: Double): Ratio = of(value, RatioSystem.PERCENTAGE)\n    fun permille(value: Double): Ratio = of(value, RatioSystem.PERMILLE)\n    fun fraction(numerator: Int, denominator: Int): Ratio {\n        val value = BigDecimal.valueOf(numerator.toLong())\n            .divide(BigDecimal.valueOf(denominator.toLong()), 10, RoundingMode.HALF_UP)\n        return decimal(value.toDouble())\n    }\n  }\n    \n  override fun getUnitSystem(): UnitSystem<Ratio> = RatioSystem\n  \n  // 편의 변환 메서드\n  fun toPercentage(): Ratio = convertTo(RatioSystem.PERCENTAGE)\n  fun toDecimal(): Ratio = convertTo(RatioSystem.DECIMAL)\n  \n  // 두 측도의 비율 계산을 위한 정적 메서드\n  companion object {\n    fun <T : Measure<T>> between(value1: T, value2: T): Ratio {\n      if (value1.unit != value2.unit) {\n        throw IllegalArgumentException(\"Cannot compute ratio between different units without conversion\")\n      }\n      \n      val ratio = value1.value.divide(value2.value, 10, RoundingMode.HALF_UP)\n      return decimal(ratio.toDouble())\n    }\n    \n    // 측도의 변화율 계산\n    fun <T : Measure<T>> changeRate(oldValue: T, newValue: T): Ratio {\n      val convertedNew = if (oldValue.unit != newValue.unit) {\n        newValue.convertTo(oldValue.unit as Unit<T>)\n      } else {\n        newValue\n      }\n      \n      val change = convertedNew.value.subtract(oldValue.value)\n      val rate = change.divide(oldValue.value, 10, RoundingMode.HALF_UP)\n      \n      return decimal(rate.toDouble())\n    }\n  }\n  \n  // 비율 연산\n  fun add(other: Ratio): Ratio {\n    val convertedOther = other.convertTo(unit as RatioUnit)\n    val sum = value.add(convertedOther.value)\n    return Ratio.of(sum, unit as RatioUnit)\n  }\n  \n  operator fun plus(other: Ratio): Ratio = add(other)\n  \n  // 측도에 비율 적용\n  fun <T : Measure<T>> applyTo(measure: T): T {\n    val decimalRatio = this.convertTo(RatioSystem.DECIMAL)\n    return measure.multiply(decimalRatio.value)\n  }\n  \n  // 증가율 적용 (1 + rate)\n  fun <T : Measure<T>> increase(measure: T): T {\n    val decimalRatio = this.convertTo(RatioSystem.DECIMAL)\n    val factor = BigDecimal.ONE.add(decimalRatio.value)\n    return measure.multiply(factor)\n  }\n}\n\nobject RatioSystem : AbstractUnitSystem<Ratio>() {\n  val DECIMAL = RatioUnit(\"\", \"decimal\", BigDecimal.ONE)\n  val PERCENTAGE = RatioUnit(\"%\", \"percentage\", BigDecimal(\"0.01\"))\n  val PERMILLE = RatioUnit(\"‰\", \"permille\", BigDecimal(\"0.001\"))\n  val BASIS_POINT = RatioUnit(\"bp\", \"basis point\", BigDecimal(\"0.0001\"))\n  \n  override val baseUnit: Unit<Ratio> = DECIMAL\n  \n  override val availableUnits: Set<Unit<Ratio>> = setOf(\n    DECIMAL, PERCENTAGE, PERMILLE, BASIS_POINT\n  )\n}\n```\n\n위와 같이 `Ratio`를 구현하면, 두 수량 간의 비율을 쉽게 계산할 수 있다. 예를 들어, 두 무게 간의 비율을 계산할 때는 다음과 같이 사용할 수 있다.\n\n```kotlin\nval weight1 = Weight.kilograms(50.0)\nval weight2 = Weight.kilograms(25.0)\nval ratio = Ratio.between(weight1, weight2)\nprintln(\"Ratio of weight1 to weight2: ${ratio}\")  // \"Ratio of weight1 to weight2: 2.0\"\n```\n\n혹은 이자와 같은 금융 비율을 계산할 때도 사용할 수 있다.\n\n```kotlin\nval interestRate = Ratio.percentage(5.0)  // 5%\nval principal = Money.usd(1000.0)\nval interest = interestRate.applyTo(principal)\nprintln(\"Interest on $1000 at 5%: ${interest.formatSimple()}\")  // \"Interest on $1000 at 5%: $50.0\"\n```\n\n이렇게 수학적 측도를 구현하면, 다양한 수량 간의 관계를 표현하고 계산할 수 있다. 외에도 다양한 수학적 측도를 구현할 수 있으며, 각 측도에 맞는 단위와 변환 규칙을 정의하면 된다.\n\n# 복합 측도와 파생 측도\n\n앞서 살펴본 기본 측도(수량)와 특수 측도(화폐 등)를 넘어, 현실 세계에서는 여러 측도가 결합되거나 파생되는 경우가 많다. 이러한 복합 측도와 파생 측도를 모델링하는 방법을 알아보자.\n\n## 복합 측도\n\n복합 측도는 두 개 이상의 기본 측도가 결합된 형태를 말한다. 예를 들어 속도는 거리와 시간의 비율(km/h)로, 밀도는 질량과 부피의 비율(kg/m³)로 표현된다.\n\n복합 측도를 모델링할 때는 기존 측도를 조합하여 새로운 측도를 생성하는 방식으로 구현할 수 있다. 예를 들어 속도를 표현하는 `Velocity`를 구현해보자.\n\n먼저 속도에 대한 단위를 정의하는 `VelocityUnit` 클래스를 구현한다. 이 클래스는 거리 단위와 시간 단위를 조합하여 속도를 표현한다.\n\n```kotlin\nclass VelocityUnit(\n  override val symbol: String,\n  override val name: String,\n  // 거리 단위와 시간 단위를 조합\n  val distanceUnit: Unit<Distance>,\n  val timeUnit: Unit<Time>\n) : AbstractUnit<Velocity>() {\n  override fun convert(value: BigDecimal, toUnit: Unit<Velocity>): BigDecimal {\n    toUnit as VelocityUnit\n    \n    // 거리 단위 변환 계수\n    val distanceFactor = distanceUnit.convert(\n      BigDecimal.ONE, \n      toUnit.distanceUnit\n    )\n    \n    // 시간 단위 변환 계수\n    val timeFactor = timeUnit.convert(\n      BigDecimal.ONE,\n      toUnit.timeUnit\n    )\n    \n    // 속도 변환: (거리 변환 / 시간 변환) * 원래 값\n    return value.multiply(distanceFactor).divide(timeFactor, 10, RoundingMode.HALF_UP)\n  }\n  \n  override fun create(value: BigDecimal): Velocity = Velocity.of(value, this)\n}\n```\n\n위 코드를 보면 `VelocityUnit` 클래스는 거리 단위와 시간 단위를 조합하여 속도를 표현한다. `convert` 메서드는 거리 단위와 시간 단위를 각각 변환한 후, 속도 변환을 수행한다. 예를 들어 60km/h를 m/s로 변환할 때, 거리 단위는 km에서 m로, 시간 단위는 h에서 s로 변환하여 최종 속도를 계산한다.\n\n다음으로 속도를 표현하는 `Velocity` 클래스를 구현해보자.\n\n```kotlin\nclass Velocity private constructor(\n  value: BigDecimal,\n  unit: VelocityUnit\n) : AbstractMeasure<Velocity>(value, unit) {\n  companion object {\n    fun of(value: BigDecimal, unit: VelocityUnit): Velocity = Velocity(value, unit)\n    fun of(value: Double, unit: VelocityUnit): Velocity = of(BigDecimal.valueOf(value), unit)\n    \n    // 편의 메서드\n    fun metersPerSecond(value: Double): Velocity = of(value, VelocitySystem.METERS_PER_SECOND)\n    fun kilometersPerHour(value: Double): Velocity = of(value, VelocitySystem.KILOMETERS_PER_HOUR)\n    fun milesPerHour(value: Double): Velocity = of(value, VelocitySystem.MILES_PER_HOUR)\n  }\n  \n  override fun getUnitSystem(): UnitSystem<Velocity> = VelocitySystem\n  \n  // 거리 계산 (속도 × 시간)\n  fun multiply(time: Time): Distance {\n    val velocityUnit = unit as VelocityUnit\n    val convertedTime = time.convertTo(velocityUnit.timeUnit)\n    \n    val distanceValue = value.multiply(convertedTime.value)\n    return Distance.of(distanceValue, velocityUnit.distanceUnit as DistanceUnit)\n  }\n  \n  // 시간 계산 (거리 ÷ 속도)\n  fun timeToTravel(distance: Distance): Time {\n    val velocityUnit = unit as VelocityUnit\n    val convertedDistance = distance.convertTo(velocityUnit.distanceUnit as DistanceUnit)\n    \n    val timeValue = convertedDistance.value.divide(value, 10, RoundingMode.HALF_UP)\n    return Time.of(timeValue, velocityUnit.timeUnit)\n  }\n}\n```\n\n여기서 주목할 점은 `multiply` 메서드와 `timeToTravel` 메서드이다. `multiply` 메서드는 속도와 시간을 곱하여 거리를 계산하고, `timeToTravel` 메서드는 거리를 속도로 나누어 시간을 계산한다. 이처럼 복합 측도는 기본 측도를 조합하여 새로운 기능을 제공할 수 있다.\n\n마지막으로 속도 단위계를 정의하는 `VelocitySystem`을 구현해보자.\n\n```kotlin\nobject VelocitySystem : AbstractUnitSystem<Velocity>() {\n  val METERS_PER_SECOND = VelocityUnit(\"m/s\", \"meters per second\", \n                                        DistanceSystem.METER, TimeSystem.SECOND)\n  \n  val KILOMETERS_PER_HOUR = VelocityUnit(\"km/h\", \"kilometers per hour\",\n                                          DistanceSystem.KILOMETER, TimeSystem.HOUR)\n  \n  val MILES_PER_HOUR = VelocityUnit(\"mph\", \"miles per hour\",\n                                    DistanceSystem.MILE, TimeSystem.HOUR)\n  \n  val FEET_PER_SECOND = VelocityUnit(\"ft/s\", \"feet per second\",\n                                      DistanceSystem.FOOT, TimeSystem.SECOND)\n  \n  override val baseUnit: Unit<Velocity> = METERS_PER_SECOND\n  \n  override val availableUnits: Set<Unit<Velocity>> = setOf(\n    METERS_PER_SECOND, KILOMETERS_PER_HOUR, MILES_PER_HOUR, FEET_PER_SECOND\n  )\n  \n  // 속도 생성 메서드\n  fun from(distance: Distance, time: Time): Velocity {\n    // 기본 단위로 변환\n    val baseDistance = distance.convertTo(DistanceSystem.METER)\n    val baseTime = time.convertTo(TimeSystem.SECOND)\n    \n    // 속도 계산\n    val velocityValue = baseDistance.value.divide(baseTime.value, 10, RoundingMode.HALF_UP)\n    \n    return Velocity.of(velocityValue, METERS_PER_SECOND)\n  }\n}\n```\n\n위와 같이 여러 단위가 정의된 복합 측도도 기본 측도 모델로 구현할 수 있다.\n\n## 파생 측도\n\n이어서 파생 측도는 기본 측도를 기반으로 만들 수 있는 새로운 측도다. 대표적인 예로 길이를 곱하여 면적을 구하거나, 길이와 면적을 곱하여 부피를 구하는 경우가 있다. 이런 경우 다음과 같이 코드를 작성할 수 있다.\n\n```kotlin\nclass Distance private constructor(\n  value: BigDecimal,\n  unit: DistanceUnit\n) : AbstractMeasure<Distance>(value, unit) {\n    \n  // 기존 메서드들...\n  \n  // 두 길이를 곱해 직사각형 면적 계산\n  fun area(other: Distance): Area {\n    // 같은 단위로 변환\n    val convertedOther = other.convertTo(unit as DistanceUnit)\n    \n    // 면적 계산\n    val areaValue = value.multiply(convertedOther.value)\n    \n    // 길이 단위에 맞는 면적 단위 생성\n    val areaUnit = AreaUnit.fromDistanceUnit(unit as DistanceUnit)\n    \n    return Area.of(areaValue, areaUnit)\n  }\n  \n  // 정사각형 면적\n  fun square(): Area {\n    return this.multiply(this)\n  }\n}\n```\n\n위와 같이 `area` 메서드를 통해 두 길이를 곱하여 면적을 계산할 수 있다. 이때 면적 단위는 길이 단위를 기반으로 생성할 수 있다. 예를 들어 미터(m) 단위의 길이를 곱하면 제곱미터(m²) 단위의 면적이 된다. 이를 위해 `AreaUnit`에서 `fromDistanceUnit` 메서드를 구현하여 길이 단위를 기반으로 면적 단위를 생성할 수 있도록 만들어야 한다.\n\n```kotlin\nclass AreaUnit(\n  override val symbol: String,\n  override val name: String,\n  val conversionFactor: BigDecimal // 기본 단위(m²)에 대한 변환 계수\n) : Unit<Area> {\n  companion object {\n    // 길이 단위로부터 면적 단위 생성\n    fun fromDistanceUnit(unit: DistanceUnit): AreaUnit {\n      val symbol = \"${unit.symbol}²\"\n      val name = \"square ${unit.name}\"\n      // 길이 변환 계수의 제곱이 면적 변환 계수가 됨\n      val conversionFactor = unit.conversionFactor.pow(2)\n      return AreaUnit(symbol, name, conversionFactor)\n    }\n  }\n  \n  override fun convert(value: BigDecimal, toUnit: Unit<Area>): BigDecimal {\n    // ... 면적 단위 변환 로직\n  }\n  \n  override fun create(value: BigDecimal): Area = Area.of(value, this)\n}\n\n// Area, AreaSystem 구현 생략\n```\n\n이런 방식으로 측도와 측도 간의 관계를 정의하여 파생 측도를 구현할 수 있다. 측도는 독립적으로만 존재하는 것이 아니라, 서로 관계를 맺고 있으며, 이를 통해 복합 측도와 파생 측도를 모델링할 수 있다. 이러한 관계를 잘 정의하면, 다양한 물리적 현상을 프로그래밍적으로 표현할 수 있다.\n\n# 마치며\n\n지금까지 측도 모델을 통해 어떻게 다양한 물리적 수량을 표현하고, 단위 변환 및 연산을 수행할 수 있는지 살펴보았다. 측도 모델은 객체지향 설계의 원칙을 잘 활용하여, 코드의 재사용성과 유지보수성을 높일 수 있는 강력한 도구이다. 또한 안정성 측면에서도 원시 타입을 사용하는 것보다 훨씬 안전하다.\n\n소프트웨어가 어떤 가치를 제공하냐에 따라 필요한 측도는 다를 수 있다. 따라서 측도 모델을 설계할 때는 도메인에 맞는 측도를 정의하고, 필요한 연산과 변환을 고려하여 설계해야 한다. 또한, 측도 모델은 단순히 수량을 표현하는 것뿐만 아니라, 비즈니스 로직을 구현하는 데에도 큰 도움이 된다.\n","tableOfContents":{"items":[{"url":"#들어가며","title":"들어가며"},{"url":"#추상화된-것을-구체화하기","title":"추상화된 것을 구체화하기"},{"url":"#측도-모델링","title":"측도 모델링","items":[{"url":"#값과-단위","title":"값과 단위"},{"url":"#수량","title":"수량"},{"url":"#화폐","title":"화폐"}]},{"url":"#수학적-측도","title":"수학적 측도"},{"url":"#복합-측도와-파생-측도","title":"복합 측도와 파생 측도","items":[{"url":"#복합-측도","title":"복합 측도"},{"url":"#파생-측도","title":"파생 측도"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"소프트웨어는 다양한 데이터를 다루는 복잡한 시스템이다. 이러한 데이터는 단순히 숫자나 문자열로 표현되는 것이 아니라, 그 자체로 의미를 가지며, 이를 잘 이해하고 활용하는 것이 소프트웨어 개발의 핵심이다. 이번 글에서는 이러한 데이터의 양이나…","fields":{"slug":"/posts/modeling-series-measure","date":"2025-05-02"},"frontmatter":{"title":"모델링 시리즈: 측도","categories":"article","tags":["modeling"],"image":"/images/2025-05-02-modeling-series-measure/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-26","slug":"/posts/how-to-build-an-agent"},"frontmatter":{"title":"AI 에이전트를 만드는 방법","image":"/images/2025-04-26-how-to-build-an-agent/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-02","slug":"/posts/modeling-series-measure"},"frontmatter":{"title":"모델링 시리즈: 측도","image":"/images/2025-05-02-modeling-series-measure/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/modeling-series-measure","series":{"title":"모델링 시리즈","items":[{"title":"모델링 시리즈: 서문","url":"/posts/modeling-series-foreword"},{"title":"모델링 시리즈: 뷰모델","url":"/posts/modeling-series-view-model"},{"title":"모델링 시리즈: 조건 트리","url":"/posts/modeling-series-conditional-tree"},{"title":"모델링 시리즈: 측도","url":"/posts/modeling-series-measure"}]},"frontmatter":{"series":"모델링 시리즈","title":"모델링 시리즈: 측도","categories":"article","tags":["modeling"],"image":"/images/2025-05-02-modeling-series-measure/thumbnail.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}