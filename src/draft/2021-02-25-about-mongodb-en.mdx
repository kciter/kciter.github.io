---
title: "MongoDB Understanding"
categories: article
tags: [database, mongodb, server]
image: /images/2021-02-25-about-mongodb/thumbnail.png
comments: true
---

import Image from '@components/Image';

Why use MongoDB? How do we use MongoDB? The purpose of this article is to answer these questions:
* What is MongoDB?
* What is a distributed system
* How to use the MongoDB modeling pattern

## What is NoSQL?

NoSQL is **Not Only SQL**. It means that it is not a relational database that uses SQL. The representative relational database is MySQL, Oracle, PostgreSQL, and the NoSQL includes MongoDB, Redis, HBase, etc.

So, why was NoSQL born? Isn't RDBMS enough? RDBMS was not a silver bullet and had clear limitations. NoSQL supports the following things that are difficult to do in RDBMS:

* Horizontal scalability
* Schema-less
* Relaxed ACID

### RDBMS vs NoSQL

If you search for RDBMS and NoSQL comparison on the Internet, you can see the table a lot:

| | RDBMS | NoSQL |
|---|------|------|
|Suitable use case|Banking system that requires data integrity|SNS system that requires low latency and high availability|
|Data model|Schema with normalization and referential integrity|Schema-less data model|
|Transaction|Strong ACID support|Relaxed ACID(BASE)|
|Scalability|Hardware enhancement(Scale up)|Horizontally scalable distributed architecture(Scale out)|
|API|SQL query|Object-based API|

The table above is written as if RDBMS could not be horizontally scaled, but MySQL Replication and MySQL Cluster exist, so it is not impossible to horizontally scale. And ACID is not impossible in NoSQL. MongoDB supports distributed transactions. However, since most NoSQL databases were released with distributed architecture in mind, they are more convenient, and since they are BASE-based, they are not complete ACID. They are absorbing each other's advantages, so the table above should be seen only as a reference.

### So, what is MongoDB?

MongoDB is a NoSQL database that has the three characteristics:

* Document
* BASE
* Open Source

MongoDB is based on Document and prioritizes performance and availability over ACID. And thanks to the open source, it is available for free.

Just so you know, MongoDB was certainly AGPL licensed a few years ago, but it changed to [SSPL(Server Side Public License)](https://en.wikipedia.org/wiki/Server_Side_Public_License).

#### Document

MongoDB is a document-based database. It consists of a hierarchy of `Database > Collection > Document > Field`. Document is equivalent to Row in RDBMS. The hierarchy is similar to RDBMS.

<Image src="/images/2021-02-25-about-mongodb/mongodb-layer.jpg" caption="RDBMS and MongoDB data layer structure" />

The interesting thing is that unlike RDBMS, Document-based databases can freely structure data. MongoDB stores data in BSON, so it can easily store Array data or Nested data.

<Image src="/images/2021-02-25-about-mongodb/bson.png" caption="JSON(BSON) data structure" />

In the data structure, you can see the unfamiliar type `ObjectId`. `ObjectId` is a unique key like `Primary Key` in RDBMS, but the difference is that `Primary Key` is assigned by DBMS, but `ObjectId` is created by the client. This is because the router(mongos) in the MongoDB cluster can quickly retrieve data from the sharded data by looking at the `ObjectId`. MongoDB server does not support `ObjectId` even if it stores it automatically. Note that if you store it without `ObjectId`, the data will be stored as it is.

<Image src="/images/2021-02-25-about-mongodb/objectid.png" caption="https://developer.mongodb.com/quickstart/bson-data-types-objectid/" />

`ObjectId` is divided into three areas. The first 4 bytes contain UNIX Timestamp information, and the next 5 bytes are random values, divided into 3 bytes and 2 bytes. The first 3 bytes use a random value created using a unique key(mac address or ip address) for the client's machine. The next 2 bytes use the process id. After filling in the 5 bytes, the last 2 bytes are composed of values generated by `Auto Increment`.

You may be wondering about how likely `ObjectId` will collide. For a collision to occur, the hash value generated simultaneously and device must match, and the count that has been increased by chance must match. I don't think it will happen often.[^1]

Next, let's talk about manipulating MongoDB data. NoSQLs like MongoDB do not use SQL, but instead **provide APIs** to manipulate data. In the case of MongoDB, the API is provided using the JavaScript engine SpiderMonkey. So, you need to know some JavaScript.

<Image src="/images/2021-02-25-about-mongodb/query.png" caption="Insert Query" />

If you look at the query to insert data into MongoDB, you can see that it looks very different from SQL. It looks like a method in a class, and MongoDB can manage data through object manipulation.

#### BASE

BASE is a concept that contrasts with ACID and consists of the following three things:

* **B**asically **A**valiable
  * Basically, it means that it can be used at any time.
  * In other words, it means that availability is required.
* **S**oft state
  * It means that information can change without external intervention.
  * In the event of a network partition, etc., the data is automatically modified for consistency.
* **E**ventually consistent
  * It means that even if it is temporarily inconsistent, it should become consistent after a certain period of time.
  * In the event of a failure, an event is triggered to maintain consistency.

In this way, BASE sacrifices some consistency and prioritizes availability. In other words, it means that it is delivered even if the data is slightly incorrect.

By the way, I wondered why it was expressed as `Basically Avaliable` or `Eventually consistent` instead of `Acid` and `Base`, but I heard that it was forced to be expressed as `Base` to give a feeling of contrast with `Acid`. I don't know if it's true, but I think it's a pretty interesting story.

#### ACID?

I wrote an article as if MongoDB was not ACID at all, but in fact, MongoDB provides transactions. Even when it was not ACID, it provided `Single-Document Transaction`, and since MongoDB 4.0, it has provided `Multi-Document Transaction`, satisfying ACID. After that, MongoDB 4.2 provided `Shard Cluster Transacion`, making distributed transactions possible.

### MongoDB is a distributed system

This time, let's talk about MongoDB's distributed system. Since MongoDB is installed and entered by default, it is a part that must be known.

<Image src="/images/2021-02-25-about-mongodb/thinking-face.png" width={340} />

As web services have evolved, the need for databases that require more data, faster performance, and horizontal scaling has emerged, even at the expense of data integrity. MongoDB was born to meet such requirements.

#### CAP Theory

<Image src="/images/2021-02-25-about-mongodb/cap.png" />

CAP theory is a theory first introduced by Eric Bruer in 2000, and it is a theory that no distributed system can satisfy **Consistency**, **Availability**, and **Partition tolerance** at the same time. It is called the CAP theory because it follows the initials of these three.

**Consistency** means that all nodes can see the same data at the same time. In other words, if the data is updated and synchronized to other nodes, all users see the latest data, it is a consistent system. To do this, users must wait during synchronization. If the waiting time is long, the system's availability is reduced.

<Image src="/images/2021-02-25-about-mongodb/consistency.png" />

**Availability** means that all requests can return success or failure results. If one node fails, the system can provide data through another node, it is an available system. If the data is different from other nodes when the node is alive again, the system is inconsistent.

<Image src="/images/2021-02-25-about-mongodb/availability.png" />

**Partition tolerance** means that the system must continue to operate even if communication fails. It means that the network that connects the nodes is broken, not the node itself. It means that the consistency is lost if the communication is broken and synchronization is impossible. If you wait for communication to recover and synchronize, availability is reduced. In the end, both cannot be satisfied.

<Image src="/images/2021-02-25-about-mongodb/partition-tolerance.png" />

### Limitations of CAP Theory

If you look at the CAP theory, you can see that MongoDB is a `CP` system that has consistency and partition tolerance. But let's doubt it. Can a `CA` system exist?

`CA` is impossible because network partitions should never occur, so you must decide after assuming that `P` will always occur.

And a system that leans toward `CP` or `AP` is not good. It is ideal to be able to change flexibly according to the situation or set it in the way the developer wants. Therefore, most distributed systems set different priorities for consistency and availability depending on the situation.

<Image src="/images/2021-02-25-about-mongodb/choose.png" caption="요구 사항에 따라 골라야한다." />

### PACELC Theory

The PACELC theory is a theory that assumes that network partitions always occur and makes choices accordingly.

<Image src="/images/2021-02-25-about-mongodb/pacelc.png" />

The theory is based on the following choices:

<table>
  <thead>
    <tr>
      <th>Division</th>
      <th>Composition</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2"><strong>P</strong>artition</td>
      <td><strong>A</strong>vailability</td>
      <td>Availability</td>
    </tr>
    <tr>
      <td><strong>C</strong>onsistency</td>
      <td>Consistency</td>
    </tr>
    <tr>
      <td rowspan="2"><strong>E</strong>lse</td>
      <td><strong>L</strong>atency</td>
      <td>Latency</td>
    </tr>
    <tr>
      <td><strong>C</strong>onsistency</td>
      <td>Consistency</td>
    </tr>
  </tbody>
</table>

Here, `Partition` means the state of network partition, and `Else` means the normal state. If it is `PA / EL`, it means that availability is prioritized when a network partition occurs, and latency is prioritized when it is normal. In other words, MongoDB is a `PA / EC` system, so it prioritizes availability when a network partition occurs and prioritizes consistency when it is normal.

### MongoDB Replica Set

MongoDB can be configured with a Replica Set as the simplest way to configure a cluster. Replica Set can be configured in the following two ways:
* P-S-S
* P-S-A

Sharded clusters can also be configured, but they are not covered in this post.

#### P-S-S

<Image src="/images/2021-02-25-about-mongodb/pss.png" />

The P-S-S system is a Replica Set consisting of one Primary and multiple Secondaries.

<Image src="/images/2021-02-25-about-mongodb/pss-vote.png" />

In the P-S-S system, if the Primary dies, the remaining Secondaries vote to elect a new Primary. If there is only one Secondary left, a new Primary cannot be elected, causing a server failure.

#### P-S-A

<Image src="/images/2021-02-25-about-mongodb/psa.png" />

The P-S-A system is a Replica Set consisting of one Primary, Arbiter, and multiple Secondaries.

<Image src="/images/2021-02-25-about-mongodb/psa-vote.png" />

In the P-S-A system, if the Primary dies, the Arbiter and Secondary vote to elect a new Primary. Even if there is only one Secondary left, the Arbiter can elect the remaining Secondary as the Primary, so the service can operate normally.

## MongoDB Pattern

MongoDB uses the Document method, so modeling should be done differently from RDBMS. Let's summarize the patterns for this.

### Model Tree Structure

When data in the same Collection has a Tree structure that refers to each other, there are five patterns that can be used. All the patterns introduced are based on the Tree structure below.

<Image src="/images/2021-02-25-about-mongodb/model-tree-structure.png" />

#### Parent References

Parent References have the following structure:

```js
[
  { _id: "MongoDB", parent: "Databases" },
  { _id: "dbm", parent: "Databases" },
  { _id: "Databases", parent: "Programming" },
  { _id: "Languages", parent: "Programming" },
  { _id: "Programming", parent: "Books" },
  { _id: "Books", parent: null }
]
```

It is suitable when you need to find the parent Document directly. If you need to find all the child trees, it is not suitable.

#### Child References

Child References have the following structure:

```js
[
  { _id: "MongoDB", children: [] },
  { _id: "dbm", children: [] },
  { _id: "Databases", children: [ "MongoDB", "dbm" ] },
  { _id: "Languages", children: [] },
  { _id: "Programming", children: [ "Databases", "Languages" ] },
  { _id: "Books", children: [ "Programming" ] }
]
```

It is suitable when you need to find the child Document directly. You can also find the parent Document, but it is slower than Parent References.

#### Array of Ancestors

Array of Ancestors have the following structure:

```js
[
  { _id: "MongoDB", ancestors: [ "Books", "Programming", "Databases" ], parent: "Databases" },
  { _id: "dbm", ancestors: [ "Books", "Programming", "Databases" ], parent: "Databases" },
  { _id: "Databases", ancestors: [ "Books", "Programming" ], parent: "Programming" },
  { _id: "Languages", ancestors: [ "Books", "Programming" ], parent: "Programming" },
  { _id: "Programming", ancestors: [ "Books" ], parent: "Books" },
  { _id: "Books", ancestors: [ ], parent: null }
]
```

It is suitable when you need to find the Document directly. It is suitable for Breadcrumb, etc. If you have multiple parent Documents, it is not suitable.

#### Materialized Paths

Materialized Paths have the following structure:

```js
[
  { _id: "Books", path: null },
  { _id: "Programming", path: ",Books," },
  { _id: "Databases", path: ",Books,Programming," },
  { _id: "Languages", path: ",Books,Programming," },
  { _id: "MongoDB", path: ",Books,Programming,Databases," },
  { _id: "dbm", path: ",Books,Programming,Databases," }
]
```

It is similar to Array of Ancestors. It uses a String type instead of an Array type to find the child items using regular expressions. It is faster than Array of Ancestors. However, it may be slower if you need to find a common parent.

#### Nested Sets

Nested Sets have a slightly different structure. Let's look at the structure based on the numbers in the image below.

```js
[
  { _id: "Books", parent: 0, left: 1, right: 12 },
  { _id: "Programming", parent: "Books", left: 2, right: 11 },
  { _id: "Languages", parent: "Programming", left: 3, right: 4 },
  { _id: "Databases", parent: "Programming", left: 5, right: 10 },
  { _id: "MongoDB", parent: "Databases", left: 6, right: 7 },
  { _id: "dbm", parent: "Databases", left: 8, right: 9 }
]
```

It is the fastest and most efficient way to find the child tree. However, it is suitable for static structures that do not change because it is costly to renumber the data when the structure changes.

### Model Relationships

MongoDB can also configure `1:1`, `1:N`, `N:M` structures like RDBMS. MongoDB provides two types of references, Reference and Embed. Reference is like a `Foreign Key` that refers to a key, and Embed is like including data as an Object in a Document.

<Image src="/images/2021-02-25-about-mongodb/link-vs-embed.png" />

If you are configuring `1:1`, it is best to Embed as a Sub Document. If the Document is too large, you have no choice but to separate it.

For `1:N`, refer to the above flowchart. If there is data that is frequently used when Link is selected, use the `Extended Reference` pattern or `Subset pattern`. `1:N` can be configured as follows:

```js

// 1 References N
// Movie Collection
{
  title: 'Star Wars',
  reviews: [1, 2, 3]
}

// Review Collection
[
  {
    _id: 1,
    comment: 'Good'
  },
  {
    _id: 2,
    comment: 'Good'
  },
  {
    _id: 3,
    comment: 'Good'
  }
]
```

```js
// N is Referenced by 1
// Movie Collection
{
  title: 'Star Wars',
}

// Review Collection
[
  {
    _id: 1,
    title: 'Star wars',
    comment: 'Good'
  },
  {
    _id: 2,
    title: 'Star wars',
    comment: 'Good'
  },
  {
    _id: 3,
    title: 'Star wars',
    comment: 'Good'
  }
]
```

For `N:M`, it is configured by referring to each other as `1:N`.

### Modeling Pattern

MongoDB does not provide functions such as Subquery or Join. Although `Aggregation` can be used similarly, it is not recommended because performance is significantly degraded when referring to multiple Collections.

In this case, to prevent referencing multiple Collections and simplify data, you can use the **Modeling Pattern**. This pattern is also introduced on the official website, and this post introduces six frequently used patterns.

#### Attribute

The Attribute pattern is a pattern that reduces the number of indexes by bundling the same fields. For example, when the data is structured as follows:

```js
{
  title: "Star Wars",
  director: "George Lucas",
  ...
  release_US: ISODate("1977-05-20T01:00:00+01:00"),
  release_France: ISODate("1977-10-19T01:00:00+01:00"),
  release_Italy: ISODate("1977-10-20T01:00:00+01:00"),
  release_UK: ISODate("1977-12-27T01:00:00+01:00"),
  ...
}
```

If you need to search by the release date of each country, you need to index it for performance.

```js
{release_US: 1}
{release_France: 1}
{release_Italy: 1}
...
```

However, in this case, there are too many indexes, making it difficult to manage and increasing the capacity. To prevent this, you can use the Attribute pattern.

```js
{
  title: "Star Wars",
  director: "George Lucas",
  ...
  releases: [
    {
      location: "USA",
      date: ISODate("1977-05-20T01:00:00+01:00")
    },
    {
      location: "France",
      date: ISODate("1977-10-19T01:00:00+01:00")
    },
    {
      location: "Italy",
      date: ISODate("1977-10-20T01:00:00+01:00")
    },
    {
      location: "UK",
      date: ISODate("1977-12-27T01:00:00+01:00")
    },
    ...
  ],
  ...
}
```

Although it was introduced grandly, it means simply bundling the same fields. In this case, you can reduce the number of indexes to two.

```js
{ "releases.location": 1, "releases.date": 1}
```

#### Extended Reference

The Extended Reference pattern is a pattern that stores frequently used data in related Documents. In MongoDB, it is recommended to use the Extended Reference pattern instead of Join to improve performance.

<Image src="/images/2021-02-25-about-mongodb/extended-reference1.png" />

Let's look at the Collection above. When an order is placed, data is stored in the `Order` Collection, and the customer who placed the order is recorded in the `customor_id` field. There seems to be no problem, but if you need to show customer information when showing order details, you need to use Join. As mentioned earlier, MongoDB's Join performance is poor, so it becomes a difficult situation. In this case, you can use the Extended Reference pattern.

<Image src="/images/2021-02-25-about-mongodb/extended-reference2.png" />

The Extended Reference pattern means storing the necessary data in the related Collection in part of the Document. In fact, it is a method that is often used for performance and convenience in RDBMS. However, MongoDB has no choice but to use it quite often. Remember this.

#### Subset

The Subset pattern is a pattern that partially Embeds frequently used data between related Documents. It looks similar to the Extended Reference pattern, but it is a little different.

<Image src="/images/2021-02-25-about-mongodb/subset1.png" />

Assume that there is a Collection related to the Product and a Collection related to the Review. In this case, the Review is stored in the Collection related to the Product in Embed form. If there are many reviews, it is necessary to separate them into a separate Collection. If you want to quickly show the latest 5 reviews, what should you do?

<Image src="/images/2021-02-25-about-mongodb/subset2.png" />

The answer is simple. Store only the latest 5 reviews in the Product Document. In this way, you can quickly deliver data to users by storing only the latest 5 reviews in the Product Document. Provide a `More` menu to allow users to click. If you use MongoDB as your main database, the Subset pattern is a pattern that is often used. Remember this.

By the way, if **data modification occurs, both sides must be modified**.

#### Computed

The Computed pattern is a pattern that calculates statistics when inserting data. This pattern is also frequently used in RDBMS.

<Image src="/images/2021-02-25-about-mongodb/computed.png" />

If you need the total number of viewers as shown in the image above, you can use an aggregation function when reading, but you can also store it in a separate field. The Computed pattern is recommended if you can afford a little error.

#### Bucket

The Bucket pattern is a pattern that bundles Documents based on one field. It is suitable for real-time time-series data.

```js
{
  sensor_id: 12345,
  timestamp: ISODate("2019-01-31T10:00:00.000Z"),
  temperature: 40
}

{
  sensor_id: 12345,
  timestamp: ISODate("2019-01-31T10:01:00.000Z"),
  temperature: 40
}

{
  sensor_id: 12345,
  timestamp: ISODate("2019-01-31T10:02:00.000Z"),
  temperature: 41
}
```

When collecting log data like the above, if you want to use the Computed pattern, you need to create a separate Collection to store the data. However, using the Bucket pattern can easily solve the problem.

```js
{
    sensor_id: 12345,
    start_date: ISODate("2019-01-31T10:00:00.000Z"),
    end_date: ISODate("2019-01-31T10:59:59.000Z"),
    measurements: [
      {
      timestamp: ISODate("2019-01-31T10:00:00.000Z"),
      temperature: 40
      },
      {
      timestamp: ISODate("2019-01-31T10:01:00.000Z"),
      temperature: 40
      },
      ...
      {
      timestamp: ISODate("2019-01-31T10:42:00.000Z"),
      temperature: 42
      }
    ],
   transaction_count: 42,
   sum_temperature: 2413
} 
```

Looking at the structure above, it is a structure that bundles Documents into one Document based on `sensor_id`. In this case, you can also configure fields for aggregation such as `transaction_count` and `sum_temperature`. In this case, it is easy to add or delete fields, and it is also possible to save index size. However, be careful not to exceed the BSON size limit. It is good to bundle based on `start_date` and `end_date` as in the above structure to avoid exceeding the limit.

#### Schema Versioning

The Schema Versioning pattern is a pattern that records version information in the Document. When operating a service, the schema is likely to change. In this case, the Schema Versioning pattern can be used to avoid hasty migration of existing data.

```js
{
  "_id": "<ObjectId>",
  "name": "Darth Vader",
  "home": "503-555-0100",
  "work": "503-555-0110",
  "mobile": "503-555-0120"
}
```

Assume that you need to change the field of the above data. If there are more than 1 billion data, it is quite a big task to migrate. In this case, you can configure it as follows using the Schema Versioning pattern.

```js
{
  "_id": "<ObjectId>",
  "schema_version": "2",
  "name": "Anakin Skywalker (Retired)",
  "contact_method": [
    { "work": "503-555-0210" },
    { "mobile": "503-555-0220" },
    { "twitter": "@anakinskywalker" },
    { "skype": "AlwaysWithYou" }
  ]
}
```

By setting the `schema_version` field to 2, you can work without conflict by adding the `schema_version` condition when `find` in the application. After solving this, you can migrate slowly.

## Conclusion

MongoDB and RDBMS have different suitable use cases. In my personal opinion, I think that using MongoDB and other NoSQL as simply as possible is the right direction. NoSQL is suitable for **as simple as possible and as much data as possible**, and RDBMS is suitable for **complex and data integrity important data**. Of course, simplifying data is not an easy task, so if you plan to use MongoDB, I recommend that you refer to the above modeling patterns to structure the data.

[^1]: Even if a collision occurs, it is okay because an error is returned.
