{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2024-04-26-living-with-ai-mdx","path":"/posts/living-with-ai/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n> 이제 인정할 수 밖에 없다. AI 없는 개발로 돌아갈 수 없다는 것을…\n\n확실하게 역체감을 느끼게 해주는 제품은 성공할 수 밖에 없다. 이제 필자를 비롯한 대다수의 개발자에게 AI 서비스는 사용하지 않던 시절로 돌아가기 힘든 제품이 되었다. ChatGPT, Claude를 비롯한 LLM 서비스나 개발을 위한 GitHub Copilot은 당당하게 가치있음을 증명했다.\n\n사실 필자는 AI를 그다지 달가워하지 않는다. 이는 지극히 개인적인 이유로, 손수 한땀한땀 코딩하는 재미를 빼앗기는 기분이 들었기 때문이다. 마치 퍼즐을 집는 순간 어디에 둬야할지 알려주는 스포일러를 보는 느낌이다. 물론 이는 단순히 감정적인 이유일 뿐이고 AI가 개발 생산성과 비용 절감에 큰 도움이 된다는 것은 충분히 이해하고 있다. 개인의 감상은 언제나 시대의 흐름에 휩쓸려갈 뿐이다.\n\n# AI를 대하는 마음가짐\n\n이제 개발자를 비롯하여 핵심 자산이 지식에 있는 지식 노동자들은 AI를 더이상 무시할 수 없다는 것은 사실이다. 물론, 아직 AI가 개발자의 일을 완전히 대체할 수 없다는 것도 사실이다. 그렇기 때문에 개발자가 더 집중해야 하는 문제가 무엇인지, AI가 할 수 있는 일과 없는 일이 무엇인지 알고, 잘 활용하는 방법을 아는 것이 중요하다.\n\n# 개발자가 사용할 수 있는 AI 도구\n\n굉장히 많은 AI 도구가 존재하지만 대게 개발자가 이용하는 AI는 크게 대화형과 코드 자동완성형 두 가지로 나뉜다고 볼 수 있다.\n\n<Image src=\"/images/2024-04-26-living-with-ai/chatgpt.gif\" caption=\"ChatGPT\" />\n\n대화형 AI는 사용자가 질문을 던지면 적절한 답변을 해주는 방식을 제공한다. 보통 모르거나 고민되는 내용을 프롬프트를 통해 질의하면 빠르게 답변을 받을 수 있다. 따라서 모르는 지식을 검색 대신 빠르게 찾거나 설계 및 구현에 대한 조언을 받을 때 유용하다.\n\n<Image src=\"/images/2024-04-26-living-with-ai/github-copilot.gif\" caption=\"GitHub Copilot\" />\n\n코드 자동완성형 AI는 코드를 작성할 때 자동완성 기능을 제공한다. 개발자가 코드를 작성하면서 자주 사용하는 패턴을 학습하여 코드를 자동완성 해주는 방식이다. 따라서 반복적인 작업을 할 때 유용하며, 이미 알고 있는 내용을 빠르게 타이핑할 때도 유용하다.\n\n# 대화형 AI\n\n대화형 AI는 말 그대로 프롬프트를 통해 서로 대화하는 것처럼 상호작용하는 것이 가능하다. 이를 통해 조금 추상적으로 질의하거나 이전 대화에서 얻은 정보를 바탕으로 더 깊은 질문을 던질 수 있다. 이는 AI가 학습한 내용과 대화 문맥을 바탕으로 추론을 하기 때문에 유용하다.\n\n다만, 필자가 사용했을 때 **AI가 학습하지 않았거나 학습량이 부족한 자료에 대해서는 전혀 도움이 되지 않는다**는 것을 느꼈다. 이 부분은 꽤 위험하다 할 수 있는데, 잘못된 지식이나 코드로 인해 큰 피해를 입을 수도 있기 때문이다. 그래도 대부분의 사례에선 아주 구체적인 내용까지는 아니더라도 설계에 대한 큰 그림을 잡거나 조언을 얻을 때 유용하다.\n\n필자가 느끼기에 현재로서 대화형 AI를 가장 유용하게 쓰는 방법은 **러버덕 디버깅**이라고 생각한다.\n\n<Image src=\"/images/2024-04-26-living-with-ai/rubber-duck.webp\" caption=\"귀엽다\" />\n\n[러버덕 디버깅](https://codesquad-yoda.medium.com/%EB%9F%AC%EB%B2%84%EB%8D%95-%EB%94%94%EB%B2%84%EA%B9%85-76c4e3fbef3c)은 문제 해결을 혼자 고민하는 것이 아닌 누군가에게 설명하듯이 문제를 설명하면서 해결책을 찾는 방법이다. 예를 들면, 위 사진에 나온 러버덕에게 내가 만든 코드와 현재 발생하는 문제를 설명하며 스스로 문제 해결 방법을 깨우치는 것이다. 물론 실제 사람과 대화한다면 새로운 아이디어를 얻을 수도 있지만, 이는 다른 사람의 시간을 소모하게 되는 단점이 있다.\n\n대화형 AI를 이용하면 러버덕 디버깅을 더 효율적으로 할 수 있다. 사람과 달리 AI는 언제나 이용할 수 있기 때문에 편할 때 질문을 던질 수 있다. 편한 마음으로 러버덕에게 설명하듯이 AI에게 문제를 설명하면서 해결책을 찾을 수 있다. 혹은 AI가 문제 해결에 대한 아이디어를 줄 수도 있다. 이는 개발자의 집중력을 높이고, 문제 해결 능력을 향상시키는 데 큰 도움이 된다.\n\n# 자동완성형 AI\n\n자동완성형 AI는 개발자가 코드를 작성할 때 자동완성 기능을 제공한다. 개발 편의를 위해 정적 분석 결과를 바탕으로 자동완성하는 것이 아닌 작성된 코드를 AI가 읽은 후 다음에 나올 코드를 예측하여 자동완성해준다. \n\n이는 이미 알고 있는 내용을 빠르게 타이핑할 때 유용하며, 반복적인 작업을 할 때도 유용하다. 또한, 유틸리티 코드나 테스트 코드를 작성할 때도 유용하다. 그러나 일반적인 내용을 벗어나면 잘 안되는 경우가 있으므로 주의해야 한다.\n\n자동완성형 AI를 사용할 때 주의할 점은 **패턴을 읽어 제안하는 것이기 때문에 이미 코드베이스가 있다면 기능 확장에 대해 유용하다**는 것이다. 따라서 패턴을 이용하여 코드를 작성하거나 주석을 이용하여 더 정확한 제안을 받을 수 있다.\n\n{/*\n# AI가 못하는 일\n\n필자가 사용해본 경험으로는 아직 AI가 개발자의 일을 완전히 대체할 수 없다고 느꼈다. 따라서 AI가 할 수 없는 일을 개발자가 해야 한다는 것을 명심해야 한다. AI가 할 수 없는 일은 크게 세 가지로 나눌 수 있다.\n\n# Cusor IDE와의 만남\n*/}\n\n# 마치며\n\nAI는 개발자에게 큰 도움이 되는 도구이다. 그러나 아직 AI가 개발자의 일을 완전히 대체할 수 없다는 것을 명심해야 한다. 따라서 개발자가 더 집중해야 하는 문제가 무엇인지, 개발자가 할 역할이 무엇인지 잘 고민할 필요가 있다.\n\n그리고 AI는 오히려 집중력을 저하시키는 것도 가능하다는 것을 명심해야 한다. AI와 노는데 시간을 보낼 수 있고 그러한 유혹을 한다는 것을 기억하자.\n","tableOfContents":{"items":[{"url":"#ai를-대하는-마음가짐","title":"AI를 대하는 마음가짐"},{"url":"#개발자가-사용할-수-있는-ai-도구","title":"개발자가 사용할 수 있는 AI 도구"},{"url":"#대화형-ai","title":"대화형 AI"},{"url":"#자동완성형-ai","title":"자동완성형 AI"},{"url":"#마치며","title":"마치며"}]},"excerpt":"이제 인정할 수 밖에 없다. AI 없는 개발로 돌아갈 수 없다는 것을… 확실하게 역체감을 느끼게 해주는 제품은 성공할 수 밖에 없다. 이제 필자를 비롯한 대다수의 개발자에게 AI 서비스는 사용하지 않던 시절로 돌아가기 힘든 제품이 되었다…","fields":{"slug":"/posts/living-with-ai","date":"2024-04-26"},"frontmatter":{"title":"AI와 더불어 살아가기","categories":"article","tags":["ai","llm","productivity"],"image":"/images/2024-04-26-living-with-ai/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-26","slug":"/posts/living-with-ai"},"frontmatter":{"title":"AI와 더불어 살아가기","image":"/images/2024-04-26-living-with-ai/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/living-with-ai","frontmatter":{"title":"AI와 더불어 살아가기","categories":"article","tags":["ai","llm","productivity"],"image":"/images/2024-04-26-living-with-ai/thumbnail.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}