{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-03-02-react-component-based-thinking-mdx","path":"/posts/react-component-based-thinking/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n컴포넌트는 React를 이용하여 프론트엔드 개발을 한다면 가장 중요한 개념이라 할 수 있다. 컴포넌트를 단순히 UI를 구성하는 단위라고 생각할 수 있지만, 사실 UI를 포함하여 이벤트 처리, 상태 관리, 통신 등 많은 부분을 컴포넌트가 담당한다. 로직을 컴포넌트로부터 아무리 잘 분리하더라도 결국 최종적으로 사용자는 컴포넌트를 통하기 때문에 좋은 제품을 만들고 싶다면 컴포넌트에 대한 이해가 필수적이다.\n\n<Image src=\"/images/2025-03-02-react-component-based-thinking/user-meets-components.png\" caption=\"사용자는 반드시 컴포넌트를 통한다\" />\n\n앞서 말한 것처럼 **React의 컴포넌트는 UI 뿐만 아닌 사용자가 시스템과 상호작용하는 모든 부분을 담당**한다. 이번 글에서는 React 컴포넌트를 어떻게 바라보고 어떤 것이 중요한지에 대해 알아볼 것이다.\n\n# 컴포넌트를 바라보는 시각\n\n흔히 React에서 컴포넌트는 UI를 구성하는 단위로 생각되지만 본래 프로그래밍에서 컴포넌트라는 개념은 조합과 재사용이 가능한 객체를 의미한다. 사실 React 컴포넌트는 UI를 빼고 생각하는 것이 더 중요하다. UI는 단지 컴포넌트가 하는 일 중 하나일 뿐이다. 그런 측면에서 생각했을 때 컴포넌트는 다양한 관점으로 바라볼 수 있고 그에 따라 구현이 달라질 수 있다.\n\n* 컴포넌트는 로직과 뷰의 조합이다.\n* 컴포넌트는 요소와 스타일의 조합이다.\n* 컴포넌트는 서버 상태를 반영하는 뷰다.\n* 컴포넌트는 사용자 이벤트를 처리하는 통로다.\n* 컴포넌트는 상태를 직접 제어할 수 있는 것과 아닌 것으로 나뉜다.\n* 컴포넌트는 유한 상태 머신이다.\n* ...\n\n위처럼 컴포넌트는 관점에 따라 다르게 묘사할 수 있다. 왜 관점이 달라질까? 그 이유는 목적이 다르기 때문이다. 즉, 컴포넌트는 **목적에 따라 추성화**가 가능하다.\n\n## 컴포넌트 분해하기\n\n추상화를 잘하기 위해선 목적에 따라 필요한 것을 조합할 수 있어야 한다. 그러기 위해선 무엇을 조합할 수 있는지 알아야 한다. 컴포넌트를 분해하는 것은 이러한 관점에서 시작된다. 일단 분해하여 무엇이 있는지 알면 목적에 따라 필요한 것을 조합할 수 있게 된다.\n\n[컴포넌트 구성 요소 이미지]\n\n뷰                              데이터                       로직\n요소 속성 텍스트 이벤트 토큰        Props 상태                 이벤트핸들러 라이프사이클 사이드이펙트\n\n생각보다 컴포넌트를 구성하는 것은 많다.\n\n컴포넌트는 크게 이름, UI, 데이터, 상태, 이벤트 핸들러, 라이프사이클, 사이드 이펙트로 구성된다. 각 구성 요소는 또 세세하게 나누는 것이 가능하다.\n\n이렇게 나뉜 구성 요소 중 목적에 따라 필요한 것을 조합하여 원하는 컴포넌트를 만들 수 있다. 예를 들어보면 Headless 컴포넌트는 스타일 요소를 완전히 배제한 컴포넌트라고 할 수 있다. 또 다른 예로 고차 \n\n위 이미지를 보았을 때 컴포넌트는 다음과 같은 요소로 구성되어 있다.\n\n* UI\n  * 요소 (DOM Element)\n    * 속성 (Attribute)\n    * 텍스트\n    * 이벤트\n  * 토큰 (CSS)\n* 상태\n* 이벤트 핸들러\n* 라이프사이클\n* Props\n\n## 컴포넌트간 협력\n\n## 컴포넌트 분류\n\n# 컴포넌트 평가\n\n## 컴포넌트의 사회성\n\n## 컴포넌트의 신뢰성\n\n## 컴포넌트의 가독성\n\n## 컴포넌트의 의존성\n\n# 마치며\n\n사고 방식은 실제 구현에 큰 영향을 미친다. 또한, 소통을 위한 명확한 기준은 팀의 생산성을 높인다. 컴포넌트는 추상적이면서 구체적인 개념이다. 그러다보니 굉장히 다양한 방식의 구현이 가능하다. 이로 인한 커뮤니케이션 비용이 증가할 수 있기 때문에 컴포넌트에 대한 사고 방식을 명확히 하는 것이 중요하다. 꼭 이 글이 아니더라도 컴포넌트에 대한 기준을 정하고 팀원들과 공유하는 것이 중요하다.\n","tableOfContents":{"items":[{"url":"#컴포넌트를-바라보는-시각","title":"컴포넌트를 바라보는 시각","items":[{"url":"#컴포넌트-분해하기","title":"컴포넌트 분해하기"},{"url":"#컴포넌트간-협력","title":"컴포넌트간 협력"},{"url":"#컴포넌트-분류","title":"컴포넌트 분류"}]},{"url":"#컴포넌트-평가","title":"컴포넌트 평가","items":[{"url":"#컴포넌트의-사회성","title":"컴포넌트의 사회성"},{"url":"#컴포넌트의-신뢰성","title":"컴포넌트의 신뢰성"},{"url":"#컴포넌트의-가독성","title":"컴포넌트의 가독성"},{"url":"#컴포넌트의-의존성","title":"컴포넌트의 의존성"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"컴포넌트는 React를 이용하여 프론트엔드 개발을 한다면 가장 중요한 개념이라 할 수 있다. 컴포넌트를 단순히 UI를 구성하는 단위라고 생각할 수 있지만, 사실 UI를 포함하여 이벤트 처리, 상태 관리, 통신 등 많은 부분을 컴포넌트가 담당한다…","fields":{"slug":"/posts/react-component-based-thinking","date":"2025-03-02"},"frontmatter":{"title":"React 컴포넌트 기반 사고","categories":"article","tags":["react","frontend","component"],"image":"/images/2025-03-02-react-component-based-thinking/thumbnail.png","comments":true,"draft":true}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/react-component-based-thinking","series":{"title":"리액트 컴포넌트 시리즈","items":[{"title":"Polymorphic한 React 컴포넌트 만들기","url":"/posts/polymorphic-react-component"},{"title":"Render Delegation하는 React 컴포넌트 만들기","url":"/posts/render-delegation-react-component"},{"title":"React 컴포넌트 기반 사고","url":"/posts/react-component-based-thinking"}]},"frontmatter":{"series":"리액트 컴포넌트 시리즈","title":"React 컴포넌트 기반 사고","categories":"article","tags":["react","frontend","component"],"image":"/images/2025-03-02-react-component-based-thinking/thumbnail.png","comments":true,"draft":true,"hide":true}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}