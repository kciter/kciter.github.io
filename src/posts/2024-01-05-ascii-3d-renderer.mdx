---
title: "ASCII 3D 렌더러 만들기"
categories: dev
tags: [crafting, renderer, 3d, ascii]
image: /images/2024-01-05-ascii-3d-renderer/thumbnail.png
comments: true
draft: true
hide: false
---

import Image from '@components/Image';
import { SpinningCube } from '@materials/2024-01-05-ascii-3d-renderer';

필자는 쓸데없지만 재밌는 프로그램을 만들면서 공부하는 것을 좋아한다. 최근에 정신적으로 에너지가 바닥나고 있다는 것을 느껴 작년에 재미로 만들었던 [Jazzlang](https://kciter.so/posts/crafting-esolang/)과 같이 정신적 에너지를 채워줄만한 재미를 느끼고 싶었다. 그래서 무언가 할만한 것을 찾던 중 작년 이맘때 쯤 재밌는 [유튜브 영상](https://www.youtube.com/watch?v=p09i_hoFdd0)을 봤던 것이 생각났다. 영상에서는 **CLI 환경에서 큐브를 회전시키는 프로그램**을 처음부터 끝까지 조용히 코딩하는 것을 보여준다.

<figure>
  <Image src="/images/2024-01-05-ascii-3d-renderer/youtube.gif" width="80%" />
  <figcaption>영상 중 일부 캡쳐</figcaption>
</figure>

필자는 이 아이디어가 굉장히 참신하다 생각했다. 마침 무언가를 만들고 싶었던 차에 `큐브가 됐다면 CLI 환경에서 다른 물체도 3D 렌더링 할 수 있지 않을까?`라는 생각을 하게되었고 실제로 구현했다. 이 글을 읽기 전에 미리 보고 싶다면 [이곳](https://github.com/kciter/ascii-3d-renderer.js)에서 실행해볼 수 있다.

# 어떻게 ASCII를 3D처럼 보이게 할까?

3D 렌더링은 빛과 그림자, 최적화, 쉐이더, 충돌 처리, 물리 계산 등 굉장히 난이도가 높은 기술이 포함된다. 하지만 우리는 단순히 3D 물체를 화면에 그리기만 할 것이기 때문에 몇 가지 기본적인 기술만 있으면 된다. 우선 화면에 나오는 물체를 왜 3D처럼 인식을 할까? 답은 간단하다. 스크린을 통해 **원근감**을 표현했기 때문이다. 사람이 원근감을 느끼도록 만드는 방법은 다양하지만 일반적인 CLI 환경에서 쓸 수 있는 것은 **선[^1]과 명암** 뿐이다.

<Image src="/images/2024-01-05-ascii-3d-renderer/perspective.png" caption="겨우 선 몇 개로 공간을 표현할 수 있다" />

선을 이용하여 원근감을 표현하는 방법은 간단하다. **멀리있는 것은 결국 한 점으로 모인다**는 사실을 이용할 수 있다. 이를 미술 용어로 [소실점](https://ko.wikipedia.org/wiki/%EC%86%8C%EC%8B%A4%EC%A0%90)이라 부른다. 이러한 소실점은 여러 개가 있을 수 있다.

<Image src="/images/2024-01-05-ascii-3d-renderer/shade.jpeg" caption="빛과 그림자를 통해 입체감을 표현할 수 있다" width="70%" />

명암을 포함한 원근감을 표현하는 방법은 더욱 간단하다. **빛이 있는 곳은 밝게, 빛이 없는 곳은 어둡게** 표현하면 된다. 이를 통해 물체의 입체감을 표현할 수 있다.

그럼 이제 ASCII 만으로 원근감, 입체감을 표현할 방법을 찾아야한다. 우선 선을 이용한 방법은 3D 공간 좌표를 2D 좌표로 변환하면 자연스럽게 처리될 것이다. 그럼 가장 고민이 되는 지점은 명암을 표현하는 방법인데 **빛이 보고있는 방향에서 나온다 가정했을 때 가까이 있을 수록 짙은 텍스트 멀리 있을 수록 옅은 텍스트로 표현**하면 될 것이다. 이를 ASCII로 표현한다면 다음과 같을 것이다.

```
@ : 가장 짙은 명암
% : 짙은 명암
# : 조금 짙은 명암
x : 중간 명암
o : 조금 옅은 명암
; : 옅은 명암
. : 가장 옅은 명암
```

참고로 간격이 일정해야 하므로 반드시 고정폭 글꼴을 사용해야 한다. 앞서 소개했던 유튜브 영상에서 나오는 큐브처럼 명암을 표현하면 다음과 같다.

<div style="box-shadow: 1px 1px 2px 2px rgba(0, 0, 0, 0.1); border-radius: 4px; padding: 16px; width: 80%; margin: 0 auto 8px auto">
  <SpinningCube />
</div>
<figcaption>마치 상자가 회전하는 것처럼 보인다</figcaption>

위 예제는 필자가 직접 웹에서 실행 가능하도록 구현했다. 비록 빛에 기반한 명암 처리는 아니지만 확실하게 **입체감**이 느껴진다. 이제 이를 구현하기 위해 필요한 지식을 알아보자.

# 3D 좌표를 2D 좌표로

우리가 표현하고자 하는 물체는 3D 공간에 존재하지만 모니터 스크린은 2D 공간이다. 따라서 이를 표현하기 위해서는 **값으로 정의된 3D 공간을 모니터 스크린인 2D 공간에 보이도록 변환**시킬 필요가 있다. 이런 변환하는 과정을 **렌더링 파이프라인**이라고 한다.

<Image src="/images/2024-01-05-ascii-3d-renderer/rendering-pipeline.png" caption="렌더링 파이프라인" />

이 글에서는 오로지 ASCII를 이용하여 3D 물체를 표현하는 것이 목표이므로 렌더링 파이프라인의 일부만 구현할 것이다. 그렇기 때문에 전체를 자세히 설명하지는 않고 필요한 부분만 설명할 것이다. 렌더링 파이프라인은 크게 보면 세 과정으로 이루어진다.

* 버텍스 처리 (Vertex processing)
* 래스터화 (Rasterization)
* 프래그먼트 처리 (Fragment processing)

각 과정을 하나씩 살펴보자.

## 버텍스 처리

3D 공간을 표현하기 위해서는 **3D 공간 좌표**가 필요하다. 3D 공간 좌표는 **데카르트 좌표계**를 사용하여 좌표를 3개의 축 `(x, y, z)`와 같이 표현한다. 어려운 용어처럼 느껴지지만 그냥 3개의 값으로 좌표를 표현한다고 생각하면 된다.

<Image src="/images/2024-01-05-ascii-3d-renderer/cartesian-coordinate-system.png" caption="데카르트 좌표계" width="50%" />

이렇게 표현된 좌표를 **버텍스**<sup>Vertex</sup>라고 부르며 3D 공간에 위치한 '정점'을 의미한다. 버텍스 하나로는 물체를 표현할 수 없으므로 버텍스를 모아 물체를 표현한다. 이때 물체를 표현하는 최소 단위를 **폴리곤**<sup>Polygon</sup>이라고 부른다. 보통 폴리곤은 특수한 경우[^2]를 제외하면 3개의 버텍스로 이루어진 삼각형으로 표현한다. 하필 삼각형인 이유는 면을 구성하기 위해 필요한 최소 단위가 삼각형이며 효율적이기 때문이다.

<Image src="/images/2024-01-05-ascii-3d-renderer/low-polygon.jpeg" caption="버추어 파이터 / 적은 수의 폴리곤을 사용했기에 각져 보인다" />

이렇게 버텍스와 폴리곤으로 구성된 하나의 물체를 **폴리곤 메시**<sup>Polygon mesh</sup>라고 부른다. 보통 개발자는 디자이너가 만들어준 3D 모델 파일을 불러와서 폴리곤 메시를 만든다. 3D 모델 파일에는 버텍스와 폴리곤을 포함한 다양한 정보가 담겨있다. 이 정보를 통해 물체를 표현할 수 있다. 이 과정을 **버텍스 처리**<sup>Vertex processing</sup>라고 부른다.

버텍스 처리 단계에서 버텍스에 대한 여러 처리를 할 수 있지만 보통 변환을 처리하는 것이 가장 기본이다. 여기서 말하는 **변환이 3D 공간을 스크린으로 옮기는 핵심 로직**이다. 변환은 보통 네 단계를 거친다.

* 모델 변환 (Model transform) 혹은 월드 변환 (World transform)
* 뷰 변환 (View transform) 혹은 카메라 변환 (Camera transform)
* 투영 변환 (Projection transform)
* 뷰포트 변환 (Viewport transform) 혹은 스크린 변환 (Screen transform)

## 래스터화

## 투영 변환

3D 공간 좌표를 2D 공간 좌표로 변환시키는 것을 **투영 변환**<sup>Projective Transformation</sup>이라고 한다. 투영 변환을 간단하게 정의하면 **3차원 공간의 점을 2차원 공간의 점으로 변환하는 것**이라 할 수 있다.

투영 변환은 다양한 방법이 존재하지만 그 중에서도 원근감을 표현하기 위해 **원근 투영**을 사용할 것이다. 기본적으로 원근 투영은 가까이 있는 것은 크게, 멀리 있는 것은 작게 표현하는 방법이다. 원근 투영을 계산하기 위해선 행렬을 사용한다.

<Image src="/images/2024-01-05-ascii-3d-renderer/perspective-projection.jpeg" caption="원근 투영" width="60%" />

# 구현하기

이제 3D 공간 좌표를 2D 공간 좌표로 변환하는 방법을 알았으니 이를 통해 ASCII로 3D 물체를 표현하기 위한 구현을 해보자.

## 설계

우선 로직의 순서는 다음과 같을 것이다.

* 카메라 위치를 정한다.
* 3D 물체를 불러온다.
* 카메라 위치에 따라 3D 물체의 공간 좌표를 2D 공간 좌표로 변환한다.
* 변환된 좌표를 통해 ASCII 문자를 출력한다.

# 마치며

[^1]: 엄밀히 따지면 선은 아니다. 픽셀이라는 작은 사각형이 모여 선처럼 보이는 것처럼 ASCII 문자열이 모여 선처럼 보이는 것이다.
[^2]: 3D 모델링 툴은 작업의 편의성을 위해 사각 폴리곤을 제공한다. 이는 후처리 과정에서 삼각 폴리곤으로 변환된다.