{"version":3,"file":"component---src-posts-2024-06-12-log-5-mdx-e9797f03b87891af2be1.js","mappings":"sRAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,MACFC,EAAAA,EAAAA,KAAsBL,EAAMM,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,gLAAiL,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,uJAAwJ,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,iIAAkI,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,6IAA8I,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,iPAAkP,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,8NAA+N,KAAMG,EAAAA,cAAoBN,EAAYG,EAAG,KAAM,kIACh6C,CAKA,UAJA,SAAoBJ,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOQ,QAASC,GAAaP,OAAOC,OAAO,CAAC,GAAGE,EAAAA,EAAAA,KAAsBL,EAAMM,YAC3E,OAAOG,EAAYF,EAAAA,cAAoBE,EAAWT,EAAOO,EAAAA,cAAoBR,EAAmBC,IAAUD,EAAkBC,EAC9H,C,qECeA,MAAMU,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBN,GAC/B,MAAMO,EAAoB,aAAiBF,GAG3C,OAAO,WACL,WAEE,MAA0B,mBAAfL,EACFA,EAAWO,GAGb,IAAIA,KAAsBP,EACnC,GACA,CAACO,EAAmBP,GAExB,C","sources":["webpack://kciter.so/./src/posts/2024-06-12-log-5.mdx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"개발자들이 삽질한다는 얘기를 들어보셨나요? 실제로 보면 열심히 뭔가를 하는데 왜 ‘삽질’이라고 부를까요? 제가 느끼기에 개발자는 전반적으로 자조적인 성향이 짙습니다. 아마 출시한 제품에 대한 책임감 때문이 아닐까 싶습니다. 기능에 문제가 생기면 결국 문제가 생긴 코드를 작성한 내 탓이라 생각하기 쉬우니까요.\"), \"\\n\", React.createElement(_components.p, null, \"개발자가 실제로 무언가를 개발하기 전에는 충분한 지식과 뒷받침되는 근거가 필요합니다. 그리고 실제로 개발하는 기간에도 개발자가 미리 알지 못한 문제, 예외로 인해 추가 연구(학습)가 필요할 수 있습니다. 개발자들은 보통 이 기간을 ‘삽질하는 중’이라고 표현합니다.\"), \"\\n\", React.createElement(_components.p, null, \"‘삽질’이라는 용어가 ‘쓸모없는 일을 한다’라는 관용어로 쓰이는 만큼 부정적인 이미지가 강합니다. 관리자에 따라서는 이 기간을 무가치한 시간이라 생각하고 삽질이 길어질수록 개발자로서 능력이 부족하다는 평가를 내리기도 합니다.\"), \"\\n\", React.createElement(_components.p, null, \"사실 앞서 표현한 것처럼 ‘삽질’은 학습이자 연구입니다. 그리고 그 기간 축적된 지식은 귀중한 회사의 자산이 됩니다. 공부한 것을 정리하지 않으면 금방 까먹듯이 ‘삽질한 기간’에 생긴 지식을 정리하지 않는다면 정말로 무가치한 시간이 되어버립니다.\"), \"\\n\", React.createElement(_components.p, null, \"관리자로서 정말 제품과 비즈니스를 생각한다면 개발자의 삽질이 정말 쓸모없는 시간으로 바뀌기 전에 회사의 자산으로 만들어야 합니다. 삽질은 나쁜 것이 아니라는 문화를 만들고 다양한 툴로 연구 결과를 기록하고 잊히지 않도록 쉽게 찾을 수 있게 구성하고 다양한 곳에 레퍼런스를 남겨야 합니다. 만약 문화가 없다면 ‘삽질’이 무가치한 시간이라는 분위기 속에서 개발자는 그 시간을 숨기게 되고 연구 결과는 영영 사라져 버리고 맙니다.\"), \"\\n\", React.createElement(_components.p, null, \"만약 어렵게 느껴진다면 검증된 프레임워크를 사용해 봅시다. 스크럼과 XP에는 ‘스파이크’라는 용어가 있습니다. 스파이크는 제품에 가치를 부여하는 것은 아니지만 리스크를 피하거나 더 좋은 방법을 찾아내는 작업을 말합니다. 이렇게 프레임워크를 도입하여 삽질이라 부르는 기간을 존중할 수 있는 시간으로 바꿀 수 있고 적절한 프로세스를 통해 연구 결과를 모두가 알 수 있게 만드는 것도 가능합니다.\"), \"\\n\", React.createElement(_components.p, null, \"‘삽질’이 진짜 무의미한 시간이 되지 않기 위해선 많은 노력이 필요합니다. 만약 개발자의 삽질을 경시하는 문화를 바꾸고 싶다면 ‘삽질’이 아닌 ‘연구’나 ‘스파이크’와 같은 다른 용어를 사용하는 것부터 시작해 보면 좋겠습니다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","_provideComponents","components","React","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}