---
title: "비밀 관리를 위한 금고 시스템 만들기"
categories: dev
tags: [vault, cipher, security, password]
image: /images/2024-04-14-encrypted-vault-system/thumbnail.jpeg
comments: true
draft: false
hide: false
---

import Image from '@components/Image';

요즘은 편한 UX에 힘입어 비밀번호 관리 시스템을 사용하는 사람들이 많다. 대체로 브라우저 혹은 OS에서 제공하는 시스템을 이용하지만 1Password와 같은 애플리케이션을 이용하는 사람도 적지않다. 만약 힙한 것을 좋아하는 사람이라면 오픈소스를 이용하는 경우도 있다.

이런 제품을 사용한다면 한 번쯤 `정말 안전한게 맞을까?`라는 의심을 해본 적이 있을 것이다. 이번 글에서는 암호에 대한 기본적인 원리와 지식을 익히고 이후 금고 시스템을 직접 구현해보며 비밀번호 관리 시스템의 원리에 대해 알아볼 것이다.

# 암호화에 대한 정의

이 글에 관심을 가진 개발자라면 대부분 암호화가 무엇인지 대략적으로 알고 있을 것이다. 당연하지만 암호라는 것은 오래전부터 사용되어왔고 많은 시행착오와 발전을 거쳐 개발 세계에 도입된 것이다. 그러니 먼저 암호화의 정의에 대해 알아보자.

> 암호학은 방해 행위로부터 **프로토콜**을 방어하는 것을 목표로 하는 과학이다. (...)<br />
> 당신은 몇 시간 정도 마법검을 내려놓고 낮잠을 좀 자고 싶다. 이를 위한 프로토콜을 한 가지 구성해보면 다음과 같다.
>
> 1. 땅에 무기를 내려 놓는다.
> 2. 나무 아래서 낮잠을 잔다.
> 3. 땅에서 무기를 들어 올린다.
>
> 물론 이는 좋은 프로토콜이 아니다. 낮잠을 자는 사이 누군가가 마법검을 훔칠 수 있기 때문이다. 여기서 암호학의 역할을 마법검을 훔쳐가려는 적의 존재를 고려하는 것이다.<br />
> <div style="text-align:right;"> - 리얼월드 암호학 1장 4쪽</div>

위와 같이 비우호적인 존재로부터 프로토콜을 방어하는 것이 암호학의 목표라고 할 수 있다. 또한, 한국어 위키피디아에 의하면 **특별한 지식을 소유한 사람들을 제외하고는 누구든지 읽어볼 수 없도록 알고리즘을 이용하여 정보(평문을 가리킴)를 전달하는 과정**이라고 한다. 조금 더 단순하게 표현하자면 평문(Plain text)를 암호문(Cipher text)으로 바꿔서 전달하는 것을 의미한다.

간단한 사례를 살펴보면 원시적인 암호화 방법으로 **카이사르 암호(시저 암호)**라는 것이 있다. 카이사르 암호는 [치환암호](https://ko.wikipedia.org/wiki/%EC%B9%98%ED%99%98_%EC%95%94%ED%98%B8)의 일종으로 암호화하고자 하는 내용을 알파벳별로 일정한 거리만큼 밀어서 다른 알파벳으로 치환하는 방식이다. 예를 들어 3글자씩 밀어내는 카이사르 암호로 'COME TO ROME'을 암호화하면 'FRPH WR URPH'가 된다. 이렇게 암호화된 문장을 다시 복호화하려면 암호화할 때와 같은 거리만큼 밀어내면 된다. 여기선 **프로토콜은 문장을 제 3자에게 전달하는 것이고 3글자씩 밀어낸다는 것이 암호화의 핵심**이다. 물론 이런 방식은 매우 취약하기에 현대에선 사용되지 않는다.

<Image src="/images/2024-04-14-encrypted-vault-system/caesar-cipher.png" caption="카이사르 암호는 각각의 알파벳을 일정한 거리만큼 밀어 글자를 치환하는 방식으로 암호화한다" width="80%" />

만약 스포츠를 좋아한다면 실시간으로 전략을 정할 때 사인을 보낸다는 것을 알고 있을 것이다. 이 때 전략이 유출되면 안되기 때문에 팀 내에서 수신호의 의미를 정하고 외부에 공개하지 않는다. 그렇지만 상대편 또한 의미를 해석하려 하기에 키 사인(Key sign)을 사용하여 숨기기도 한다. 이 또한 암호화의 한 형태라고 할 수 있다.

<Image src="/images/2024-04-14-encrypted-vault-system/sport-sign.jpeg" caption="다른 사람들은 이 수신호의 의미를 알 수 없다" />

이런 단순한 형태의 암호화를 거쳐 오늘 날의 암호화는 복잡하고 검증된 알고리즘을 사용한다. 이런 알고리즘을 이용하면 비밀번호 관리 시스템을 만드는 것도 가능하다. 이 글에서는 **프로토콜을 어떻게 안전하게 만들 것인가?**를 다루는 것이 목적이며 알고리즘이 어떻게 이루어지는지는 다루지 않을 것이다. 따라서 복잡한 수학적인 지식은 필요하지 않다.

# 케르크호프스의 원칙

> 공개된 암호화 표준을 구축하는 것은 케르크호프스의 원칙이라는 개념과 관련이 있다.
> 이 원칙은 대략 다음과 같다 '우리가 가장 많이 사용하는 알고리즘을 적이 발견하지 못하리라고 기대하는 것은 어리석은 일이다. 차라리 적에게 공개적으로 개방하자'<br />
> <div style="text-align:right;"> - 리얼월드 암호학 1장 9쪽</div>

카이사르 암호나 스포츠에서 사용되는 사인과 다르게 프로그래밍에 쓰이는 암호화 관련 알고리즘은 대부분 공개되어 있다. 앞서 소개한 사례는 알고리즘이 유출되는 경우 너무나도 쉽게 복호화가 가능하다. 그러니 **알고리즘이 공개되었는데 정말 안전한게 맞는가?**라는 의문이 충분히 들 수 있다. 결론부터 말하자면 최소한 요즘 프로그래밍에 사용되는 알고리즘은 안전하다고 말할 수 있다.

케르크호프스 혹은 커코프라 불리는 원칙은 Auguste Kerckhoffs가 작성한 글인 군사용 암호 설계 원칙을 살펴보자. 한국어 위키백과에 실린 내용은 다음과 같다.

1. 암호체계는 수학적으로는 해독불가능하지 않다고 하더라도, 실질적으로 그래야한다.
2. **암호체계는 비밀에 부쳐질 필요가 없어야만 하며, 적의 손에 떨어지더라도 문제가 없어야 한다.**
3. 키는 글로 쓰여지지 않더라도 교환 혹은 보관할 수 있어야 한다. 당사자들의 의지에 의해서 바뀌거나 수정될 수 있어야 한다.
4. 전신에 적용할 수 있어야 한다.
5. 이동이 가능해야하며, 암호 체계의 사용과 기능을 위해 여러 사람의 협력을 필요로 하지 않아야 한다.
6. 마지막으로, 시스템의 활용을 요구하는 여러 상황들이 주어졌을 때, 암호 체계는 이용이 쉬워야 하며, 정신적인 압박감이나 여러 규칙들의 관찰을 필요로 하지 않아야 한다.

이 중 두 번째 `암호체계는 비밀에 부쳐질 필요가 없어야만 하며, 적의 손에 떨어지더라도 문제가 없어야 한다.`가 케르크호프스의 원칙으로 알려졌으며 소프트웨어적으로 표현한다면 암호화 알고리즘이 노출되더라도 안전해야 한다고 할 수 있다. 이 말처럼 이미 HTTPS나 이 글에서 다루는 비밀번호 관리자 시스템 등 많은 영역에서 AES, RSA 등 공개된 암호화 알고리즘을 사용하지만 충분히 안전하다.

알고리즘이 공개되어도 안전할 수 있는 이유는 **비밀 키**에 있다. 현대에서 사용되는 대부분의 알고리즘은 비밀 키를 다른 사람들이 모른다면 알고리즘이 알려지더라도 암호문을 안전하게 전달할 수 있다. 즉, 비밀 키를 통해 **알고리즘이 아닌 프로토콜을 안전하게 만드는 것**이다. 그러니 오히려 **알고리즘을 공개하여 더 많은 사람들이 검증하고 개선할 수 있도록 하는 것**이 더 안전하다고 할 수 있다. 우리가 사용하는 암호화 알고리즘은 많은 사람들이 헛점을 찾는 것에 도전했으며 그 많은 도전을 이겨내고 남은 것이다.

# 고전 암호는 왜 위험한가?

말은 쉽지만 공개되어도 안전한 알고리즘을 만드는 것은 쉬운 일이 아니다. 오늘 날의 컴퓨터는 사람이 절대 따라갈 수 없는 엄청난 연산량을 가지고 있다. 반면 컴퓨터가 등장하기 전 고전 암호라 불리는 암호 체계는 이러한 연산량을 고려하여 탄생하지 않았다.

예를 들어 앞서 사용했던 카이사르 암호는 특정한 숫자를 비밀 키로 사용하여 알파벳을 밀어내지만 비밀 키를 모르더라도 해독하는 것이 어렵지 않다. 알파벳은 겨우 26개이기 때문에 모든 경우의 수를 다 해보면 쉽게 해독할 수 있고 컴퓨터는 26개 정도는 순식간에 처리할 수 있다.

그러면 조금 더 복잡한 고전 암호는 어떨까? 16세기에 지오반 바티스타 벨라소라는 이탈리아 인이 만든 비즈네르 암호라는 것이 있다.[^1] 원리는 카이사르 암호와 비슷하지만 키와 알고리즘이 조금 더 복잡하다. 만약 키가 `DUF`고 `HI THERE`이라는 문장을 암호화한다면 `KU VJZUJ`가 된다.

<Image src="/images/2024-04-14-encrypted-vault-system/vigenere-cipher.png" caption="키가 DUF인 경우" />

이 암호의 핵심은 키에 해당하는 알파벳 위치가 특정 수를 나타내고 그 수만큼 평문을 연쇄적으로 밀어내는 것이다. 따라서 D, U, F는 각각 3, 20, 5를 의미하고 `HI THERE`을 3-20-5-3-20.. 순으로 밀어내면 `KU VJZUJ`가 된다. 비즈네르 암호는 키의 길이가 고정이 아니기 때문에 사람 손으로 해독하기엔 많은 경우의 수를 고려해야해서 어려울 것이다.

다만 컴퓨터 입장에서 그다지 어렵지 않다. [빈도분석](https://ko.wikipedia.org/wiki/%EB%B9%88%EB%8F%84%EB%B6%84%EC%84%9D)을 이용하면 쉽게 해독할 수 있다. 빈도분석은 언어에서 글자들의 분포가 고르지 않다는 점을 활용한다. 예를 들어 영어에서는 `E`가 가장 많이 나오는 글자이고 `Q`가 가장 적게 나오는 글자이다. 따라서 암호문에서 가장 많이 나오는 글자를 `E`로 해석하고 가장 적게 나오는 글자를 `Q`로 해석하면서 해독해 나가면 된다. 그리고 이러한 확률적인 계산과 반복적인 대입은 컴퓨터가 쉽게 할 수 있는 일이다.

> 비즈네르 암호는 이처럼 비교적 약한 암호이지만, 실제로 쓰이던 시절에는 메시지를 안전하게 암호화하는 용도로 충분히 쓸만했을 것이다. (...) 당시 비밀리에 전송한 메시지들은 대부분 아주 짧은 기간만 비밀을 유지하면 되었다. 따라서 언젠가 적이 암호를 해독한다고 해도 문제가 되지 않았다.
> <div style="text-align:right;"> - 리얼월드 암호학 1장 33쪽</div>

# 그러면 현대 암호는 안전한가?

고전 암호는 전수 키 탐색, 빈도 수 공격 등에 매우 취약하다. 특히 카이사르 암호와 같이 키 공간[^2]이 부족하고 언어적 특성이 바로 반영되는 경우엔 암호로서 큰 의미가 없다고 볼 수 있다. 그럼 현대 암호는 뭐가 다를까?

현대 암호는 **혼돈과 확산**이라는 개념을 극대화한 알고리즘을 사용한다. 혼돈과 확산은 정보 이론의 창시자라 할 수 있는 클로드 섀넌이 제시했으며 혼돈은 **암호문에서 키를 알아내기 어렵게 하는 성질**을 말하며 확산은 **암호문에서 원본 메세지를 알아내기 어렵게 하는 성질**을 말한다. 현대 암호는 이를 잘 달성했는지 여부가 암호화의 안전성을 판단하는 기준이 된다.

<Image src="/images/2024-04-14-encrypted-vault-system/confusion-and-diffusion.jpg" caption="인크립션: 실용주의 암호화 / 길벗" width="80%" />

그러면 혼돈과 확산은 어떻게 달성하는가? 혼돈은 원래 대상과 다른 대상을 섞어 원래 대상이 무엇인지 알아볼 수 없만들고 확산은 원래 대상이 암호문에서 최대한 넓은 부분으로 퍼지도록 만든다. 이때 혼돈을 달성하기 위해 **Substitution**<sup>대체</sup>을 사용하고 확산을 달성하기 위해 **Permutation**<sup>순열</sup>을 사용한다. 말 그대로 Substitution은 'ABCA'와 같은 문자열이 있다면 '1231'과 같이 대체하는 것을 말하고 Permutation은 'ABCA'와 같은 문자열이 있다면 'BCAA'와 같이 순서를 바꾸는 것을 말한다.

Substitution과 Permutation을 한 번 수행하는 것을 SPN(Substitution-Permutation Network)이라고 하며 현대 암호는 SPN을 여러번 반복하는 것으로 충분한 안정성을 달성한다.

# 세 가지 암호화 방식

보통 현대적인 암호화 알고리즘은 세 가지 방식으로 나뉜다. 각각 대칭 암호화, 비대칭 암호화, 해싱으로 이 세 가지 방식은 각각 다른 목적으로 사용되며 서로 다른 특징을 가지고 있다. 이 글에선 간단한 개념과 대표적인 알고리즘을 소개하고 구체적인 동작이나 구현에 대해 알아보지는 않을 것이다.

## 대칭 암호화

대칭 암호화는 하나의 비밀 키를 이용하여 암호화하고 복호화하는 알고리즘을 의미한다. 

<Image src="/images/2024-04-14-encrypted-vault-system/symmetric-key-algorithm.png" />

대표적으로 AES 알고리즘이 있으며 이를 이용하여 사용자가 추가할 비밀번호를 암호화하여 저장할 수 있다. 또한, 사용자가 비밀번호를 요청할 때 이 비밀 키를 이용하여 복호화하여 반환할 수 있다.

## 비대칭 암호화

## 해싱

# 개인 비밀번호 관리자

보통 브라우저나 OS에서 제공하는 비밀번호 관리자 시스템은 사용자 개인을 위해 만들어졌다. 이를 이용하면 어렵게 만든 비밀번호를 외우지 않더라도 쉽게 로그인하는 것이 가능하기에 매우 편리하다. 하지만 쓰면서도 정말 안전하게 맞는지 의심이 들 수 있다. 개인 비밀번호 관리자가 어떻게 돌아가는 지 이해하기 위해선 두 가지 개념을 알아야 한다. 바로 **마스터 패스워드**와 **대칭키 암호화**다. 실제 제품에는 보안을 위해 더 많은 기술이 필요하겠지만 가장 핵심적인 기술은 이 두 가지라고 할 수 있다.

## 마스터 패스워드

마스터 패스워드는 암호화되어 저장한 모든 비밀번호를 복호화할 수 있는 키를 의미한다. 이말은 즉, 마스터 패스워드이 유출되면 모든 비밀번호가 유출된다는 것을 의미한다. 또한, 유실할 경우 저장된 모든 비밀번호를 알 수 없게 되버린다. 따라서 이 마스터 패스워드는 안전하게 보관해야 한다. 다만, 유실의 경우 다른 특수한 기술을 사용하여 복구하는 방법이 있을 수 있다.

보통 마스터 패스워드는 그대로 사용하지 않고 사용자가 입력한 값을 해싱(Hashing) 알고리즘을 통해 만들어 낸다. 해싱 알고리즘은 단방향 암호화라고도 부르는데 그 이유는 받은 쪽에서 복호화가 불가능하기 때문이다. 오로지 받은 평문을 해싱하여 저장된 해싱값과 일치하는지 확인하는 것만 가능하다.

<Image src="/images/2024-04-14-encrypted-vault-system/hashing-algorithm.png" />

이를 이용하여 사용자가 입력한 마스터 패스워드를 해싱하여 비밀 키를 만들어낸다. 이렇게 만들어진 비밀 키를 저장하여 이후 사용자가 보낸 마스터 패스워드가 진짜인지 확인하는 용도로 사용할 수 있다.



## 정리

개인 비밀번호 관리자는 사용자가 입력한 마스터 패스워드를 해싱하여 비밀 키를 만들고 이를 저장하여 검증에 이용한다. 검증에 성공했다면 마스터 패스워드를 이용하여 대칭키 암호화로 추가할 비밀번호를 암호화한다. 사용자가 만약 비밀번호를 요청하면 대칭키를 이용해 복호화하여 반환한다. 이렇게 하면 사용자는 하나의 마스터 패스워드로 모든 비밀번호를 관리할 수 있게 된다.

<!-- 

# 팀 단위 관리

마스터 패스워드
대칭키
비대칭키
하이브리드 암호화

## 영지식 증명

-->

# 마치며

암호라는 것은 모든 것이 공개되는 인터넷 세계에선 필수라고 할 수 있다. 그럼에도 불구하고 필자를 포함한 많은 개발자들이 암호에 대해 잘 알지 못한다. 이 도메인을 전문적으로 다루거나 종사하는 것이 아니라면 모든 것을 다 알아야할 필요는 없겠지만 단순히 패스워드를 해싱하는 수준에서 벗어나 더 넓은 세계를 탐구해보는 것은 좋을 것이다.

참고로 이 글에서 쓰여진 코드는 정말 안전한지 검증된 것은 아니다. 따라서 이 글을 참고하여 실제 제품에 반영하고자 한다면 충분히 검증 후 도입하기를 권장한다. 여기서 사용된 알고리즘은 보편적으로 사용하는 것을 택했으며 더 안전한 방법이 있을 수 있다.

[^1]: 비즈네르는 다른 암호를 만든 블레즈 드 비즈네르라는 프랑스 인이지만 역사상의 인용 오류 때문에 그냥 비즈네르라는 이름이 굳어버렸다 / 처음 배우는 암호화 1장 32쪽
[^2]: 키가 될 수 있는 조합 수
