---
title: "바보야, 문제는 경계야!"
categories: article
tags: [software-engineering, boundary, architecture, design]
image: /images/2026-02-20-it-is-the-boundary-stupid/thumbnail.png
comments: true
draft: true
hide: false
---

import Image from '@components/Image';

소프트웨어 개발의 어려움은 늘 경계에 있었다.

새벽 3시, 알림이 울린다. 서비스가 죽었다. 급하게 로그를 열고 원인을 추적한다. 코드는 바뀐 게 없다. 테스트도 다 통과했다. 한참을 헤매다 결국 찾아낸 원인은 외부 결제 API의 응답 형식이 바뀐 것이었다. 내 코드와 외부 시스템 **사이**에서 문제가 터졌다.

아키텍처 회의를 떠올려보자. 화이트보드에 박스를 그리고 화살표를 잇는다. "이 서비스를 나눠야 하나, 합쳐야 하나?" "이 데이터는 누가 소유하는 거야?" 논쟁은 박스 안의 로직이 아니라 항상 박스와 박스 **사이**에서 벌어진다.

코드를 짜는 일상도 다르지 않다. 이 예외를 여기서 처리할 것인가, 호출자에게 넘길 것인가. 이 값이 null일 수 있는가, 없는가. 서버의 Instant를 클라이언트의 Date로 어떻게 변환할 것인가. 개발자의 시간을 잡아먹는 고민은 코드의 내부 로직이 아니라, 코드와 코드가 만나는 접점에 몰려 있다.

{/* TODO: 이미지 — "It's the economy, stupid" → "It's the boundary, stupid" 패러디. 1992년 미국 대선 캠페인의 유명한 슬로건을 소프트웨어 맥락으로 변형한 이미지 */}

**바보야, 문제는 경계야.**

이것이 이 글의 핵심 주장이다. 물론 모든 문제가 경계에서 온다고 말하는 것은 아니다. 알고리즘의 논리적 오류나 단순한 오타는 경계와 무관하다. 그러나 실무에서 개발자를 괴롭히는 **진짜 어려운 문제**들을 떠올려보자. 외부 API가 예고 없이 스펙을 바꿔 시스템이 무너진다. 분산 트랜잭션의 원자성이 깨져 데이터가 꼬인다. 내 로컬에서는 잘 되는데 배포만 하면 터진다. 이런 문제들은 놀라울 정도로 경계에 집중되어 있다.

사실 이는 소프트웨어만의 이야기가 아니다. 국경에서 분쟁이 일어나고, 부서 간 협업에서 갈등이 생기며, 문화와 문화가 만나는 곳에서 오해가 피어난다. 경계의 문제는 인간 세계 전반에 걸쳐 있지만, 그 이야기는 이 글의 범위를 벗어난다.

이 글에서는 소프트웨어 개발에서 경계가 만들어내는 문제들을 살펴보고, 그 경계를 어떻게 다스릴 수 있는지 이야기한다.

{/* TODO: 이미지 — 함수 → 모듈 → 시스템 → 조직으로 확대되는 경계의 스케일을 보여주는 동심원 또는 줌아웃 다이어그램 */}

# 경계란 무엇인가

그렇다면 소프트웨어에서 **경계**란 정확히 무엇일까? 경계란 **서로 다른 관심사, 책임, 또는 맥락이 만나는 지점**이다. 함수와 함수 사이에는 호출이라는 경계가 있고, 모듈과 모듈 사이에는 인터페이스라는 경계가 있다. 클라이언트와 서버 사이에는 네트워크라는 경계가 있고, 애플리케이션과 데이터베이스 사이에는 쿼리라는 경계가 있다.

경계는 왜 존재할까? 우리가 소프트웨어를 만들 때 하는 거의 모든 행위가 경계를 만드는 행위이기 때문이다. 함수를 나누는 것, 클래스를 정의하는 것, 모듈을 분리하는 것, 서비스를 쪼개는 것. 이 모든 것은 **관심사를 분리**하고 **복잡성을 관리하기 위한 경계 설정** 행위다. 소프트웨어 공학의 역사는 어떻게 보면 경계를 만드는 기술의 역사라 할 수 있다. 구조적 프로그래밍은 제어 흐름에 경계를 만들었고, 객체지향은 데이터와 행위에 경계를 만들었으며, 마이크로서비스는 배포 단위에 경계를 만들었다.

{/* TODO: 이미지 — 경계의 양면성 다이어그램. 하나의 덩어리를 경계로 나누면 내부는 단순해지지만, 경계 접점에서 새로운 복잡성(화살표, 프로토콜, 에러 처리 등)이 태어나는 모습 */}

여기서 아이러니가 발생한다. **경계는 복잡성을 다루기 위해 만들지만, 경계 자체가 새로운 복잡성의 원천이 된다.** 하나의 덩어리로 존재하던 코드를 둘로 나누는 순간, 그 둘 사이의 소통 방식을 정의해야 한다. 누가 누구를 호출하는지, 어떤 데이터를 주고받는지, 에러가 발생하면 어떻게 처리하는지. 경계가 없었다면 존재하지 않았을 문제들이 경계와 함께 태어난다.

그렇다고 경계를 만들지 않을 수는 없다. 경계 없는 소프트웨어는 모든 것이 뒤엉킨 혼돈이며, 인간의 인지 능력으로는 다룰 수 없다. 시스템이 커지면 단일 서버의 한계 때문에 분산 처리가 필요해지고, 그 순간 네트워크라는 경계가 불가피하게 생겨난다. 조직이 커지면 한 팀이 모든 코드를 소유할 수 없고, 팀과 팀 사이에 경계가 만들어진다. 우리는 경계를 만들 수밖에 없고, 따라서 경계에서 발생하는 문제와도 함께 살아갈 수밖에 없다. 중요한 것은 **경계가 어디에 있는지 인식하고, 그 경계에서 어떤 문제가 발생할 수 있는지 이해하는 것**이다.

그리고 하나 더. 경계를 다루려면 **경계 자체의 성질**을 알아야 한다. 함수 호출은 나노초 단위지만 네트워크 호출은 밀리초 단위다. 같은 프로세스 안에서는 메모리를 공유하지만, 프로세스를 넘으면 직렬화가 필요하다. 네트워크는 언제든 끊길 수 있고, 디스크는 가득 찰 수 있다. 경계의 종류에 따라 비용과 실패 양상이 완전히 다르다. 경계가 어디에 있는지 아는 것만으로는 부족하다. 그 경계가 **어떤 성질을 가지는지** 이해해야 비로소 제대로 다룰 수 있다.

경계는 어쩔 수 없이 생긴다. 아이러니하게도 경계를 이해하려는 이 글에서도 마찬가지다. 이제부터 경계가 만들어내는 문제를 코드의 경계, 물리의 경계, 그리고 사람의 경계로 나누어 살펴본다.

# 코드의 경계

첫 번째 범주는 **코드의 경계**다. 이 경계들은 우리가 복잡성을 관리하기 위해 **의식적으로 만든** 것들이다. 함수를 나누고, 추상화를 만들고, 외부 라이브러리에 의존하고, 데이터를 변환한다. 이 모든 행위가 경계를 만들고, 각 경계에서 고유한 문제가 발생한다.

## Caller와 Callee의 경계

가장 원초적인 경계는 **호출하는 쪽(Caller)과 호출당하는 쪽(Callee) 사이**에 존재한다. 하나의 함수가 다른 함수를 호출하는 단순한 행위에서조차 경계 문제가 발생한다.

```kotlin
fun getUser(id: String): User? {
    // 사용자가 없으면 null을 반환할까? 예외를 던질까?
    // 이 결정은 Caller의 삶을 완전히 바꾼다.
}

fun processOrder(userId: String) {
    val user = getUser(userId)
    // user가 null일 수 있다는 것을 알고 있는가?
    // getUser가 예외를 던질 수 있다는 것을 알고 있는가?
    user.name // 💥 NullPointerException
}
```

이 코드에서 문제의 핵심은 **계약(Contract)의 부재** 혹은 **계약의 모호함**이다. `getUser`는 사용자를 찾지 못했을 때 `null`을 반환하는가, 예외를 던지는가? `processOrder`는 그 사실을 알고 있는가? Kotlin의 Nullable 타입(`User?`)은 이 계약을 타입 시스템에 녹여낸 좋은 사례지만, Java 라이브러리와의 경계에서는 이 보호가 무력화되기도 한다. 호출자와 피호출자 사이의 경계에서 이 계약이 명확하지 않으면 문제가 발생한다.

이 문제는 방어적 프로그래밍과 계약에 의한 설계라는 두 가지 철학으로 이어진다. 방어적 프로그래밍은 경계를 불신하는 접근이다. 상대방이 무엇을 보내든 방어적으로 대응한다. 계약에 의한 설계는 경계를 명시적 계약으로 정의하는 접근이다. 계약을 어긴 쪽이 책임을 진다. 어떤 접근이 옳다고 단정할 수는 없지만, 두 접근 모두 **경계에서의 계약**이라는 문제를 해결하려는 시도라는 점에서 공통된다.

{/* TODO: 이미지 — Caller와 Callee 사이의 경계 다이어그램. 양쪽에서 "상대방이 처리하겠지"라고 생각하며 책임이 공중에 떠있는 모습 */}

더 근본적으로 보면, 이 문제는 **책임의 경계** 문제이기도 하다. 입력값의 유효성은 누가 검증해야 하는가? 에러 처리의 책임은 누구에게 있는가? 이런 질문에 명확한 답이 없을 때 버그가 태어난다. 경계에서 책임이 모호해지는 순간, 양쪽 모두 상대방이 처리해줄 것이라 기대하고, 결국 아무도 처리하지 않는 상황이 벌어진다.

## 인터페이스의 경계

Caller-Callee가 함수 레벨의 경계라면, 인터페이스의 경계는 **추상화 계층 사이의 경계**다. 우리는 복잡성을 감추기 위해 추상화를 만들고, 그 추상화의 표면을 인터페이스라 부른다. 문제는 이 추상화가 **완벽하지 않다**는 데 있다.

Joel Spolsky는 이를 **누수되는 추상화의 법칙**이라 불렀다.[^1] 모든 비자명한 추상화는 어느 정도 누수된다. 추상화가 감추려 했던 아래 계층의 복잡성이 경계를 뚫고 올라온다.

```kotlin
// JPA는 SQL을 추상화한다
val users = userRepository.findAllByActiveTrue()

// 하지만 성능 문제가 생기면 결국 SQL을 이해해야 한다
// ORM이라는 경계 아래를 들여다봐야 하는 순간이 온다
@Query("""
    SELECT u FROM User u
    JOIN FETCH u.profile p
    WHERE u.active = true
    AND p.lastLogin > :threshold
""")
fun findActiveUsersWithRecentLogin(
    @Param("threshold") threshold: LocalDateTime
): List<User>
```

{/* TODO: 이미지 — 추상화 계층 다이어그램. 깔끔한 인터페이스 표면 아래로 복잡한 SQL, 네트워크, 바이트 등이 비져나오는(leaking) 모습 */}

ORM은 데이터베이스와 애플리케이션 코드 사이의 경계에 위치한 추상화다. 대부분의 경우 잘 동작하지만, 복잡한 쿼리나 성능 최적화가 필요한 순간 추상화가 누수된다. 개발자는 ORM이 감추려 했던 SQL의 세계를 다시 직면해야 한다. 경계가 완벽하지 않기에 발생하는 문제다.

REST API도 마찬가지다. HTTP라는 프로토콜 위에 리소스라는 추상화를 얹었지만, 복잡한 비즈니스 로직을 CRUD 패턴에 끼워 맞추기 어려운 순간이 온다. GraphQL은 이 문제를 해결하려 했지만, 다시 캐싱이라는 새로운 경계 문제를 만들어냈다. **하나의 경계 문제를 해결하면 다른 경계 문제가 생기는 것**, 이것이 인터페이스 경계의 본질적 어려움이다.

## 의존성의 경계

다음은 **내가 통제하는 코드와 통제하지 못하는 코드의 경계**다. 외부 라이브러리, 외부 서비스, 런타임 환경 등 우리가 직접 작성하지 않은 모든 것은 경계 너머에 존재한다.

Michael Nygard는 저서 Release It!에서 **"Integration Points are the #1 killer"**라고 말했다.[^2] 시스템이 외부와 통합하는 모든 지점은 잠재적 장애 지점이다. 외부 API가 응답하지 않을 때, 라이브러리가 메이저 버전을 올리며 하위호환성을 깨뜨릴 때, 의존하던 서비스가 예고 없이 스펙을 변경할 때. 경계 너머의 변화가 내 코드를 무너뜨린다.

```kotlin
// 어제까지 잘 동작하던 코드
val response = paymentClient.charge(request)
// 외부 결제 API가 응답 필드명을 바꿨다.
// transactionId → txnId
// 내 코드에는 버그가 없는데 시스템이 실패한다.
val transactionId = response.transactionId // 💥 null
```

이 문제가 특히 까다로운 이유는 **경계 너머를 통제할 수 없기 때문**이다. 내 코드에는 버그가 없는데 시스템이 실패한다. 어제까지 잘 돌아가던 코드가 오늘 갑자기 깨진다. 원인을 추적하면 의존하던 무언가가 바뀌었다는 사실을 알게 된다. 의존성의 경계는 **내가 통제할 수 있는 영역의 한계**를 보여준다.

## 표현의 경계

소프트웨어에서 같은 데이터는 경계를 넘을 때마다 다른 형태로 **표현**된다. 이를 **임피던스 불일치**[^4]라 부른다. 원래 전기공학에서 온 용어지만 소프트웨어에서도 정확히 같은 현상이 일어난다.

가장 잘 알려진 예는 객체-관계 불일치다. 애플리케이션은 객체로 세상을 표현하고, 데이터베이스는 테이블과 행으로 세상을 표현한다. 같은 "사용자"라는 개념이 코드에서는 상속과 다형성을 가진 객체이고, 데이터베이스에서는 정규화된 여러 테이블의 조인이다. 이 두 표현 사이를 오갈 때마다 변환이 일어나고, 변환은 정보를 잃거나 왜곡한다.

```kotlin
// 서버: Kotlin 도메인 모델
data class User(
    val id: Long,
    val name: String,
    val createdAt: Instant,       // java.time.Instant
    val profile: Profile          // 중첩 객체
)

// API 경계: JSON 직렬화
// { "id": 1, "name": "...", "created_at": "2024-01-15T09:30:00Z", "profile": { ... } }

// 클라이언트: 또 다른 모델
// { id: number, name: string, createdAt: Date, profile: { bio: string, avatar: string } }
```

{/* TODO: 이미지 — 하나의 User 데이터가 서버(Kotlin 객체) → API(JSON) → 클라이언트(JS 객체) → DB(테이블 행)로 형태가 바뀌며 흐르는 데이터 변환 다이어그램. 각 경계에서 타입과 구조가 달라지는 모습 */}

하나의 User 데이터가 여러 경계를 넘으며 각각 다른 형태로 표현된다. 각 변환 지점에서 타입이 바뀌고(`Instant` → `String` → `Date`), 구조가 바뀌며(객체 그래프 → JSON 트리 → 또 다른 객체 구조), 의미가 미묘하게 달라질 수 있다. 프론트엔드 모델과 백엔드 모델이 일치하지 않아 발생하는 버그는 모두 이 표현의 경계에서 비롯된다.

## 신뢰의 경계

**신뢰의 경계**란 검증된 데이터와 검증되지 않은 데이터가 만나는 지점이다. 경계 안쪽의 데이터는 이미 검증을 거쳤으므로 신뢰할 수 있다. 그러나 경계 바깥에서 들어오는 데이터는 원칙적으로 신뢰할 수 없다.

```kotlin
// 신뢰의 경계를 무시한 코드
fun searchUser(name: String): List<User> {
    val query = "SELECT * FROM users WHERE name = '$name'"
    return jdbcTemplate.query(query, userRowMapper)
}

// name에 "'; DROP TABLE users; --" 가 들어온다면?
```

SQL Injection, XSS, CSRF 같은 보안 취약점의 본질은 모두 **신뢰의 경계를 무시한 것**이다. 외부에서 들어온 데이터를 검증 없이 내부 시스템에 전달한 것, 즉 경계를 넘는 데이터에 대한 불신이 부족했던 것이다.

Michael Nygard는 이를 **"냉소적인 소프트웨어"**라는 개념으로 설명했다.[^3] 좋은 소프트웨어는 냉소적이다. 자기 자신조차 믿지 않으며, 외부에서 오는 모든 것을 의심한다. 이는 비관적인 것이 아니라 현실적인 것이다. 경계 바깥은 언제나 예측 불가능하며, 그 예측 불가능성으로부터 경계 안쪽을 보호하는 것이 견고한 소프트웨어의 조건이다.

{/* TODO: 이미지 — 신뢰의 경계(Trust Boundary) 다이어그램. 안쪽은 "검증된 영역(Trusted Zone)", 바깥은 "검증되지 않은 영역". 경계를 넘어오는 화살표(사용자 입력, 외부 API 응답, 파일 업로드 등)에 검증 게이트가 있는 모습 */}

신뢰의 경계는 보안에만 국한되지 않는다. 외부 API의 응답을 그대로 믿고 사용하다가, 스펙에 없던 필드가 `null`로 오면서 시스템이 터지는 경우도 신뢰의 경계 문제다. **경계 너머에서 오는 모든 것은 의심의 대상**이라는 원칙을 잊으면, 언젠가 반드시 문제가 발생한다.

## 설계와 구현의 경계

아키텍처 다이어그램을 그려본 적이 있는가? 깔끔한 박스와 화살표로 시스템을 표현하면 모든 것이 명확해 보인다. 그런데 실제 코드를 열어보면 다이어그램과는 사뭇 다른 세상이 펼쳐진다. "지도는 영토가 아니다"라는 격언처럼, 설계는 지도이고 코드는 영토다. 지도는 현실을 단순화하고 추상화한 것이므로, 반드시 현실과 차이가 있다. 요구사항이 설계로 번역될 때 일부가 손실되고, 설계가 코드로 구현될 때 또 일부가 손실된다. **경계를 넘을 때마다 정보가 손실**되는 것이다.

{/* TODO: 이미지 — 설계 침식(Design Erosion) 다이어그램. 요구사항 → 설계 → 구현 → 운영으로 이어지는 파이프라인에서, 각 경계를 넘을 때마다 원래 의도(신호)가 조금씩 변형/손실되어 최종 결과와 원래 요구사항 사이에 간극이 생기는 모습 */}

이 경계가 문제가 되는 이유는 손실이 누적되기 때문이다. 요구사항 → 설계 → 구현 → 테스트 → 운영으로 이어지는 각 단계 사이에 경계가 있고, 각 경계에서 조금씩 정보가 변형된다. 최종적으로 운영되는 시스템은 원래 요구사항과 상당한 간극을 가질 수 있다. 이를 일컬어 **설계 침식**이라 부르기도 한다.

디자인 시안과 실제 구현 사이의 괴리도 같은 맥락이다. 디자이너가 그린 시안은 정적이고 이상적이다. 모든 텍스트는 적절한 길이이고, 이미지는 완벽한 비율이며, 네트워크는 항상 빠르다. 하지만 실제 구현에서는 텍스트가 넘치고, 이미지가 깨지며, 로딩 상태와 에러 상태를 처리해야 한다. 이상적 설계와 현실적 구현 사이의 경계에서 수많은 엣지 케이스가 태어난다.

# 물리의 경계

두 번째 범주는 **물리의 경계**다. 코드의 경계가 개발자의 선택에 의해 만들어진다면, 물리의 경계는 **물리적 제약이 강제하는** 것들이다. 비동기 실행은 순서를 보장하지 않고, 규모는 임계점을 넘으면 성질이 바뀌고, 환경은 언제나 다르며, 하나의 작업은 경계를 넘는 순간 쪼개질 수 있다. 이 경계들은 코드를 아무리 읽어봐도 보이지 않지만, 실행 시점에 비로소 드러나기에 더욱 위험하다.

## 시간의 경계

소프트웨어에서 가장 교묘한 경계 중 하나는 **시간**이다. 동기 코드에서는 시간이 선형적으로 흐른다. A가 끝나면 B가 시작되고, B가 끝나면 C가 시작된다. 그러나 비동기의 세계로 넘어가는 순간, 시간은 더 이상 선형적이지 않다.

```kotlin
// 코루틴: 동기적으로 보이지만, 각 suspend 지점 사이에 시간의 경계가 존재한다
suspend fun buildOrderSummary(id: String): OrderSummary {
    val user = userService.getUser(id)
    // ⏳ 이 사이에 user의 상태가 바뀔 수 있다
    val orders = orderService.getOrders(user.id)
    // ⏳ 이 사이에 새로운 주문이 추가될 수 있다
    return createSummary(user, orders)
    // summary는 이미 과거의 스냅샷이다
}
```

코루틴의 `suspend` 지점은 코드를 동기적으로 보이게 만들지만, 실제로는 각 `suspend` 사이에 시간의 경계가 존재한다. 그 경계 사이에서 세상이 바뀔 수 있다. Race condition, 이벤트 순서 역전, Stale data 문제는 모두 이 시간의 경계에서 비롯된다.

{/* TODO: 이미지 — 시간의 경계 타임라인 다이어그램. 서버 A와 서버 B의 시간축이 나란히 있고, 같은 이벤트가 각 서버에서 다른 순서로 도착하는 모습. Clock Drift와 네트워크 지연이 이벤트 순서를 뒤바꾸는 것을 시각화 */}

분산 시스템에서 시간의 경계는 더 극적이다. 서로 다른 서버의 시계는 미세하게 다르고, 네트워크 지연은 이벤트의 순서를 뒤바꾼다. 서버 A에서 먼저 일어난 일이 서버 B에서는 나중에 도착할 수 있다. **물리적 시간과 논리적 시간의 경계**는 분산 시스템의 가장 근본적인 문제 중 하나다.

## 규모의 경계

**작은 규모에서 동작하던 것이 규모가 커지면 깨진다.** 이것은 단순히 성능이 느려진다는 의미가 아니다. 규모가 특정 **임계점**을 넘는 순간, 시스템의 동작 자체가 근본적으로 달라진다.

메모리에 담을 수 있던 데이터가 디스크로 넘어가는 순간, 접근 속도는 수만 배 느려진다. 단일 서버에서 처리하던 요청이 여러 서버로 분산되는 순간, 데이터 일관성이라는 새로운 문제가 등장한다. 하나의 프로세스에서 돌아가던 코드가 네트워크를 사이에 두고 실행되는 순간, 부분 실패라는 개념이 생겨난다.

{/* TODO: 이미지 — 규모의 경계 그래프. X축은 데이터/트래픽 규모, Y축은 복잡도/비용. 선형이 아닌 계단식 또는 지수적으로 증가하며, 임계점(메모리→디스크, 단일→분산 등)에서 급격히 점프하는 모습 */}

이 현상의 핵심은 **비선형성**이다. 규모가 10배가 되면 문제가 10배 어려워지는 것이 아니라 100배, 1000배 어려워질 수 있다. 이는 규모의 경계가 **양적 변화가 아닌 질적 변화**를 가져오기 때문이다. 메모리 안에서의 프로그래밍과 분산 시스템에서의 프로그래밍은 같은 언어를 사용하더라도 본질적으로 다른 활동이다.

흥미로운 점은 이 경계가 **미리 예측하기 어렵다**는 것이다. 어느 지점에서 임계점이 올지, 그때 어떤 문제가 발생할지를 정확히 예측하는 것은 거의 불가능하다. 그래서 규모의 경계는 대부분 사후적으로 발견되며, 그때부터 고통스러운 전환이 시작된다.

## 환경의 경계

**"Works on my machine."** 소프트웨어 역사상 가장 유명한 말일 것이다. 이 말은 환경의 경계를 완벽하게 요약한다. 같은 코드가 다른 환경에서 다르게 동작하는 현상, 이것이 환경의 경계 문제다.

개발 환경과 운영 환경의 차이는 다양한 형태로 나타난다. OS가 다르다(macOS에서 개발하고 Linux에서 배포한다). 런타임 버전이 다르다(로컬은 Node 20인데 서버는 Node 18이다). 환경 변수가 다르다. 네트워크 구성이 다르다. 시간대가 다르다.

```kotlin
// 로컬에서는 완벽하게 동작하는 코드
fun getRegisteredToday(): List<User> {
    val today = LocalDate.now() // 로컬: KST 기준 2024-01-16
    return userRepository.findByCreatedDate(today)
}
// 서버(UTC)에서는 KST 기준 전날의 데이터를 조회한다.
// 같은 코드, 같은 시각, 다른 결과.
```

이 목록에서 하나라도 차이가 나면 버그가 발생할 수 있다. 타임존 차이로 날짜 계산이 하루 밀리거나, 파일 경로의 대소문자 구분 차이로(macOS는 기본적으로 대소문자를 구분하지 않지만 Linux는 구분한다) 파일을 찾지 못하거나, 메모리 제한으로 로컬에서는 발생하지 않던 메모리 부족(OOM)이 운영에서 터지거나.

Docker와 같은 컨테이너 기술은 이 문제를 완화하기 위해 등장했다. 환경의 경계를 좁히려는 시도다. 그러나 컨테이너조차 완벽하지는 않다. 호스트 OS와 컨테이너 OS의 차이, 네트워크 구성의 차이, 스토리지 드라이버의 차이 등 **환경의 경계는 기술이 발전해도 완전히 사라지지 않는다.**

## 원자성의 경계

**"하나의 작업"이 여러 경계를 넘어가야 할 때**, 원자성의 문제가 발생한다. 원자성이란 작업이 전부 성공하거나 전부 실패해야 한다는 것을 말한다. 경계 안에서는 비교적 쉽게 보장할 수 있지만, 경계를 넘으면 급격히 어려워진다.

```kotlin
// 주문 처리: 세 서비스의 경계를 넘어야 하는 하나의 작업
fun processOrder(order: Order) {
    paymentService.charge(order.payment)      // ✓ 성공
    inventoryService.deduct(order.items)       // ✗ 실패!
    notificationService.send(order.userId)     // — 실행되지 않음

    // 결제는 됐는데 재고는 차감되지 않았다.
    // 사용자에게는 어떤 상태를 보여줘야 하는가?
}
```

단일 데이터베이스 안에서라면 트랜잭션으로 원자성을 보장할 수 있다. 그러나 작업이 여러 서비스, 여러 데이터베이스에 걸쳐있다면 이야기가 달라진다. 분산 트랜잭션은 악명 높게 어렵고, 2PC(Two-Phase Commit)는 성능 문제를 일으키며, Saga 패턴은 보상 트랜잭션이라는 복잡성을 더한다. 이 모든 어려움은 **"하나의 작업"이 여러 경계에 걸쳐있기 때문**에 발생한다.

{/* TODO: 이미지 — 원자성이 깨지는 순간을 보여주는 다이어그램. 하나의 작업이 서비스 A, B, C 경계를 넘어가는데, B에서 실패하여 A는 완료, C는 미실행인 불일치 상태 */}

더 일상적인 예를 들면, 파일에 쓰기 작업을 하다가 중간에 프로세스가 죽는 경우도 원자성의 경계 문제다. 메모리(애플리케이션 경계 안)에서는 데이터가 완전하지만, 디스크(경계 밖)에는 절반만 기록된 상태가 된다. 경계를 넘는 순간, 원자성은 더 이상 보장되지 않는다.

# 사람의 경계

마지막 범주는 **사람의 경계**다. 코드의 경계는 개발자가 선택하고, 물리의 경계는 인프라가 강제한다. 하지만 소프트웨어는 결국 **사람이 만들고, 사람이 사용한다.** 조직이 소통하는 방식, 사용자가 시스템을 이해하는 방식. 이런 곳에서 사람이라는 변수가 경계를 만들고, 그 경계에서 고유한 문제가 발생한다.

## 코드와 사람 사이

1968년, Melvin Conway는 다음과 같은 관찰을 발표했다.

> Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. — Melvin Conway

{/* TODO: 이미지 — Conway's Law 다이어그램. 왼쪽에 3개 팀의 조직 구조(소통 경로 포함), 오른쪽에 그와 동일한 구조로 나뉜 시스템 아키텍처. 조직의 경계선과 시스템의 경계선이 거울처럼 일치하는 모습 */}

**콘웨이의 법칙**으로 알려진 이 관찰은 조직의 경계가 곧 시스템의 경계가 된다는 것을 말한다. 세 팀이 따로 일하면 세 개의 컴포넌트가 나오고, 두 팀 사이의 커뮤니케이션이 원활하지 않으면 두 시스템 사이의 인터페이스도 어색해진다. 이는 시스템이 조직의 소통 구조를 반영하기 때문이다.

코드 오너십도 경계 문제다. "이 코드는 누구 것인가?"라는 질문에 명확한 답이 없을 때, 양쪽 팀 모두 손대기를 꺼리는 무주공산이 생긴다. 반대로 여러 팀이 같은 코드를 수정하면 충돌이 발생한다. 코드의 경계와 조직의 경계가 일치하지 않을 때 이런 문제가 나타난다.

지식 사일로는 사람의 경계가 만드는 또 다른 문제다. 특정 시스템을 이해하는 사람이 한 명뿐이라면, 그 사람이 떠나는 순간 경계가 벽이 된다. 코드는 남아있지만 그 코드를 이해하는 맥락은 사라진다. 코드와 사람 사이의 경계에서 **지식이라는 데이터가 손실**된 것이다.

## 사람과 사람 사이

소프트웨어는 코드로 만들어지지만, 그 코드가 무엇을 해야 하는지는 **사람의 말**로 전달된다. 여기서 경계가 생긴다. 기획자가 "간단한 기능 하나만 추가해주세요"라고 말할 때, 그 사람의 머릿속에 있는 그림과 개발자가 떠올리는 그림은 다르다. 기획자에게는 화면 하나지만, 개발자에게는 세 시스템을 관통하는 API 변경일 수 있다. 같은 단어를 쓰지만 서로 다른 것을 상상하는 것, 이것이 사람과 사람 사이의 경계 문제다.

이 문제의 근본에는 **암묵지**가 있다. 소프트웨어 개발에서 가장 중요한 지식 중 상당수는 문서에 적히지 않는다. "왜 이 아키텍처를 선택했는지", "이 코드가 이렇게 복잡한 이유가 무엇인지", "이 엣지 케이스를 왜 특별히 처리하는지". 이런 맥락은 당시 논의에 참여한 사람의 머릿속에만 존재한다. 코드는 **무엇(What)**을 기록하지만, **왜(Why)**는 사람 사이의 대화 속에 남는다. 그 대화에 참여하지 못한 사람에게 코드는 맥락 없는 결과물일 뿐이다.

{/* TODO: 이미지 — 전언 게임(Telephone Game) 다이어그램. 이해관계자 → 기획자 → 디자이너 → 개발자로 이어지는 체인에서, 각 경계를 넘을 때마다 원래 의도가 조금씩 변형되어 최종 결과가 원래 요구와 달라지는 모습 */}

결국 소프트웨어 개발은 일종의 **전언 게임**이다. 이해관계자의 요구가 기획자를 거쳐 디자이너에게, 다시 개발자에게 전달되는 과정에서 매 경계마다 정보가 변형된다. 명시적으로 전달된 내용도 해석이 달라지고, 암묵적으로 전제했던 내용은 아예 전달되지 않는다. 때로는 정보가 의도적으로 공유되지 않기도 한다. 팀 간 경쟁이나 조직 정치가 정보의 흐름을 막으면, 기술적으로는 아무 문제가 없는데도 경계가 벽이 된다. 소프트웨어의 버그 중 상당수가 코드의 실수가 아니라 **소통의 실패**에서 비롯되는 이유다.

# 경계를 다스리는 법

지금까지 소프트웨어 개발에서 마주치는 다양한 경계 문제를 살펴보았다. 코드의 경계, 물리의 경계, 사람의 경계. 어디에나 경계가 있고, 경계마다 새로운 문제가 따라온다. 그렇다면 우리는 어떻게 해야 할까? 경계를 모두 없앨 수는 없을까? 아니면 경계를 더 촘촘하게 만들어야 할까?

여기서 깨달아야 할 중요한 통찰이 있다. **소프트웨어를 만드는 모든 행위는 경계에 대한 선택**이다. 함수를 정의하고, 클래스를 나누고, 서비스를 분리한다. 이 모든 행위는 "여기에 경계를 두겠다"는 의식적인 선택이다. 그리고 역으로, 경계를 긋지 않기로 결정하는 것도 선택이다. 중요한 것은 **그 선택의 의도와 대가를 이해하는 것**이다.

경계를 긋는다는 것은 **복잡성을 두 곳으로 나눈다**는 뜻이다. 내부의 단순함을 얻는 대신, 경계 자체라는 새로운 복잡성을 받아들이는 것이다. 그리고 경계를 긋지 않는다는 것도 마찬가지다. 경계의 관리 비용은 피하지만, 내부의 복잡성은 점점 커진다. 둘 다 선택이며, 둘 다 비용이 따른다.

{/* TODO: 이미지 — 천칭 또는 저울 이미지. 왼쪽 접시에 "경계를 긋지 않음: 내부 복잡성 ↑"이고 오른쪽 접시에 "경계를 음: 경계 관리 비용 ↑" */}

## 숨겨진 경계를 인식하라

경계를 다스리려면, 먼저 경계를 **볼 수 있어야** 한다. 그런데 모든 경계가 눈에 보이는 것은 아니다. 함수 시그니처나 API 스키마처럼 명시적인 경계도 있지만, 아무도 의식하지 못하는 경계도 있다. 두 서비스가 같은 데이터베이스 테이블을 읽고 있다면, 코드상으로는 아무 연결이 없지만 실제로는 강하게 결합되어 있다. 배포 스크립트에 암묵적인 순서 의존성이 있다면, 그것도 경계다. 문서화되지 않은 팀 간의 암묵적 합의도 마찬가지다.

이런 숨겨진 경계를 찾으려면 평소에 보지 않는 곳을 봐야 한다. 때로는 전체를 봐야 할 수도 있다. 데이터는 어디서 어디로 흐르는가? 한쪽의 변화가 어디까지 파급되는가? 이 질문들이 숨겨진 경계를 드러낸다. 보이지 않는 경계는 다스릴 수도 없다.

## 경계를 그어야 할 때

그렇다면 언제 경계를 그어야 할까? 이 질문에 대한 답을 찾기 위해 앞서 만난 문제들로 돌아가보자.

### 서로 다른 이유로 변하는 것 사이

가장 고전적인 기준은 **단일 책임 원칙**[^5]이다. 변화의 이유가 다르면, 경계를 그어야 한다.

```kotlin
// 나쁜 예: 두 가지 변화의 이유가 한 곳에
class UserRepository {
    fun getUser(id: String): User? {
        // 변화의 이유 1: 데이터베이스 스키마가 바뀔 때
        val user = db.query("SELECT * FROM users WHERE id = ?", id)
        // 변화의 이유 2: 사용자 모델의 비즈니스 규칙이 바뀔 때
        user?.isActive = determineUserStatus(user)
        return user
    }
}

// 좋은 예: 경계를 나누어 변화의 이유를 분리
class UserRepository {
    fun getUser(id: String): UserEntity? {
        // 변화의 이유 1: 데이터베이스 스키마
        return db.query("SELECT * FROM users WHERE id = ?", id)
    }
}

class UserService {
    fun enrichUser(entity: UserEntity): User {
        // 변화의 이유 2: 비즈니스 규칙
        return User(entity, isActive = determineUserStatus(entity))
    }
}
```

데이터베이스 스키마가 변할 때와 비즈니스 규칙이 변할 때는 완전히 다른 이유다. 이들 사이에 명확한 경계를 그어야, 한쪽의 변화가 다른 쪽에 파급되지 않는다.

### 서로 다른 팀/소유자가 관리하는 것 사이

앞서 살펴본 콘웨이의 법칙처럼 조직의 경계는 시스템의 경계가 된다. 이것은 문제가 아니라 **역으로 활용할 수 있는 기회**다.

**역 콘웨이 전략**[^6]이라는 개념이 있다. 원하는 시스템 아키텍처를 먼저 정의한 뒤, 조직 구조를 그에 맞게 만드는 것이다. 만약 당신의 팀이 독립적으로 일해야 한다면, 시스템도 그렇게 나뉘어야 한다. 반대로, 만약 결제 팀과 주문 팀이 자주 협력해야 한다면, 그들 사이의 경계는 느슨해야 한다.

```kotlin
// 결제 팀과 주문 팀이 독립적으로 운영할 수 있도록
// 명확한 계약(API)으로 경계를 정의

// PaymentService (결제 팀 소유)
interface PaymentGateway {
    suspend fun charge(request: ChargeRequest): ChargeResult
    suspend fun refund(transactionId: String): RefundResult
}

// OrderService (주문 팀 소유)
class OrderOrchestrator(val paymentGateway: PaymentGateway) {
    suspend fun processOrder(order: Order) {
        // 결제 팀이 정의한 계약을 통해서만 상호작용
        val chargeResult = paymentGateway.charge(order.toChargeRequest())
        // ...
    }
}
```

여러 팀이 함께 일한다면, 팀의 경계를 코드의 경계로 명시하는 것이 중요하다. 이것이 "누가 이 코드를 책임지는가?"라는 질문을 명확히 한다.

### 서로 독립적으로 실패해야 하는 것 사이

**장애 격리**는 분산 시스템의 핵심 원칙이다. 한 부분의 실패가 전체 시스템을 무너뜨려서는 안 된다.

앞서 원자성의 경계에서 결제, 재고 차감, 알림이 서로 다른 서비스에 걸쳐 있는 문제를 살펴보았다. 만약 이들이 같은 프로세스에서 동기적으로 실행된다면, 재고 서비스의 장애가 결제 처리까지 막을 수 있다. 하지만 Saga 패턴처럼 각 단계를 독립적으로 실행하고 실패 시 보상하는 방식으로 분리하면, 재고 서비스가 일시적으로 실패해도 결제는 진행되고, 나중에 재시도할 수 있다. 경계를 그어서 **실패의 전파를 차단**하는 것이다.

### 서로 다른 생명주기/속도로 확장해야 하는 것 사이

"이 기능은 매일 변한다. 저 기능은 반년에 한 번 본다."

이런 상황이 있다면, 경계를 그어야 한다. 빠르게 변하는 부분과 느리게 변하는 부분이 같은 코드에 있으면, 느린 부분이 빠른 부분의 발목을 잡는다.

```kotlin
// 배포 관점에서의 경계

// 빠르게 변하는 부분: 추천 알고리즘 (매주 업데이트)
interface RecommendationEngine {
    fun recommendProducts(userId: String): List<Product>
}

// 느리게 변하는 부분: 상품 기본 정보 (거의 변하지 않음)
class ProductCatalog {
    fun getProduct(id: String): Product { /* */ }
}

// 이 둘을 분리하면:
// - 추천 엔진은 자주 배포 가능
// - 상품 카탈로그는 안정적으로 유지
// - 배포 중 한쪽이 다운되어도 다른 쪽은 영향 없음
```

빠르게 변하는 것들은 자주 배포될 수 있도록 물리적으로 분리해야 한다.

## 경계를 긋지 말아야 할 때

하지만 **경계를 긋는다고 항상 좋은 것만은 아니다.** 경계는 비용을 낸다. 그리고 그 비용이 이득보다 클 수도 있다.

### 항상 함께 변하는 것 사이

"분석해보니 이 두 부분은 항상 함께 변하네."

그렇다면 경계를 그을 필요가 없다. 함께 변하는 것을 강제로 분리하는 것은 불필요한 복잡성만 추가한다.

```kotlin
// 안 좋은 예: 항상 함께 변하는데 분리함

// UserModel (userService에 소유)
data class User(val id: String, val name: String, val email: String)

// UserProfile (profileService에 소유)
data class UserProfile(val bio: String, val avatar: String)

// 비즈니스 로직 변화 사례: "사용자 정보 변경 기능"이 추가됨
// → User도 변경, UserProfile도 변경, API도 변경, DB도 변경
// 경계를 넘어가는 변화가 일어남!

// 좋은 예: 함께 변하니까 함께 두기
class UserService {
    data class User(
        val id: String,
        val name: String,
        val email: String,
        val bio: String,
        val avatar: String
    )

    fun updateUser(id: String, updates: UserUpdates) { /* */ }
}

// 변화가 한 곳에서만 일어남
```

결합이 **반드시 나쁜 것은 아니다.** 함께 변하는 것들을 함께 두는 것이 더 간단할 수 있다.

### 경계의 비용이 이득을 초과할 때

경계를 그으면 구체적인 비용이 발생한다. 같은 프로세스 내 함수 호출은 마이크로초지만 네트워크를 넘으면 밀리초 단위가 된다. 데이터 일관성을 유지하기 위해 분산 트랜잭션이나 Saga 같은 복잡한 해결책이 필요해지고, 여러 서비스의 버전을 맞추며 배포하는 것도 쉽지 않다. 하나의 기능이 여러 서비스에 걸쳐 있으면 버그 추적은 훨씬 어려워진다.

```kotlin
// 현실적인 예: 마이크로서비스의 비용

// 초기 구조: 하나의 모놀리스
class OrderProcessor {
    fun processOrder(order: Order): OrderResult {
        val user = userRepository.getUser(order.userId)      // 메모리: 마이크로초
        val payment = paymentProcessor.process(order)        // 메모리: 마이크로초
        val inventory = inventoryService.deduct(order.items) // 메모리: 마이크로초
        return createResult(user, payment, inventory)
    }
}

// 마이크로서비스로 분리했을 때의 비용
class OrderServiceRpc(
    val userClient: UserServiceClient,           // 네트워크: 10-50ms
    val paymentClient: PaymentServiceClient,     // 네트워크: 10-50ms
    val inventoryClient: InventoryServiceClient  // 네트워크: 10-50ms
) {
    suspend fun processOrder(order: Order): OrderResult {
        // 최악의 경우: 순차 호출이면 150ms
        // 동시 호출이라도 50ms
        // 원래는 마이크로초였던 작업이 이제 밀리초 단위!
        // + 재시도 로직, 타임아웃 처리, 서킷 브레이커, 로깅, 추적...
    }
}
```

마이크로서비스는 훌륭한 도구지만, **항상 가치 있는 것만은 아니다.** 비용과 이득을 객관적으로 비교해야 한다.

### "미래를 위해" 미리 긋는 경계의 위험

**성급한 추상화**는 실제 코드에서 가장 흔하게 마주치는 오버엔지니어링이다.

"나중에 결제 방식이 여러 개가 될 것 같으니, 지금부터 결제 인터페이스를 추상화해야겠다."
"언젠가 다른 DB로 마이그레이션할 수도 있으니, ORM으로 감싸야겠다."

이런 생각은 타당해 보인다. 그런데 문제가 하나 있다. **아직 일어나지 않은 변화를 예측하기는 매우 어렵다.** 예측을 잘못하면, 추상화 자체가 오히려 변화를 방해한다.

```kotlin
// 미래를 위한 과도한 추상화 (YAGNI 위반)

// 지금은 Stripe만 써
interface PaymentProcessor {
    suspend fun process(request: PaymentRequest): PaymentResponse
    suspend fun refund(transactionId: String): RefundResponse
    suspend fun verify(token: String): VerificationResult
    // ... 10개 더
}

class StripePaymentProcessor : PaymentProcessor { /* */ }

// 6개월 뒤: "사실 우린 Stripe만 계속 쓸 거야"
// 이제 이 추상화는 짐만 된다.

// 차라리 처음엔 이렇게:
class StripePaymentClient {
    suspend fun charge(amount: Money, customerId: String): StripeTransaction { /* */ }
    // 꼭 필요한 것만
}

// 나중에 정말 다른 결제사를 써야 하면 그때 추상화해도 늦지 않다.
// 그때는 실제 요구사항을 알고 있으니, 더 정확하게 설계할 수 있다.
```

YAGNI[^7]는 단순한 원칙이지만 강력하다. 현재 필요한 경계만 그으라는 것이다.

### "경계를 긋지 않는다"는 것의 의미

마지막으로, 중요한 구분이 하나 있다. **경계를 긋지 않기로 결정하는 것과 경계에 대해 생각하지 않는 것은 다르다.**

```kotlin
// 이것은 경계에 대해 생각하지 않은 것 (나쁨)
class UserService {
    fun getUser(id: String) { /* */ }
    fun updateUser(id: String, updates: UserUpdates) { /* */ }
    fun sendEmail(userId: String, email: Email) { /* */ }  // 왜 이게 여기?
    fun logActivity(userId: String, action: String) { /* */ } // 왜 이게 여기?
    fun validatePayment(order: Order) { /* */ } // ???
    // 모든 게 여기에 섞여있음
}

// 이것은 의식적으로 경계를 최소화한 것 (좋음)
class UserService {
    fun getUser(id: String): User { /* */ }
    fun updateUser(id: String, updates: UserUpdates): User { /* */ }
    // User 조회와 수정은 항상 함께 변하므로 한 곳에 둔다
}
```

전자는 무질서다. 후자는 의식적인 선택이다. 경계를 긋지 않기로 결정했다면, **왜 긋지 않는지에 대한 이유가 있어야 한다.** "이 둘은 항상 함께 변한다" 또는 "네트워크 호출 비용 때문에 함께 둔다" 같은 이유 말이다.

## 경계를 그었다면 — 잘 관리하는 원칙

경계를 긋겠다고 결정했다면, 그 경계를 제대로 관리해야 한다. 대충 관리되는 경계는 그 자체로 문제가 된다.

### 명시적으로 만들어라

**암묵적 경계가 가장 위험하다.** "이쪽이 뭐고 저쪽이 뭔지 우리끼리는 알잖아"라는 생각은 치명적이다. 팀이 커지고, 시간이 지나고, 사람이 바뀌면 암묵적 경계는 무너진다.

```kotlin
// 나쁜 예: 암묵적 경계
class OrderRepository {
    fun getOrder(id: String): Order? { /* */ }
    // 이건 뭘 반환해? nullable인 이유가 뭐야?
    // 조회 실패와 결제 실패를 구분하나?
}

// 좋은 예: 명시적 경계
sealed class OrderQuery {
    data class Found(val order: Order) : OrderQuery()
    data class NotFound(val orderId: String) : OrderQuery()
    data class Error(val reason: String) : OrderQuery()
}

class OrderRepository {
    suspend fun getOrder(id: String): OrderQuery {
        return when {
            // ...
        }
    }
}

```

타입 시스템, API 스키마, 계약 테스트 같은 도구로 경계의 계약을 **코드에 녹여라.** 문서로 남기지 말고, 컴파일러가 강제하도록.

### 보호하라

경계 너머는 신뢰할 수 없다. 이것을 앞서 **신뢰의 경계**에서 배웠다. 가장 대표적인 방법은 부패 방지 계층을 두는 것이다. 외부 응답을 그대로 내부 모델에 전파하지 않고, 검증과 변환을 거치게 한다.

```kotlin
// 부패 방지 계층: 외부 데이터를 검증하고 변환
class PaymentServiceAdapter(val paymentClient: ExternalPaymentClient) {
    suspend fun charge(request: ChargeRequest): InternalChargeResult {
        val externalResponse = paymentClient.charge(request)

        // 검증: 필수 필드가 있나?
        val txnId = externalResponse.transactionId
            ?: throw InvalidPaymentResponseException("Missing transactionId")

        // 변환: 외부 형식을 내부 형식으로
        return InternalChargeResult(
            transactionId = txnId,
            status = mapStatus(externalResponse.status),
            amount = Money(externalResponse.amount ?: BigDecimal.ZERO)
        )
    }
}
```

이 외에도 회로 차단기로 반복되는 외부 실패가 내부로 전파되지 않도록 차단하고, 멱등성을 보장하여 같은 요청이 반복되더라도 부작용이 발생하지 않도록 하는 것이 경계를 보호하는 핵심 전략이다.

### 마찰을 줄여라

경계는 유지하되, 그것을 **넘는 비용을 최소화하라.** 경계가 많을수록, 그것을 넘는 마찰이 쌓인다.

구체적으로는 공유 스키마를 통해 양쪽이 같은 언어로 대화하도록 하고, 스키마 변경 시 코드를 자동 생성하여 수작업을 줄이고, 경계를 넘는 호출을 추적할 수 있도록 관찰성을 확보해야 한다.

```kotlin
// 관찰성: 경계를 넘는 호출을 추적하고 디버깅할 수 있도록
class ObservableServiceClient(val client: ServiceClient) {
    suspend fun <T> call(
        serviceName: String,
        methodName: String,
        request: Any,
        block: suspend () -> T
    ): T {
        val startTime = System.currentTimeMillis()
        val span = tracer.startSpan("$serviceName.$methodName")

        return try {
            val result = block()
            span.setTag("status", "success")
            result
        } catch (e: Exception) {
            span.setTag("status", "failure")
            span.setTag("error", e::class.simpleName)
            throw e
        } finally {
            val duration = System.currentTimeMillis() - startTime
            span.finish()
            metrics.recordLatency("$serviceName.$methodName", duration)
        }
    }
}
```

경계를 넘는 마찰을 줄이는 핵심은 **사람이 반복적으로 해야 할 일을 줄이는 것**이다. 스키마에서 코드를 생성하고, 추적 ID를 자동으로 전파하고, 경계를 넘는 호출을 한눈에 볼 수 있게 만든다. 경계가 존재하되, 넘는 비용은 최소화하는 것이다.

## 경계의 진화

마지막으로 한 가지 더. 경계는 정적인 것이 아니다. 시스템이 성장하고 이해가 깊어지면, 경계도 변한다.

하나의 전형적인 흐름을 보자. 초기에는 모놀리스가 맞을 수 있다. 요구사항을 충분히 이해하지 못한 상태에서 서비스를 나누면 잘못된 곳에 경계를 긋게 된다. 이 단계에서는 모듈 수준의 논리적 경계만으로 충분하다. 시간이 지나 트래픽이 늘고 팀이 커지면, 특정 모듈이 병목이 되기 시작한다. 그때 해당 모듈을 별도 서비스로 분리하면, 경계의 비용을 감수할 만한 명확한 이유가 생긴다. 또는 반대로, 조직이 변하면서 마이크로서비스로 나눴던 서비스들을 다시 합치는 것이 더 효율적일 수도 있다.

이 과정에서 경계는 한 방향으로만 움직이지 않는다. 분리했다가 합치고, 합쳤다가 다시 나누기도 한다. 중요한 것은 **경계를 의식적으로 관리하는 것**이다. 어제의 올바른 결정이 오늘도 올바른 것은 아니다. 정기적으로 경계를 검토하고, 현재의 맥락에 맞게 재구성해야 한다.

---

# 마치며

Caller와 Callee 사이에서, 데이터가 형태를 바꾸는 곳에서, 비동기 실행이 순서를 뒤집는 곳에서, 코드와 사람이 만나는 곳에서. 경계는 어디에나 있고, 문제는 그 경계에서 피어난다.

그렇다고 경계를 두려워할 필요는 없다. 경계는 복잡한 세상을 다루기 위한 필수적인 도구이며, 경계 없이 소프트웨어를 만들 수는 없다. 중요한 것은 경계의 존재를 **의식**하는 것이다. 경계가 보이면 그 경계에서 어떤 문제가 발생할 수 있는지 예측할 수 있고, 예측할 수 있으면 대비할 수 있다.

다만 한 가지 경계해야 할 것이 있다. 경계를 잘 다루고 있다는 확신이다. 경계는 시스템이 변하고, 조직이 변하고, 요구사항이 변할 때마다 함께 움직인다. "이 구조가 정답이야"라고 믿는 순간, 이미 변해버린 경계를 알아채지 못하게 된다. 경계를 다스리는 일에 완성이란 없다. 언제나 변화할 준비가 되어 있어야 한다.

지금 당신이 겪고 있는 문제가 있다면, 한번 물어보자. 혹시 그 문제, 경계에서 오고 있지는 않은가?

[^1]: Joel Spolsky, "The Law of Leaky Abstractions", 2002
[^2]: Michael T. Nygard, "Release It! Design and Deploy Production-Ready Software", 2007
[^3]: Nygard는 이 개념을 "enterprise software must be cynical"이라 표현했다. 좋은 소프트웨어는 나쁜 일이 일어날 것을 예상하며, 그것이 실제로 일어나도 놀라지 않는다.
[^4]: Impedance Mismatch. 원래 전기공학에서 회로 간 임피던스가 맞지 않아 신호가 손실되는 현상을 가리키는 용어다.
[^5]: Single Responsibility Principle(SRP). Robert C. Martin이 정립한 SOLID 원칙 중 하나로, 모듈은 변경의 이유가 하나여야 한다는 원칙이다.
[^6]: Inverse Conway Maneuver. 원하는 아키텍처에 맞춰 조직 구조를 설계하는 전략. Conway의 법칙을 역으로 활용한다.
[^7]: You Aren't Gonna Need It. 익스트림 프로그래밍(XP)에서 유래한 원칙으로, 실제로 필요해질 때까지 기능을 추가하지 말라는 것이다.
