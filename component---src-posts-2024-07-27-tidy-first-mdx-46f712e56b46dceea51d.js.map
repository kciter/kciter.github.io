{"version":3,"file":"component---src-posts-2024-07-27-tidy-first-mdx-46f712e56b46dceea51d.js","mappings":"8PAGA,SAASA,EAAkBC,GACzB,MAAMC,EAAcC,OAAOC,OAAO,CAChCC,EAAG,IACHC,OAAQ,SACRC,EAAG,IACHC,GAAI,KACJC,GAAI,OACHC,EAAAA,EAAAA,KAAsBT,EAAMU,YAC/B,OAAOC,EAAAA,cAAoBA,EAAAA,SAAgB,KAAMA,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,WAAYO,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,SAAU,gHAAiHM,EAAAA,cAAoBV,EAAYK,EAAG,CAChTM,KAAM,2CACNC,IAAK,gCACJ,cAAe,KAAMF,EAAAA,cAAoBV,EAAYK,EAAG,CACzDM,KAAM,4CACNC,IAAK,gCACJ,aAAc,0DAA2D,KAAMF,EAAAA,cAAoBV,EAAYM,GAAI,CACpHO,GAAI,MACHH,EAAAA,cAAoBV,EAAYK,EAAG,CACpCM,KAAM,OACL,OAAQ,KAAMD,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,UAAWO,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,6BAA8B,uCAAwCM,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,gBAAiB,yDAA0D,KAAMM,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,+KAAgL,KAAMO,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,0HAA2H,KAAMO,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,4GAA6GO,EAAAA,cAAoBV,EAAYK,EAAG,CACx3BM,KAAM,qDACNC,IAAK,gCACJ,aAAc,QAASF,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,0BAA2B,kBAAmB,KAAMM,EAAAA,cAAoBV,EAAYM,GAAI,CAC9JO,GAAI,gBACHH,EAAAA,cAAoBV,EAAYK,EAAG,CACpCM,KAAM,iBACL,iBAAkB,KAAMD,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,iGAAkG,KAAMO,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,wCAAyCO,EAAAA,cAAoBV,EAAYO,GAAI,KAAM,8BAA+B,cAAeG,EAAAA,cAAoB,MAAO,KAAM,0BAA2B,kHAAmHA,EAAAA,cAAoBV,EAAYK,EAAG,CACtiBM,KAAM,8EACNC,IAAK,gCACJ,MAAO,kBAAmB,KAAMF,EAAAA,cAAoBV,EAAYM,GAAI,CACrEO,GAAI,OACHH,EAAAA,cAAoBV,EAAYK,EAAG,CACpCM,KAAM,QACL,QAAS,KAAMD,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,gBAAiBO,EAAAA,cAAoBV,EAAYK,EAAG,CAC7GM,KAAM,0FACNC,IAAK,gCACJ,qBAAsB,0DAA2DF,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,YAAa,2DAA4D,KAAMM,EAAAA,cAAoBV,EAAYG,EAAG,KAAM,iDAAkDO,EAAAA,cAAoBV,EAAYI,OAAQ,KAAM,mCAAoC,mEAChY,CAKA,UAJA,SAAoBL,QAAK,IAALA,IAAAA,EAAQ,CAAC,GAC3B,MAAOe,QAASC,GAAad,OAAOC,OAAO,CAAC,GAAGM,EAAAA,EAAAA,KAAsBT,EAAMU,YAC3E,OAAOM,EAAYL,EAAAA,cAAoBK,EAAWhB,EAAOW,EAAAA,cAAoBZ,EAAmBC,IAAUD,EAAkBC,EAC9H,C,qEChBA,MAAMiB,EAAkB,CAAC,EAEnBC,EAAa,gBAAoBD,GAUhC,SAASE,EAAiBT,GAC/B,MAAMU,EAAoB,aAAiBF,GAG3C,OAAO,WACL,WAEE,MAA0B,mBAAfR,EACFA,EAAWU,GAGb,IAAIA,KAAsBV,EACnC,GACA,CAACU,EAAmBV,GAExB,C","sources":["webpack://kciter.so/./src/posts/2024-07-27-tidy-first.mdx","webpack://kciter.so/./node_modules/.pnpm/@mdx-js+react@3.0.1_@types+react@18.2.79_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    a: \"a\",\n    h1: \"h1\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"이 책은... \", React.createElement(_components.strong, null, \"매우 얇다\"), \". 그것이 장점이자 단점이다. 장점은 빠르게 읽을 수 있다는 것이고, 단점은 내용이 얕다는 것이다. 이 책을 집필한 켄트 백은 의심할 여지 없이 소프트웨어 업계에선 유명한 인물이다. 그의 저서인 \", React.createElement(_components.a, {\n    href: \"https://m.yes24.com/Goods/Detail/2126201\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"익스트림 프로그래밍\"), \"과 \", React.createElement(_components.a, {\n    href: \"https://m.yes24.com/Goods/Detail/12246033\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"테스트 주도 개발\"), \"은 많은 개발자들에게 영감을 주었고, 이 책도 그와 비슷한 영감을 주지 않을까 기대하면서 읽었다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"내용\"\n  }, React.createElement(_components.a, {\n    href: \"#내용\"\n  }, \"내용\")), \"\\n\", React.createElement(_components.p, null, \"켄트 백은 '\", React.createElement(_components.strong, null, \"괴짜들이 세상에서 안전하다고 느끼도록 돕는 일\"), \"'이 자신의 개인적인 사명이라 한다. 그렇기 때문인지 이 책에선 \", React.createElement(_components.strong, null, \"안전하게 코딩하는 방법\"), \"에 대해 다루고 그것을 Tidy First?, 정리를 할지 판단하는 것으로 가능하다고 주장한다.\"), \"\\n\", React.createElement(_components.p, null, \"책의 내용은 총 세 개 파트로 나뉘는데, 첫 파트는 코드 레벨에서 정리하는 방법을 다루고 있다. 유명한 Guard Clause 패턴이나 주석에 대한 자신의 견해, 여러 리팩토링 기법을 설명하며 지저분한 코드를 발견했다면 코드를 정리하라고 주장한다. 주로 리팩토링과 관련된 책에서 자주 볼 수 있는 내용이다.\"), \"\\n\", React.createElement(_components.p, null, \"두 번째 파트는 코드 정리를 언제 하면 좋을지, 설계에 대한 변경을 어떻게 정리할지에 대해 다루고 있다. 켄트 백의 경험에서 우러나오는 정리 시기와 자주 들을 수 있는 결합도와 응집도에 대한 설명을 볼 수 있다.\"), \"\\n\", React.createElement(_components.p, null, \"마지막 파트는 정리를 왜 해야하는가를 다룬다. 여기선 정리에 대한 이야기를 비용에 빗대서 설명하며 정리를 미룰수록 변화에 대응하는 비용이 증가할 수 있다고 주장한다. 이전에 마틴 파울러가 \", React.createElement(_components.a, {\n    href: \"https://youtu.be/mNPpfB8JSIU?feature=shared&t=1510\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"리팩토링의 중요성\"), \"에 대해 \", React.createElement(_components.strong, null, \"경제성이 리팩토링을 해야하는 유일한 이유\"), \"라고 말한 것이 생각났다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"좋았던-점과-아쉬운-점\"\n  }, React.createElement(_components.a, {\n    href: \"#좋았던-점과-아쉬운-점\"\n  }, \"좋았던 점과 아쉬운 점\")), \"\\n\", React.createElement(_components.p, null, \"좋은 점은 켄트 백이 오랫 동안 쌓아온 경험과 가치관을 매우 빠르게 읽을 수 있다는 점이다. 앉은 자리에서 다 읽고 한 번 더 회독하더라도 하루가 걸리지 않을 것이다.\"), \"\\n\", React.createElement(_components.p, null, \"아쉬운 점은 챕터마다 내용이 너무 빈약하다는 것이다. 예를 들어, \", React.createElement(_components.em, null, \"챕터 4, 새로운 인터페이스로 기존 루틴 부르기\"), \"에서 통로 인터페이스\", React.createElement(\"sup\", null, \"pass-through interface\"), \"라는 용어를 사용하는데, 여기서 말하는 인터페이스가 문법 상 인터페이스를 말하는지, 아니면 단순 함수 명세를 말하는지 알 수가 없다. 이런 부분이 아쉽다. 나만 이렇게 느낀 것이 아닌건지 이에 대해 \", React.createElement(_components.a, {\n    href: \"https://tidyfirst.substack.com/p/request-for-examples-pass-through/comments\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"질문\"), \"하는 경우도 볼 수 있다.\"), \"\\n\", React.createElement(_components.h1, {\n    id: \"마치며\"\n  }, React.createElement(_components.a, {\n    href: \"#마치며\"\n  }, \"마치며\")), \"\\n\", React.createElement(_components.p, null, \"조금 인상 깊었던 것은 \", React.createElement(_components.a, {\n    href: \"https://www.amazon.com/Structured-Design-Fundamentals-Discipline-Computer/dp/0138544719\",\n    rel: \"nofollow noopener noreferrer\"\n  }, \"Structured Design\"), \"이라는 책이 여러 번 언급되는데, 이 책을 나도 읽었다는 점이다. 켄트 백이 느꼈던 점과 유사하게 \", React.createElement(_components.strong, null, \"기본은 정확하다\"), \"라는 것을 느꼈다. 중요한 가치는 기술이 발전하고 여러 기교가 등장하더라도 변하지 않는다는 것이다.\"), \"\\n\", React.createElement(_components.p, null, \"이 책도 그러한 가치를 담고 있는 책이라고 생각한다. 정리를 먼저 해야하는 이유는 \", React.createElement(_components.strong, null, \"안전한 코딩을 위해서이며 그것은 경제성으로 이어진다는 것\"), \"이 핵심이다. 이런 핵심은 소프트웨어를 제작해서 판매하는 사람이라면 누구나 인정할 수 밖에 없는 기본적인 가치다.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","/**\n * @typedef {import('mdx/types.js').MDXComponents} MDXComponents\n * @typedef {import('react').Component<{}, {}, unknown>} Component\n * @typedef {import('react').ReactNode} ReactNode\n */\n\n/**\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Readonly<MDXComponents>} currentComponents\n *   Current components from the context.\n * @returns {MDXComponents}\n *   Additional components.\n *\n * @typedef Props\n *   Configuration for `MDXProvider`.\n * @property {ReactNode | null | undefined} [children]\n *   Children (optional).\n * @property {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context (default: `false`).\n */\n\nimport React from 'react'\n\n/** @type {Readonly<MDXComponents>} */\nconst emptyComponents = {}\n\nconst MDXContext = React.createContext(emptyComponents)\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Readonly<MDXComponents> | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that creates them (optional).\n * @returns {MDXComponents}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(\n    function () {\n      // Custom merge via a function prop\n      if (typeof components === 'function') {\n        return components(contextComponents)\n      }\n\n      return {...contextComponents, ...components}\n    },\n    [contextComponents, components]\n  )\n}\n\n/**\n * Provider for MDX context.\n *\n * @param {Readonly<Props>} properties\n *   Properties.\n * @returns {JSX.Element}\n *   Element.\n * @satisfies {Component}\n */\nexport function MDXProvider(properties) {\n  /** @type {Readonly<MDXComponents>} */\n  let allComponents\n\n  if (properties.disableParentContext) {\n    allComponents =\n      typeof properties.components === 'function'\n        ? properties.components(emptyComponents)\n        : properties.components || emptyComponents\n  } else {\n    allComponents = useMDXComponents(properties.components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    properties.children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","strong","a","h1","em","_provideComponents","components","React","href","rel","id","wrapper","MDXLayout","emptyComponents","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}