{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-04-10-mcp-from-ux-perspective-mdx","path":"/posts/mcp-from-ux-perspective/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n항상 떠들썩한 IT 업계에서 최근 가장 뜨거운 화두는 단연코 MCP(Model Context Protocol)라고 할 수 있습니다. 이 MCP에 대해서는 놀랍다, 재밌다 같은 감상부터 생산성 증대, 새로운 방식의 툴링 등 긍정적인 의견과 그냥 API를 OpenAPI처럼 열어둔 것에 불과하다던가 보안 이슈가 있다던가 하는 부정적인 의견도 많습니다.\n\n저 또한 MCP를 직접 만들어보며 굉장히 흥미롭다고 생각했고, 이번 글에서는 기술적인 것보다 UX(사용자 경험)라는 조금 다른 관점에서 이야기해보려 합니다.\n\n# 전산화 시대의 UX\n\n조금 과거로 돌아가보면, 전산화 시대는 컴퓨터가 등장하면서 시작됐습니다. 이 시기에는 컴퓨터가 단순히 계산을 수행하는 도구로 사용되었고, 사용자와의 상호작용은 주로 명령어 입력과 결과 출력으로 이루어졌습니다. 이때의 UX는 사용자가 명령어를 정확히 입력해야만 원하는 결과를 얻을 수 있었고, 이는 사용자에게 큰 부담이었습니다.\n\n시간이 지나 GUI[^1]가 등장하면서 사용자와의 상호작용 방식이 변화했습니다. 이 당시의 UX는 **사용자에게 원하는 것을 제공하기 위해 프로세스를 이해하고 따라가도록 요구**했습니다. 그러다보니 전체 프로세스가 어떻게 이뤄지는지, 사용자가 현재 어떤 프로세스에 위치하는지에 대해 정확히 알려줄 필요가 있었습니다. 예를 들어, 오늘날 사용자가 스마트폰 앱을 통해 음식 배달을 하기 위해선 1) 먹을 것을 검색하고, 2) 품목과 수량을 정하고, 3) 결제하는 절차를 사용자가 알아야 합니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/stepper-ux.png\" caption=\"프로세스 기반 UX\" />\n\n이렇게 GUI가 등장하고 계속된 실험과 통계로 사용자 경험은 크게 향상됐지만, 여전히 사용자는 어느정도 시스템의 동작 원리를 이해해야 했고 이는 서비스를 이용할 때 가장 부담스러운 요소입니다. 지금에와서는 많은 사용자들이 이러한 UX에 학습되어 있기에 **대부분의 서비스가 표준적인 GUI를 제공하는 방식으로 UX를 설계**[^2]합니다. 하지만 이러한 GUI에 익숙하지 않은 노인 세대 등 IT 취약 계층은 여전히 서비스 사용에 불편함을 느끼고 있습니다. 즉, **전산화 시대의 UX는 사용자에게 시스템의 동작 원리를 이해하도록 요구하는 UX**입니다.\n\n# 좋은 UX란 무엇인가?\n\n개인적으로 좋은 UX의 핵심은 **경계를 허무는 것**에 있다고 생각합니다. 현실 세계의 UX를 생각해봅시다. 우리는 맥도날드에서 메뉴를 주문할 때 직원에게 \"더블쿼터치즈버거 세트 하나 주세요\"라고 말합니다. 이때 우리는 단순히 자연어로 대화하고 주문을 처리합니다. 이 방식이 그다지 어렵지 않고 문제가 생길 경우 직원이 친절하게 설명도 해줍니다. 저는 이러한 형태를 경계가 없는 UX라고 생각합니다. 이 방식이 기존 **전산화 UX와 다른 점은 사용자가 미리 절차와 상태를 인지하지 않아도 된다는 점**입니다. 분명히 구조적으로 절차는 존재하지만, 이를 정확히 따르지 않아도 됩니다. 이로 인해 별도의 학습 없이도 어떤 상태인지를 확실히 인지할 수 있습니다. 따라서 **좋은 UX는 사용자가 큰 노력 없이 자신이 아는 지식만으로 이용할 수 있는 것**이라고 생각합니다.\n\n그렇지만 현실 세계에서도 어려운 UX가 있습니다. 바로 서브웨이 입니다. 서브웨이는 사용자가 원하는 대로 샌드위치를 만들 수 있도록 다양한 재료를 제공합니다. 하지만 이로 인해 사용자는 절차를 미리 파악해야 하고 어려움을 느끼게 됩니다. 여기서는 주문을 위한 명확한 절차가 존재하고 이를 경계라고 생각합니다. 즉, 현실 세계라하여 무조건 좋은 UX는 아닙니다. 결국 얼마나 자연스럽게 경계를 허무는가. 그것이 좋은 UX의 핵심이라고 생각합니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/subway.jpg\" caption=\"처음가면 무조건 얼타는 곳\" maxWidth=\"440px\" />\n\n전산화 UX에는 경계를 허무는 일이 없을까요? 물론 있습니다. 대표적인 사례로 토스가 있습니다. 토스는 사용자가 큰 노력 없이 원하는 것을 얻을 수 있도록 **최소한의 복잡성만을 남기도록 절차를 통합**하는 일을 정말 잘한다고 생각합니다. 저는 이러한 UX가 경계를 허무는 것에 가깝다고 생각합니다. 그리고 이는 분명 많은 실험과 데이터 분석을 통해 구조적으로 도출된 결과[^3]일 것입니다.\n\n그럼에도 불구하고 현실 세계에서 제공하는 경험을 전산 시스템에서 제공하는 것은 어렵습니다. 수많은 예외 상황이 존재하고 사람에 따라 다르게 반응하는 비결정론적인 문제는 기계가 처리하기엔 어렵기 때문에 결국 프로세스가 있을 수 밖에 없습니다. 그렇기에 결국 여러 법칙과 데이터, 실험을 통해 가장 좋은 프로세스를 도출해내는 것이 전산화 UX의 목표가 됐다고 할 수 있습니다.\n\n# MCP의 탄생과 새로운 UX\n\n지금은 이야기가 달라졌습니다. 본래 기계적인 것은 사람과 거리가 멀었지만, LLM 기반 AI가 나오면서 사람과 기계 간의 소통 방식이 변화했습니다. LLM은 자연어를 이해하고 생성할 수 있는 능력을 가지고 있어 사용자가 자연스럽게 기계와 소통할 수 있도록 도와줍니다.\n\n다만 LLM은 굉장히 광범위한 범위에서 대화를 진행하기 때문에 적절한 맥락을 제공할 필요가 있었습니다. 또한, 특정 데이터를 알기 위해서는 사용자가 명시적으로 프롬프트로 제공해야 했고, 앞서 예시로 설명한 음식 주문과 같은 기능을 실현할 수는 없었습니다.\n\n하지만 **MCP가 등장하고 나서는 LLM이 스스로 상황을 이해하고, 필요한 프로세스를 MCP 툴을 통해 진행**할 수 있게 되었습니다. 이로인해 기존 전통적인 전산화 UX의 경계는 완전히 허물어졌습니다. 사용자는 더 이상 시스템의 동작 원리를 이해할 필요가 없고, 단순히 자연어로 질문하면 됩니다. 예를 들어, \"만두 주문해줘\"라고 말하면 LLM이 자동으로 필요한 정보를 수집하고 주문을 진행할 수 있습니다. 이에 대한 시나리오를 간단하게 구현해봤을 때 다음과 같이 진행할 수 있었습니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/mcp-ux.png\" caption=\"MCP를 이용한 주문 배달 시나리오\" expandable />\n\n정말 대화하는 것처럼 자연스럽게 주문, 결제까지 진행할 수 있었습니다. 이때 사용자로서 전혀 시스템에 대한 이해가 필요하지 않았습니다. 사용자는 더 이상 복잡한 명령어를 입력하거나 프로세스를 이해할 필요 없이, 자연어로 질문하고 대답을 받을 수 있습니다. 즉, **사람과 시스템의 경계를 허물어버린 것**입니다.\n\n이런 경험을 느낀 후 앞으로 소프트웨어가 제공하는 UX 방식이 많이 달라질 수 도 있겠다고 생각했습니다. 어쩌만 미래엔 스마트폰을 열면 앱 리스트가 보이는 것이 아니라, 텍스트 박스 혹은 마이크 버튼만 보일지도 모르겠습니다.\n\n# 악용될 여지는?\n\n기존 UX에도 다크 패턴이 존재했습니다. 다크 패턴은 사용자가 실수로 잘못된 행동을 하도록 유도하여, 시스템이 원하는 방향으로 사용자를 이끌어가는 UX입니다.\n\n<Image src=\"/images/2025-04-10-mcp-from-ux-perspective/ux-dark-pattern.png\" caption=\"사용자의 실수를 유도하는 다크 패턴\" />\n\nMCP 기반 UX는 기존 전산화 UX보다 훨씬 자연스럽고 인간적인 상호작용을 제공합니다. 그러나 아이러니하게도, 이 자연스러움이 **악용되면 더 교묘한 UX 다크 패턴**으로 발전할 수도 있습니다. 예를 들어, 사용자가 \"저렴한 만두 추천해줘\"라고 말했을 때, LLM이 고의적으로 수수료가 높은 제휴 음식점을 추천할 수 있습니다. 이 경우 사용자는 시스템이 **중립적인 추천을 했다고 착각하지만**, 실제로는 시스템이 은밀하게 의도한 방향으로 행동을 유도받은 셈입니다.\n\n또한, 자연어 인터페이스에서는 선택지가 명시적으로 보이지 않기 때문에 사용자가 **다른 옵션의 존재 자체를 인식하지 못할 가능성**도 큽니다. 예전에는 'A와 B 중에서 선택하세요'라고 명확하게 보여주었다면, 이제는 시스템이 A만 말해주는 것이죠. 이처럼 **선택의 맥락을 숨기는 다크 패턴**이 등장할 수도 있습니다.\n\n# 마치며\n\n정리하자면 MCP는 기존 전산화 UX의 경계를 허물고, 사용자가 시스템과 자연스럽게 상호작용할 수 있는 새로운 UX를 제공합니다. 이는 사용자가 시스템의 동작 원리를 이해하지 않고도 원하는 작업을 수행할 수 있도록 도와줍니다. 하지만 이러한 변화는 긍정적인 면만 있는 것은 아닙니다. MCP 기반 UX는 다크 패턴을 더욱 교묘하게 만들 수 있는 가능성도 내포하고 있다고 생각합니다.\n\nMCP에 대해서는 아직도 많은 이야기가 오가고 있습니다. 앞으로 다른 방향으로 진화할 수도 있고, MCP 대신 다른 표준으로 대체될 수도 있습니다. 하지만 MCP는 기술적인 의의보다는 새로운 사용자 경험 표준에 대한 가능성을 보여주었다고 생각합니다.\n\n[^1]: Graphical User Interface\n[^2]: 제이콥의 법칙\n[^3]: 테슬러의 법칙\n","tableOfContents":{"items":[{"url":"#전산화-시대의-ux","title":"전산화 시대의 UX"},{"url":"#좋은-ux란-무엇인가","title":"좋은 UX란 무엇인가?"},{"url":"#mcp의-탄생과-새로운-ux","title":"MCP의 탄생과 새로운 UX"},{"url":"#악용될-여지는","title":"악용될 여지는?"},{"url":"#마치며","title":"마치며"}]},"excerpt":"항상 떠들썩한 IT 업계에서 최근 가장 뜨거운 화두는 단연코 MCP(Model Context Protocol)라고 할 수 있습니다. 이 MCP에 대해서는 놀랍다, 재밌다 같은 감상부터 생산성 증대, 새로운 방식의 툴링 등 긍정적인 의견과 그냥…","fields":{"slug":"/posts/mcp-from-ux-perspective","date":"2025-04-10"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","categories":"article","tags":["ai","mcp","ux"],"image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-26","slug":"/posts/how-to-build-an-agent"},"frontmatter":{"title":"AI 에이전트를 만드는 방법","image":"/images/2025-04-26-how-to-build-an-agent/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-02","slug":"/posts/modeling-series-measure"},"frontmatter":{"title":"모델링 시리즈: 측도","image":"/images/2025-05-02-modeling-series-measure/thumbnail.png"}}},{"node":{"fields":{"date":"2025-05-06","slug":"/posts/modeling-series-temporal"},"frontmatter":{"title":"모델링 시리즈: 시간","image":"/images/2025-05-06-modeling-series-temporal/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/mcp-from-ux-perspective","frontmatter":{"title":"UX 관점에서 바라보는 MCP","categories":"article","tags":["ai","mcp","ux"],"image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}