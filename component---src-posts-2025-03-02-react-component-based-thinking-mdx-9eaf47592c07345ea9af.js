"use strict";(self.webpackChunkkciter_so=self.webpackChunkkciter_so||[]).push([[9211,9859,565,6296,6601,7087,3974,871,8750,7283,8639,5513,7345,2449,7822,2764,4103,5481,2897,2301,5128,483,2619,193,3211,5109,727],{2875:function(e,n,t){t.r(n);var l=t(9128),r=t(9474),a=t(5799);function c(e){const n=Object.assign({p:"p",strong:"strong",h1:"h1",a:"a",ul:"ul",li:"li",h2:"h2"},(0,l.R)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.p,null,"컴포넌트는 React를 이용하여 프론트엔드 개발을 한다면 가장 중요한 개념이라 할 수 있다. 컴포넌트를 단순히 UI를 구성하는 단위라고 생각할 수 있지만, 사실 UI를 포함하여 이벤트 처리, 상태 관리, 통신 등 많은 부분을 컴포넌트가 담당한다. 로직을 컴포넌트로부터 아무리 잘 분리하더라도 결국 최종적으로 사용자는 컴포넌트를 통하기 때문에 좋은 제품을 만들고 싶다면 컴포넌트에 대한 이해가 필수적이다."),"\n",r.createElement(a.A,{src:"/images/2025-03-02-react-component-based-thinking/user-meets-components.png",caption:"사용자는 반드시 컴포넌트를 통한다"}),"\n",r.createElement(n.p,null,"앞서 말한 것처럼 ",r.createElement(n.strong,null,"React의 컴포넌트는 UI 뿐만 아닌 사용자가 시스템과 상호작용하는 모든 부분을 담당"),"한다. 이번 글에서는 React 컴포넌트를 어떻게 바라보고 어떤 것이 중요한지에 대해 알아볼 것이다."),"\n",r.createElement(n.h1,{id:"컴포넌트를-바라보는-시각"},r.createElement(n.a,{href:"#컴포넌트를-바라보는-시각"},"컴포넌트를 바라보는 시각")),"\n",r.createElement(n.p,null,"흔히 React에서 컴포넌트는 UI를 구성하는 단위로 생각되지만 본래 프로그래밍에서 컴포넌트라는 개념은 조합과 재사용이 가능한 객체를 의미한다. 사실 React 컴포넌트는 UI를 빼고 생각하는 것이 더 중요하다. UI는 단지 컴포넌트가 하는 일 중 하나일 뿐이다. 그런 측면에서 생각했을 때 컴포넌트는 다양한 관점으로 바라볼 수 있고 그에 따라 구현이 달라질 수 있다."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"컴포넌트는 로직과 뷰의 조합이다."),"\n",r.createElement(n.li,null,"컴포넌트는 요소와 스타일의 조합이다."),"\n",r.createElement(n.li,null,"컴포넌트는 서버 상태를 반영하는 뷰다."),"\n",r.createElement(n.li,null,"컴포넌트는 사용자 이벤트를 처리하는 통로다."),"\n",r.createElement(n.li,null,"컴포넌트는 상태를 직접 제어할 수 있는 것과 아닌 것으로 나뉜다."),"\n",r.createElement(n.li,null,"컴포넌트는 유한 상태 머신이다."),"\n",r.createElement(n.li,null,"..."),"\n"),"\n",r.createElement(n.p,null,"위처럼 컴포넌트는 관점에 따라 다르게 묘사할 수 있다. 왜 관점이 달라질까? 그 이유는 목적이 다르기 때문이다. 즉, 컴포넌트는 ",r.createElement(n.strong,null,"목적에 따라 추성화"),"가 가능하다."),"\n",r.createElement(n.h2,{id:"컴포넌트-분해하기"},r.createElement(n.a,{href:"#컴포넌트-분해하기"},"컴포넌트 분해하기")),"\n",r.createElement(n.p,null,"추상화를 잘하기 위해선 목적에 따라 필요한 것을 조합할 수 있어야 한다. 그러기 위해선 무엇을 조합할 수 있는지 알아야 한다. 컴포넌트를 분해하는 것은 이러한 관점에서 시작된다. 일단 분해하여 무엇이 있는지 알면 목적에 따라 필요한 것을 조합할 수 있게 된다."),"\n",r.createElement(n.p,null,"[컴포넌트 구성 요소 이미지]"),"\n",r.createElement(n.p,null,"뷰                              데이터                       로직\n요소 속성 텍스트 이벤트 토큰        Props 상태                 이벤트핸들러 라이프사이클 사이드이펙트"),"\n",r.createElement(n.p,null,"생각보다 컴포넌트를 구성하는 것은 많다."),"\n",r.createElement(n.p,null,"컴포넌트는 크게 이름, UI, 데이터, 상태, 이벤트 핸들러, 라이프사이클, 사이드 이펙트로 구성된다. 각 구성 요소는 또 세세하게 나누는 것이 가능하다."),"\n",r.createElement(n.p,null,"이렇게 나뉜 구성 요소 중 목적에 따라 필요한 것을 조합하여 원하는 컴포넌트를 만들 수 있다. 예를 들어보면 Headless 컴포넌트는 스타일 요소를 완전히 배제한 컴포넌트라고 할 수 있다. 또 다른 예로 고차"),"\n",r.createElement(n.p,null,"위 이미지를 보았을 때 컴포넌트는 다음과 같은 요소로 구성되어 있다."),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"UI","\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"요소 (DOM Element)","\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"속성 (Attribute)"),"\n",r.createElement(n.li,null,"텍스트"),"\n",r.createElement(n.li,null,"이벤트"),"\n"),"\n"),"\n",r.createElement(n.li,null,"토큰 (CSS)"),"\n"),"\n"),"\n",r.createElement(n.li,null,"상태"),"\n",r.createElement(n.li,null,"이벤트 핸들러"),"\n",r.createElement(n.li,null,"라이프사이클"),"\n",r.createElement(n.li,null,"Props"),"\n"),"\n",r.createElement(n.h2,{id:"컴포넌트간-협력"},r.createElement(n.a,{href:"#컴포넌트간-협력"},"컴포넌트간 협력")),"\n",r.createElement(n.h2,{id:"컴포넌트-분류"},r.createElement(n.a,{href:"#컴포넌트-분류"},"컴포넌트 분류")),"\n",r.createElement(n.h1,{id:"컴포넌트-평가"},r.createElement(n.a,{href:"#컴포넌트-평가"},"컴포넌트 평가")),"\n",r.createElement(n.h2,{id:"컴포넌트의-사회성"},r.createElement(n.a,{href:"#컴포넌트의-사회성"},"컴포넌트의 사회성")),"\n",r.createElement(n.h2,{id:"컴포넌트의-신뢰성"},r.createElement(n.a,{href:"#컴포넌트의-신뢰성"},"컴포넌트의 신뢰성")),"\n",r.createElement(n.h2,{id:"컴포넌트의-가독성"},r.createElement(n.a,{href:"#컴포넌트의-가독성"},"컴포넌트의 가독성")),"\n",r.createElement(n.h2,{id:"컴포넌트의-의존성"},r.createElement(n.a,{href:"#컴포넌트의-의존성"},"컴포넌트의 의존성")),"\n",r.createElement(n.h1,{id:"마치며"},r.createElement(n.a,{href:"#마치며"},"마치며")),"\n",r.createElement(n.p,null,"사고 방식은 실제 구현에 큰 영향을 미친다. 또한, 소통을 위한 명확한 기준은 팀의 생산성을 높인다. 컴포넌트는 추상적이면서 구체적인 개념이다. 그러다보니 굉장히 다양한 방식의 구현이 가능하다. 이로 인한 커뮤니케이션 비용이 증가할 수 있기 때문에 컴포넌트에 대한 사고 방식을 명확히 하는 것이 중요하다. 꼭 이 글이 아니더라도 컴포넌트에 대한 기준을 정하고 팀원들과 공유하는 것이 중요하다."))}n.default=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,l.R)(),e.components);return n?r.createElement(n,e,r.createElement(c,e)):c(e)}},5799:function(e,n,t){var l=t(9474),r=t(1615),a=t(6810);n.A=e=>{let{src:n,caption:t,width:c,maxWidth:i,expandable:m}=e;const{0:u,1:o}=(0,l.useState)(!1);return console.log(u),(0,a.Y)("figure",null,(0,a.Y)("img",{src:n,width:c||"100%",style:{cursor:m?"zoom-in":"default",maxWidth:i},onClick:m?()=>o(!0):void 0}),t&&(0,a.Y)("figcaption",{dangerouslySetInnerHTML:{__html:t}}),u&&r.createPortal((0,a.Y)("div",{style:{position:"fixed",top:0,left:0,width:"100%",height:"100%",cursor:"zoom-out",backgroundColor:"rgba(0, 0, 0, 0.7)"},onClick:()=>o(!1)},(0,a.Y)("div",{style:{borderRadius:8,maxWidth:1440,width:"100%",position:"fixed",top:"50%",left:"50%",transform:"translate(-50%, -50%)",backgroundColor:"white"}},(0,a.Y)("img",{src:n,width:"100%"}))),document.body))}},9128:function(e,n,t){t.d(n,{R:function(){return c}});var l=t(9474);const r={},a=l.createContext(r);function c(e){const n=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}}}]);
//# sourceMappingURL=component---src-posts-2025-03-02-react-component-based-thinking-mdx-9eaf47592c07345ea9af.js.map