---
title: "디버깅 원칙"
categories: article
tags: [debugging, renderer, 3d, ascii]
image: /images/2024-03-16-principles-of-debugging/thumbnail.png
comments: true
draft: false
hide: false
---

import Image from '@components/Image';

필자를 포함하여 대부분의 개발자가 만드는 것은 생명과 직결된 항공이나 핵 발사 프로그램 같은 것은 아닐 것이다. 따라서 우리가 만드는 제품은 **생산성과 안정성 사이에서 생산성을 택하는 경우가 많으며 이로 인해 발생하는 품질 확인 공백은 결함으로 이어지는 경우가 많다**. 즉, 생산성을 포기하면서까지 꼼꼼하게 확인하지는 않기 때문에 결함을 막기 위한 다양한 방법론과 도구를 사용하더라도 완전히 제거하는 것은 불가능에 가깝다. 당연하게도 이는 규모가 클 수록 더 힘들어진다.

다행히 프로그램이란 것은 물리적인 제약이 없기 때문에 문제가 발견되더라도 제품이 릴리즈되기 전에 문제를 해결하는 것이 가능하다. 그래서 대부분의 개발자는 생산성에 지장이 없는 수준에서 구현하되 문제가 발생할 경우 디버깅을 통해 문제를 신속하게 해결하는 전략을 사용한다. 이러한 환경과 문화를 고려했을 때 디버깅이란 것은 사실상 개발자의 필수 역량이라고 할 수 있다.

어느 정도 경력이 쌓인 개발자라면 누구나 자신만의 디버깅 원칙을 가지고 있을 것이다. 말 그대로 자신만의 원칙이기 때문에 사람마다 접근하는 방식이 다를 수 있다. 이 글에 대해 동의하지 못하는 개발자가 있을 수 있지만 필자는 그래도 어느 정도 디버깅을 잘하는 편이라 자부하며 이 글에서는 나만의 디버깅 원칙을 정리해 보고자 한다. 만약 전부 읽기 귀찮거나 시간이 없다면 글 가장 하단만을 봐도 괜찮다.

# 마인드셋

어떻게보면 디버깅은 잡기술이라 볼 수도 있지만 그렇기 때문에 **어떻게 접근할 것인가라는 마인드셋이 중요**하다. 우선 디버깅을 한 문장으로 표현하자면 **예상하지 못한 동작을 올바르게 만드는 과정**이다. 그러다보니 디버깅을 하다보면 "분명 이곳이 잘못된 부분일 것 같은데"같은 생각으로 인해 엉뚱한 부분에 매몰되는 경우가 많다. 이는 예상하지 못한 동작이라는 부분에 대한 나의 생각이 의심을 넘어 확신으로 변하기 때문이다. 많은 개발자들이 디버깅을 할 때 이러한 상황에 빠지게 되는데 이는 엄청난 시간을 소비하게 되며 개발자의 멘탈적인 부분에서도 타격을 주게 된다.

<Image src="/images/2024-03-16-principles-of-debugging/sunk-cost-fallacy.png" caption="혹시 매몰비용의 오류를 범하고 있지 않은가?" width="80%" />

따라서 디버깅을 할 때는 **모든 것을 의심하는 것**이 중요하다. 물론 나 자신을 가장 믿지 않아야 한다.

# 직관과 퍼널

디버깅을 하는 개발자는 마치 추리 소설 속 탐정과도 같다. 탐정은 상황과 증거를 기반으로 경우의 수를 줄여 나가며 범인을 찾아나간다. 간혹 주변인의 도움을 받기도 하며 뛰어난 통찰력으로 범인을 유추하기도 한다. 버그를 찾는 개발자도 탐정과 크게 다르지 않다. **디버깅이란 상황 증거와 직접 증거를 기반으로 문제의 원인을 찾아나가는 과정**이기 때문이다.

<Image src="/images/2024-03-16-principles-of-debugging/detective.jpeg" caption="얘네가 개발자면 매일 버그가 생길지도 모른다" />

디버깅을 통한 문제 해결은 크게 두 가지로 나뉜다. 바로 **직관을 이용하는 방법과 퍼널을 이용하는 방법**이다.

잠깐, 직관이라니? 그런 애매모호한 방법을 사용해도 되는 건가? 라고 생각할 수도 있지만 아마 대부분 직관을 이용하여 문제를 해결하나 해결하는 것을 본적이 있을 것이다. 직관은 모 아니면 도라는 식으로 찍는 방법이 아닌 내가 가지고 있는 지식과 경험을 바탕으로 문제를 해결하는 방법[^1]이다. 이미 이전에 한 번 유사한 경험을 했을 수 있고 관련된 지식이 있기에 문제를 찾을 수 있는 것이다.

<Image src="/images/2024-03-16-principles-of-debugging/dikiw.png" caption="직관은 어디서 나오는가? / DIKW 피라미드" />

직관은 지혜에서 나온다. 많은 사람들이 지식과 지혜는 다르다고 말하는데 대체 지혜라는게 뭘까? 설명을 보기 전에 다음 이야기를 읽어보자.

> 한여름의 태양이 시장을 환하게 비추는 날이었다. 시장 입구에서 소리치는 상인들의 목소리가 여기저기서 들렸다. 김 씨는 장을 보러 시장에 나섰다. 그는 장바구니를 들고 여기저기 둘러보며 필요한 것들을 찾고 있었다.
>
> 우연히 그는 한 과일 가게 앞에서 발길을 멈췄다. “오늘 복숭아가 정말 싱싱해요!” 상인이 외쳤다. 복숭아는 아내가 가장 좋아하는 과일 중 하나였다. 호기심이 동한 김 씨는 복숭아를 자세히 살펴봤다. 과일마다 크기도 다르고 색도 조금씩 달랐다. 그는 잠시 고민하다가 상인에게 물었다.
>
> “복숭아는 어떻게 고르는 게 좋나요?” 상인은 웃으며 말했다. “좋은 복숭아는 향이 진하고, 껍질에 흠이 없으며, 살짝 눌렀을 때 단단한 느낌이 듭니다.” 김 씨는 상인의 말을 듣고 고개를 끄덕이곤 이내 큰 복숭아 두 개를 골랐다.
>
> 장을 다 보고 돌아오는 길에, 김 씨는 아내에게 복숭아를 건네며 오늘의 이야기를 들려주었다. 아내는 복숭아를 한 입 베어 물며 미소 지었다. “당신 덕분에 정말 맛있는 복숭아를 먹게 되었네요.”

사실 지혜라는 것은 특별한 것이 아니다. 우리는 일상 생활에서 항상 지혜를 발휘하고 있다. 김 씨가 시장에서 본 복숭아의 크기, 색깔, 향기, 껍질 상태는 모두 데이터다. 데이터를 수집한 김씨는 상인에게 데이터 분석에 대한 외주를 맡겨 향이 진하고, 껍질에 흠이 없으며, 살짝 눌렀을 때 단단한 느낌이 나는 복숭아가 좋은 복숭아라는 정보를 얻었다.

이어서 김 씨는 상인의 정보를 바탕으로 복숭아를 고르는 경험을 하고 학습하며 지식을 얻었다. 즉, 김 씨는 경험과 학습을 통해 정보를 체계화 했다고 볼 수 있다. 그리고 김 씨는 최종적으로 아내에게 복숭아를 건네 함께 즐기며 아내를 행복하게 만드는 지혜를 발휘했다. 김 씨는 단순히 좋은 복숭아를 고르는 법을 아는 것에 그치지 않고 아내가 복숭아를 좋아한다는 지식과 연결하여 가족의 행복을 증진시키는 지혜를 발휘한 것이다.

디버깅은 조금 더 진지한 상황일 뿐, 위 이야기와 크게 다르지 않다. 개발자는 에러 메시지, 코드, 상황 등의 데이터를 수집하고 이를 분석하여 '이 문제는 어떤 것과 관련이 있을 것 같다'라는 정보를 얻는다. 이렇게 얻은 정보를 바탕으로 연관된 지식을 개발자의 머리 속 데이터베이스 혹은 인터넷, 도서, 동료 등을 통해 얻을 수 있다. 그리고 이러한 지식을 문제와 연결함으로서 생기는 가설을 테스트하고 결과를 분석하여 문제를 해결하는 지혜를 발휘할 수 있다. 여기서 **지식을 문제와 연결하는 것이 직관**이다.

보통 `어 설마 이건가?`하고 정답이 뿅 나오는 것은 이미 지식이 충분하고 유사한 경험을 했기 때문이다. 즉, **경험이 직관으로 통하는 숏컷 역할**을 해주는 것이다. 그럼 만약 경험이 없다면 어떻게 해야할까? 숏컷을 사용할 수 없다면 느리더라도 직관을 만들기 위한 과정을 거치면 된다. 이를 위해 퍼널을 이용할 수 있다. 이어서 이에 대한 이야기를 해볼 것이다.

<Image src="/images/2024-03-16-principles-of-debugging/funnel.jpg" caption="필요없는 것은 걸러내야 한다" width="80%" /> 

# 여과하기

> **불가능을 제외하고 남은 것은 아무리 믿을 수 없어도 진실이다.**
> <div style={{textAlign:'right'}}>— 셜록 홈즈, 네 사람의 서명에서</div>

개발자는 디버깅은 예상하지 못한 동작의 원인을 찾기 위하여 본능적으로 **가능성을 좁혀나가는 행위**를 하게된다. 자신만의 원칙을 가진 개발자도 있을 것이고 일단 주먹구구식으로 찾아보는 개발자도 있을 것이다.

개인적으로는 원칙을 가지고 의식적으로 하나씩 좁혀나가는 것이 좋다고 생각한다. 일단 디버거를 켜고 시작하는 바텀업 방식은 여러 함정에 빠질 위험이 크다. 여기서부터 필자가 디버깅을 할 때 사용하는 방법을 소개하고자 한다. 만약 특별한 원칙이 없었다면 이 글을 참고하여 자신만의 원칙을 만들어보는 것도 좋을 것이다.

# 체크리스트를 작성하라

체크리스트를 작성하면 가능성을 좁히기 위하여 내가 확인한 부분과 앞으로 확인해야 하는 부분을 확인하는 데 큰 도움이 된다. 앞서 이야기한 내용과 연결하면 **데이터를 확인하고 이에 대한 정보를 수집하는 일**이라 할 수 있다. 번거롭게 느껴질 수도 있지만 체크리스트를 작성하는 것이 오히려 시간을 절약하는 경우가 많다.

체크리스트는 큰 범주에서 작게는 세세한 부분까지 작성하는 것이 좋다. 이 말이 모든 부분에 대해 체크리스트를 작성하라는 말은 아니다. 디버깅은 설계를 하는 것이 아니기 때문에 문제가 있는 부분을 좁혀나가는 것이 중요하다. 그래서 큰 범주에 대한 체크리스트만 먼저 작성하고 의심되는 범주에 대해 조금씩 파고들면서 검증하고 떠오르는 생각을 체크리스트로 작성하며 확인하는 것이다. 이런 방식으로 작업하면 특정 부분만을 확인하는 과몰입 방지에 도움이 된다. 그리고 당연하게도 체크리스트를 작성하면 무엇을 확인했는지 알 수 있기 때문에 중복 확인을 방지할 수 있으며 다음으로 확인해야 하는 부분을 빠르게 떠올릴 수 있다.

요약하자면 체크리스트를 작성하는 것은 다음과 같은 이유로 유용하다.

* 체크리스트를 작성하면 무엇을 확인해야 하는지, 무엇을 확인했는지 알 수 있다.
* 한 영역에 대해 과몰입하는 것을 어느정도 방지할 수 있다.

# 정보를 수집하라

문제가 발생했을 때 개발자가 확인할 수 있는 데이터는 다양하다. 확인한 데이터는 보고 넘어가지 말고 정보로 만들 필요가 있다. 다음과 같은 예를 들 수 있다.

* 에러가 발생한 지점을 확인하고 이를 의존하는 코드를 정리한다.
* 에러 메시지를 확인하고 관련한 자료를 검색한다.
* 에러가 발생한 시점의 하드웨어 상태를 확인한다.
* 에러의 발생 주기에 패턴이 있는지 확인하다.
* ...

데이터를 기반으로 만들 수 있는 정보는 무궁무진하다. 이러한 정보를 최대한 만들어내는 것이 디버깅의 핵심이다.

## 디버깅 드릴링

어이없는 실수로 인한 문제를 제외한다면 **디버깅은 큰 범위에서 좁은 범위로 좁혀나가는 탑다운적인 사고 방식이 유용**하다. 필자는 이를 디버깅 드릴링이라고 부르고 다음과 같은 순서로 진행된다.

* 논리적 결함 확인
* 의존 기술 결함 확인
* 과학적 결함 확인
* 물리적 결함 확인

상황에 따라 위 순서는 변경될 수 있다. 유연하게 대처하는 것이 디버깅의 핵심이다.

## 논리적 결함

논리적 결함은 셋으로 나눌 수 있다. 각각 로직에 대한 결함, 데이터에 대한 결함, 그리고 기획에 대한 결함이다.

로직에 대한 결함은 당연히 내가 작성한 코드에 대한 결함이다. 이는 대부분 디버거를 사용하여 로직의 흐름을 파악하면 쉽게 문제가 있는지 확인할 수 있다. 물론 디버거를 사용하지 않고도 확인할 수 있지만 디버거를 사용하면 훨씬 효율적으로 확인할 수 있다.

데이터에 대한 결함은 데이터의 상태를 확인하는 것이 중요하다. 이는 로그를 확인하거나 디버거를 사용하여 데이터의 상태를 확인하는 것이 중요하다. 데이터의 상태를 확인하는 것은 로직에 대한 결함을 확인하는 것과 병행하여 진행되어야 한다.

기획에 대한 결함은 요구사항을 잘못 이해했거나 기획 자체에 문제가 있는 경우에 해당한다. 이런 경우는 요구사항을 다시 검토하여 기획한 사람 혹은 고객과 상의하여 해결해야 한다.

## 의존 기술 결함 확인

이 글에서 말하는 의존 기술이란 프레임워크나 라이브러리, 언어 등을 말한다. 발생 할 수 있는 문제는 크게 다음과 같다.

* 설정 문제
* 버전 문제
* 잘못된 사용 방법
* 버그

**설정 문제**는 대부분 해당 기술의 문서를 참고하는 것으로 해결할 수 있다. 의심 되는 부분이 있다면 문서를 잘 확인해보자.

**버전 문제**는 대부분 버전을 올리거나 내리는 것으로 해결할 수 있다. 특히 라이브러리의 경우 의존성 설정 중 자동으로 업데이트 되어 버전이 올라가는 경우가 많다. 이런 경우에 간혹 버전이 올라가며 라이브러리 자체에 버그가 생겼거나 기능이 변경되는 등 문제가 발생할 수 있다. 이런 경우에는 버전을 내리는 것이 해결책이 될 수 있다. 혹은 문서는 최신 버전을 보고있지만 낮은 버전을 사용하여 문제가 되는 경우도 있다. 그러니 버전을 확인하는 것은 중요하다.

**잘못된 사용 방법**은 대부분 스택오버플로우나 블로그 문서 등을 보며 작업했을 때 발생한다. 이런 경우엔 해당 기술의 문서를 참고하는 것으로 해결할 수 있다. 이는 설정 문제와 비슷하다.

간혹 의존하는 기술에 **버그**가 있는 경우가 있다. 이에 대한 것은 정말 찾기 힘들고 커뮤니티가 활발하지 않은 경우엔 해결하기 어려울 수 있다. 의존 기술 자체에 버그가 있는 것이 의심된다면 커뮤니티에 문의하거나 해당 기술의 이슈 트래커를 확인해보는 것이 가장 좋다.

## 과학적 결함

과학적 결함은 컴퓨터 과학적인 문제로 인해 발생하는 결함이다. 이는 주로 메모리나 성능, 통신 등과 관련된 문제이다. 이에 대한 문제를 해결하기 위해선 컴퓨터 과학 지식이 필요하며 관련 툴을 잘 사용하는 것이 중요하다.

**메모리 문제**는 대부분 메모리 누수로 인해 발생한다. 이는 관련 점검 툴을 이용하여 확인할 수 있다. 간혹 메모리 덤프와 같은 방법을 사용하여 확인할 수도 있다.

간혹 **성능 문제**로 인해 타임 아웃이 발생하거나 프로그램 자체가 멈출 수 있다. 이는 프로파일링 툴을 사용하여 확인할 수 있다.

**통신 문제**는 대부분 네트워크 문제로 인해 발생한다. 타임 아웃 혹은 커넥션 문제가 발생하는 경우가 대부분이다. 이는 네트워크 툴을 사용하여 확인할 수 있다.

## 물리적 결함

물리적 결함은 하드웨어적인 문제인 가능성이다. 디버깅 중 여기까지 오는 경우는 드물지만 전혀 없는 사례는 아니다. 임시로 다른 장비에서 테스트해보거나 하드웨어에 고장이 있는지 확인하는 것이 좋다.

# 정보를 제거하라

정보를 수집했다면 그 중엔 아는 것과 잘 모르는 것으로 나뉠 것이다. 잘 아는 것은 바로 여과를 할 수 있는지 확인할 수 있다. 사실 예상 가능한 단순한 문제라면 정보를 수집하는 단계에서 바로 여과되는 정보라고 할 수 있다. 잘 모르는 것은 일단 냅둔다.

다만, 제거한다고 체크리스트에서 바로 지우는 것은 별로 좋지 않다. 잘 안다고 생각했지만 사실 잘 몰랐던 경우나 알고보니 진짜 문제는 제거한 정보에 있었던 경우가 있을 수 있기 때문이다. 따라서 우선 별도로 빼두고 모든 경우를 확인한 후에도 문제를 파악하지 못했다면 별도로 빼둔 리스트를 다시 한 번 검토하면 된다.

## 어이없는 실수를 의심하라

간혹 어이없는 실수로 인해 프로그램 동작에 문제가 생기는 경우가 있다. 대표적인 사례로는 다음과 같은 것들이 있다.

* 오타
* 잘못된 변수 사용
* 잘못된 조건문 사용
* 계산 실수

위와 같은 실수는 정보를 수집할 때 무시하고 넘어가는 경우가 많다. 하지만 의외로 위와 같은 실수가 문제의 원인이 되는 경우가 적지 않다. 다음과 같은 사례가 있다.

* 문자열로 상태를 기록하는데 오타를 낸 경우
* 조건문에서 `if (a == 1)`을 사용해야 하는데 `if (a = 1)`을 사용한 경우
* 계산식을 잘못 작성한 경우. 예를 들면 연산자 우선순위를 잘못 작성하는 경우
* 멤버 변수를 사용해야 하는데 동일한 이름의 지역 변수를 사용한 경우

물론 이런 실수는 흔하지 않다. 하지만 없다고 말할 수도 없다. 이러한 실수는 디버거를 사용하더라도 찾기 어려울 수 있기 때문에 본격적으로 디버깅을 시작하기 전에 **어이없는 실수를 한 번쯤 의심하는 것**이 좋다. 참고로 특정 실수는 IDE에서 경고로 보여주는 경우도 있다. 그러니 IDE의 경고를 무시하지 말자.

# 학습하여 지식을 얻어라

앞서 잘 모르는 것으로 분류한 정보는 여과하기 어려울 것이다. 이런 경우에는 정보를 바탕으로 학습을 해야한다. 학습은 다양한 방법으로 할 수 있다. 인터넷 검색, 도서, 동료, 커뮤니티 등을 활용하여 지식 공백을 채울 수 있다. 이렇게 얻은 지식은 정보가 문제와 관련이 없는지 판단하는 데 도움이 된다.

만약 그럼에도 불구하고 제거하는게 좋을지 판단이 안된다면 가능성 점수[^2]를 매기고 일단 냅두는 것도 방법이 될 수 있다.

# 문제와 연결하기

가능성을 좁혀나가다 보면 문제와 연결되는 가설이 생길 것이다. 이 가설을 테스트하고 결과를 분석하면 간접 증거나 직접 증거를 얻을 수 있다.

# 마치며

마지막으로 앞서 작성한 글을 정리해보자.

* 디버깅을 할 때는 모든 것을 의심하라
* 가능성을 좁혀나가기 위해 체크리스트를 작성하라
* 디버거를 사용하라
* 로그를 잘 남기자
* 어이없는 실수를 의심하자
* 큰 범위에서 좁은 범위로 좁혀나가는 탑다운적인 사고 방식을 이용하라

AI가 코드를 생산해주는 시대기에 역설적으로 디버깅은 더 중요해질 것이다. 그만큼 디버깅을 잘하는 것은 개발자로서 중요한 역량이 될 것이다. 그러니 만약 나만의 유용한 디버깅 원칙이 존재한다면 필자처럼 정리해보는 것을 추천한다. 더 나아가 좋은 팁을 공유한다면 더할나위 없을 것이다.

[^1]: 재밌게도 유레카로 유명한 아르키메데스의 밀도의 발견, 뉴턴이 중력의 법칙을 생각해 낸 것도 직관을 통한 것이라고 한다.
[^2]: 필자는 가능성에 대해 1점부터 5점까지 점수를 매긴다. 물론 이 점수는 주관적이다.