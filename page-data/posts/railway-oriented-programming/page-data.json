{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2023-07-17-railway-oriented-programming-mdx","path":"/posts/railway-oriented-programming/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n프로그램을 개발함에 있어 **에러와 사이드 이펙트(부수 효과)를 처리하는 것은 필연적**이다. 아무리 꼼꼼하게 코드를 작성해도 생각하지 못한 문제는 존재하며 특히나 지속해서 발전하는 프로그램은 기술 부채와 함께 **끊임없이 새로운 문제가 발생**한다.\n\n문제가 발생하는 것은 개발자 개인에게도 프로그램을 판매하는 회사에게도 끔찍한 일이다. 아무리 단순하게 해결할 수 있는 문제여도 사용자에게 피해가 간다면 금전적 손실이 발생할 수 밖에 없다. 그렇기 때문에 **프로그래밍은 안전하게 프로그램을 작성할 수 있는 형태로 끊임없이 발전**해왔고 개발자들은 다양한 방법을 생각해냈다. 그 중 하나가 방법론인 `Railway-Oriented Programming`(이하 ROP)이다.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/trip.jpg\" caption=\"여행을 떠나보자\" />\n\n# 사이드 이펙트\n\n먼저 사이드 이펙트에 대해서 자세히 알아보자. 사이드 이펙트란 **함수 내부(혹은 프로시저)에서 발생한 일이 함수 외부에 영향을 미치는 것**을 말한다. 구체적으로 다음과 같은 경우를 말한다.\n* 함수 내부에서 외부에 있는 변수를 조작하는 경우\n* 네트워크 통신 중 잘못된 데이터를 받아 프로그램에 영향을 미치는 경우\n* 함수 내부에서 에러가 발생하여 프로그램에 문제가 발생하는 경우\n\n위와 같은 사례 외에도 다양하게 존재할 수 있다. 요즘엔 함수 내부에서 외부 값을 참조하거나 변경하면 좋지 않다는 것이 널리 알려져 있기 때문에 보통 사이드 이펙트는 **I/O로 인한 문제**로 접하는 경우가 많다. 그래서 이런 문제를 해결하기 위해 많은 개발자들이 예외 처리를 하는 것에 많은 공을 들인다. 하지만 또 많은 개발자들이 간과하는 문제는 `함수 내부에서 에러가 발생하여 프로그램에 문제가 발생하는 경우`라고 할 수 있다. 아주 간단한 코드를 작성하더라도 이런 문제는 발생할 수 있다. 오히려 간단하기 때문에 실수하는 경우가 많다. 예를 들어, 다음과 같은 코드를 살펴보자.\n\n```kotlin\n// Kotlin\nfun getFirstElement(list: List<Int>): Int {\n  return list[0]\n}\n```\n\n위 코드는 리스트의 첫번째 값을 찾아 불러오는 아주 간단한 함수다. 얼핏보면 큰 문제가 없어보이나 **리스트가 비어있을 때 문제가 발생**한다. 물론 이런 간단한 문제는 쉽게 해결할 수 있지만 막상 작성할 때 실수하는 경우가 많다.\n\n사이드 이펙트는 프로그램의 흐름을 예측하기 어렵게 만들며, 특히나 다른 개발자가 작성한 코드를 수정할 때 사이드 이펙트를 고려하지 않으면 예상치 못한 문제가 발생할 수 있다. 이러한 문제를 해결하기 위해서 다양한 방법이 존재한다.\n\n# 다양한 해결 방법\n\n단순히 분기를 이용하는 것 외에도 사이드 이펙트를 해결 할 수 있는 방법은 다양하다. ROP에 대해 알아보기 전에 다른 방법들을 먼저 살펴보자. 사이드 이펙트를 해결하는 방법은 크게 두 가지로 나뉜다.\n* LBYL (Look Before You Leap)\n* EAFP (Easier to Ask for Forgiveness than Permission)\n\nLBYL은 **뛰기 전에 보라**라는 뜻이고 EAFP는 **허락보다는 용서를 구하는 것이 쉽다**라는 뜻이다. 아마 Python을 공부해봤다면 이 두 방법에 대해 들어본 적이 있을 것이다. LBYL은 로직 내에 명시적으로 조건을 검사하는 것을 말한다. 예를 들어, 다음과 같은 코드를 살펴보자.\n\n```kotlin\n// Kotlin\nfun getFirstElement(list: List<Int>): Int? {\n  if (list.isEmpty()) {\n    return null\n  }\n  return list[0]\n}\n```\n\n위 코드는 비어있는 리스트가 매개 변수로 들어올 것을 예상하여 **분기를 통해 미리 예외 처리**를 한다. 반면 EAFP는 예외 처리를 통해 사이드 이펙트를 해결하는 방법이다. 예를 들어, 다음과 같은 코드를 살펴보자.\n\n```kotlin\n// Kotlin\nfun getFirstElement(list: List<Int>): Int? {\n  return try {\n    list[0]\n  } catch (e: Exception) {\n    null\n  }\n}\n```\n\n위 코드는 LBYL과 달리 **올바른 로직을 작성한 후 예외가 발생하면 잡는 방식**으로 사이드 이펙트를 해결한다. 말 그대로 먼저 처리한 후 예외에 대한 용서를 구하는 방식이다.\n\nPython에서는 LBYL보다는 EAFP를 선호하지만 필자는 이 두 스타일에 우열은 없다고 생각한다. 상황에 따라 적절한 것이 있을 뿐이다. 이 방법들에 대한 사용 사례를 조금 더 자세히 살펴보자.\n\n## LBYL\n### 순수 함수\n외부와 상호작용 해야하는 I/O를 다루는 것이 아니라면 순수 함수로 작성하여 사이드 이펙트 문제를 해결 할 수 있다. 순수 함수는 **동일한 인자**를 받았을 때 항상 **같은 값**을 반환하는 함수를 말한다. 이말은 즉, **결과를 예측할 수 있다**는 말과 동일하다. 다음과 같은 함수는 순수 함수라 할 수 있다.\n\n```kotlin\nfun sum(a: Int, b: Int): Int {\n  return a + b\n}\n```\n\n참고로 에러가 발생할 수 있는 예외는 처리해줘야 한다.\n\n프로그램은 컴퓨터 시스템 위에 올라가기 때문에 수학처럼 **완전하게 순수할 수는 없다**. 그래서 순수 함수의 범위가 애매하게 느껴질 수 있다. 예를 들면, 부동 소수점 문제가 있다.\n\n```kotlin\nvar num1: Double = 0.0\nfor (i in 0 until 10) {\n  num1 += 1.0 / 3\n}\nval num2: Double = 1.0 / 3 * 10\nprintln(num1 == num2) // false\n```\n\n위 코드를 수학적으로 생각하면 num1과 num2는 같은 값이기 때문에 `true`가 나와야 정상이다. 하지만 부동 소수점이라는 한계가 있기 때문에 `false`가 나온다. 만약 위와 같이 부동 소수점을 다루는 함수가 있다면 과연 그 함수를 순수하다고 할 수 있을까?\n\n이를 해결하기 위해서는 프로그램 목적에 따라 **구현 스펙**을 정할 필요가 있다. 다시 부동 소수점을 예로 든다면 자세한 소수점이 필요 없다면 적절한 단위에서 반올림을 통해 문제를 해결하거나 정확한 계산이 필요하다면 Double 자료형을 쓰는 것이 아닌 문자열을 통해 정확한 소수점을 계산해주는 객체를 만들어 사용할 수 있다.\n\n### Guard Clause 패턴\n\nGuard Clause 패턴은 로직의 시작 지점에 방어 조건을 먼저 작성하는 패턴이다. 패턴이라하니 복잡하다 느낄 수 있지만 실제로는 `if`를 이용하여 간단하게 구현할 수 있다.\n\n```javascript\n// JavaScript\nfunction authorize(user) {\n  if (user.role !== 'admin') return false\n  if (user.isBlocked) return false\n\n  // 권한이 있는 사용자에게만 보여줄 로직\n}\n```\n\n위 코드를 보다시피 매우 간단하다. Guard Clause 패턴의 핵심은 **로직 상단에 방어 조건이 있는 것이며 중첩된 if를 피하는 것**이다. 이를 통해 함수의 **가독성**을 높일 수 있다. 참고로 Swift는 언어 자체에서 Guard 문법을 지원한다.\n\n```swift\n// Swift\nfunc authorize(user: User) throws -> Bool {\n  // if와 달리 조건이 맞지 않으면 실행된다.\n  guard user.role == .admin else { return false }\n  guard !user.isBlocked else { return false }\n\n  // 권한이 있는 사용자에게만 보여줄 로직\n}\n```\n\n## EAFP\n### try-catch 문법\n\n순수 함수는 결과를 예측하게 해주지만 **외부 I/O와 개발자가 미처 알아차리지 못한 문제**는 해결해주지 않는다. 특히 요즘 제작되는 대부분의 소프트웨어는 거의 반드시 외부 I/O를 다루기 때문에 새로운 해결 방법을 찾아야 한다. 그 중 하나가 **try-catch 문법**이다.\n\ntry-catch 문법은 이미 오래전부터 많은 언어가 지원하고 있다. 그래서 많은 개발자들이 잘 알고있는 예외 처리 방법이기도 하다.\n\n```kotlin\n// Kotlin\ntry {\n  // 예외가 발생할 수 있는 코드\n} catch (e: Exception) {\n  // 예외가 발생했을 때 실행할 코드\n}\n```\n```javascript\n// JavaScript\ntry {\n  // 예외가 발생할 수 있는 코드\n} catch (e) {\n  // 예외가 발생했을 때 실행할 코드\n}\n```\n```python\n# Python\ntry:\n  # 예외가 발생할 수 있는 코드\nexcept Exception as e:\n  # 예외가 발생했을 때 실행할 코드\n```\n\n언어마다 조금씩 문법은 조금씩 다르지만 형태는 거의 같다. try-catch 문법은 **예외가 발생할 수 있는 코드를 try 블록에 작성**하고 **예외가 발생했을 때 실행할 코드를 catch 블록에 작성**한다. 이렇게 작성하면 예외가 발생했을 때 catch 블록의 코드가 실행된다. try-catch는 어디에서 사용되어야 할까? 대체로 함수를 사용하는 상위 로직에서 사용한다. 그리고 사용 당하는 함수는 에러만을 던진다. 이는 개발자가 미리 알고 의도한 에러든 예상치 못한 에러든 상관없다.\n\n```kotlin\n// Kotlin\nfun authorize(user: User) {\n  if (user.role != Role.ADMIN) {\n    throw RuntimeException(\"권한이 없습니다.\")\n  }\n}\n\nfun login() {\n  try {\n    authorize(User(name = \"kciter\", role = Role.USER))\n  } catch (e: Exception) {\n    println(e.message)\n  }\n}\n```\n\ntry-catch 문법은 크게 문제가 없어보이지만 **가독성**에 조금 문제가 있다. try-catch는 순차적으로 흐르지 않는다. 에러가 발생하면 `catch` 절로 이동하고 `finally`와 같은 문법을 사용할 경우 `try`에서 처리된 후 온 것인지 `catch`에서 처리된 후 온 것인지 확인이 필요하다. 그렇기 때문에 프로그램을 그대로 종료할 것이 아니라면 어떤 절로 로직이 마무리 되더라도 문제없이 진행될 수 있도록 개발자가 신경써야 한다.\n\n또한, 해당 함수가 **어떤 에러를 반환하는지 개발자가 미리 알아야 한다는 문제**가 있다. 특히 사용자 지정 에러가 많은 경우 생산성에 문제가 될 수 있다.\n\n하지만 try-catch가 나쁘다는 의미는 아니다. 서버 프로그램과 같이 **절대로 패닉이 발생해선 안되는 프로그램**에서는 try-catch 문법은 매우 유용하다.\n\n```kotlin\nfun main() {\n  val server = ServerSocket(8080)\n  println(\"Server is running on port ${server.localPort}\")\n\n  while (true) {\n    val socket = server.accept()\n    val reader = Scanner(socket.getInputStream())\n    val writer = socket.getOutputStream()\n    println(\"Client connected: ${socket.inetAddress.hostAddress}\")\n\n    thread {\n      while (true) {\n        try {\n          val text = reader.nextLine()\n          writer.write(text.toByteArray(Charset.defaultCharset()))\n        } catch (e: Exception) {\n          println(e.message)\n          socket.close()\n          break\n        }\n      }\n    }\n  }\n}\n```\n<figcaption style={{marginTop:-16}}>서버는 신뢰성을 위해 최대한 살아있어야 한다</figcaption>\n\n### Functor와 Monad\n\n펑터와 모나드는 **함수형 프로그래밍**을 접하면 자주 들을 수 있는 개념이다. 일반적으로 처음 프로그래밍을 접하며 배운 내용들과는 이질적이기도 하고 설명에 수학적인 내용이 들어가는 경우도 있어서 어렵게 느껴질 수 있다. 하지만 하나씩 살펴보면 그리 어려운 개념은 아니다. 함수형 프로그래밍에 대한 설명은 이 글의 범위를 벗어나므로 어려운 개념은 생략하고 간단하게 펑터와 모나드를 살펴볼 것이다.\n\n먼저 펑터와 모나드를 이해하기 전에 **타입**에 대해 살펴볼 필요가 있다. 함수형 프로그래밍에서 타입은 **함수 합성**을 하기 위한 중요한 개념이다. 수학적 정의와 마찬가지로 프로그래밍 세계의 함수도 **정의역과 치역**으로 이루어져 있다.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/domain-range.png\" caption=\"정의역과 치역 그리고 공역\" width=\"80%\" />\n\n함수의 정의역과 치역은 집합이다. 그리고 프로그래밍 언어에선 이를 타입으로 표현한다. \n\n```js\nBoolean = {true, false}\nShort = {-32768, ..., 0, ..., 32767}\nInt = {-2147383647, ..., 0, ..., 2147483647}\n...\n```\n\n그렇다면 다음 함수는 Int 집합에서 Double 집합으로 변형하는 함수라고 볼 수 있다. 즉, **정의역은 매개 변수의 타입이고 치역은 반환 타입**이다.\n\n```kotlin\nfun divide(a: Int, b: Int): Double = a.toDouble() / b.toDouble()\n```\n\n하지만 위 함수는 b가 0일 경우 DivideByZero 에러가 발생하기 때문에 순수 함수가 아니다. 이 경우 **치역을 온전한 Double**이라고 말할 수는 없다. 분기를 이용한 예외 처리로 이를 해결할 수 있지만 만약 에러마저도 치역에 포함시키고 싶다면 다른 방법을 사용해야 한다. 이 문제를 해결하는 것이 어렵게 느껴질 수 있지만 사실 상당히 간단한 일이다. Double이라는 집합으로는 에러를 담아낼 수 없기 때문에 새로운 집합이 필요하다. 즉, **새로운 타입**을 만들어내면 되는 것이다.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/new-range.png\" caption=\"묶어서 하나의 타입\" />\n\n위와 같은 개념이 **펑터**라고 할 수 있다. 지금부터 프로그래밍 세계에서 펑터를 어떻게 구현할 수 있을지 알아보자.\n\n#### Functor\n\n펑터라는 개념을 이용하면 타입을 확장하여 새로운 타입을 만들어낼 수 있다. 이를 통해 에러를 담아낼 수 있다. 코드를 살펴보기 전에 먼저 **개념적인 이미지**부터 살펴보자.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/functor.png\" />\n\n위 이미지를 보면 펑터는 박스와 같다는 것을 알 수 있다. 박스 안에는 값이 들어있고 이를 **꺼내서(unwrap value)** 함수를 <strong>적용(apply function)</strong>한다. 그리고 다시 박스에 **집어넣는다(rewrap value)**. 왜 이런 번거로운 짓을 하는 걸까? 그 이유는 **값에 함수를 적용할 때 발생하는 문제를 해결**하기 위함이다. 다시 다음 이미지를 살펴보자.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/functor-error.png\" />\n\n이번엔 펑터에 0을 나누는 함수를 적용했다. 이 경우 당연히 에러가 발생한다. 여기서 개발자는 적절한 로직을 통해 예외 처리를 할 수 있다. 이때 **예외 처리를 통해 얻은 에러 객체를 펑터**에 넣어주면 된다.\n\n이를 코드로 구현하면 다음과 같다. 여기선 예제로 Kotlin을 사용하겠다.\n\n```kotlin\nclass Functor<T>(private val value: T) {\n  fun <R> map(f: (T) -> R): Functor<R> =\n    Functor(f(this.value))\n}\n```\n\n펑터에서 **함수를 받아 값을 변형하는 함수**를 보통 `map`이라고 한다. 어디서 많이본 함수 아닌가? 그렇다. 우리는 이미 펑터라는 개념을 자주 써왔다! 그럼 이번엔 위 Functor 클래스를 이용하는 코드를 살펴보자.\n\n```kotlin\nclass Functor<T>(private val value: T) {\n  fun <R> map(f: (T) -> R): Functor<R> =\n    Functor(f(this.value))\n\n  override fun toString(): String =\n    \"Functor($value)\"\n}\n\nfun main() {\n  val functor = Functor(1)\n  val result = functor.map { it + 1 }\n  println(result) // Functor(2)\n}\n```\n\n아주 간단한 코드다. 펑터는 1이라는 값을 가지고 있고 이를 `map` 함수를 통해 1을 더한 값을 반환한다. 이를 통해 펑터는 **값을 변형하는 함수를 적용할 수 있다**는 것을 알 수 있다. 이제 펑터를 이용하여 조금 더 복잡한 것을 만들어보자. 이번에는 값이 `null`인지 알 수 있는 펑터를 구현해볼 것이다.\n\n```kotlin\nsealed class Option<out T> {\n  data class Some<T>(val value: T): Option<T>()\n  object None: Option<Nothing>()\n\n  companion object {\n    fun <T> of(value: T?): Option<T> = when (value) {\n      null -> None\n      else -> Some(value)\n    }\n  }\n\n  override fun toString(): String =\n    when (this) {\n      is Some -> \"Some($value)\"\n      is None -> \"None\"\n    }\n}\n\nfun <T, R> Option<T>.map(f: (T) -> R): Option<R> =\n  when (this) {\n    is Option.Some -> Option.of(f(this.value))\n    is Option.None -> Option.None\n  }\n\nfun main() {\n  val option = Option.of(\"Hello, World!\")\n  val result1 = option.map { it.toIntOrNull() }\n  val result2 = option.map { it.length }\n\n  println(result1) // None\n  println(result2) // Some\n}\n```\n\n`Option`이라는 값이 적용될 때 `null`인지 아닌지 판단하여 `null`이라면 `None`을 값이 있다면 `Some`으로 타입을 분류하는 펑터를 구현했다. 이를 이용하여 NullPointerException과 같은 문제를 예방할 수 있다. 그리고 패턴 매칭이 지원되는 언어라면 다음과 같이 더 안전하게 사용이 가능하다.\n\n```kotlin\nfun main() {\n  val option = Option.of(\"Hello, World!\")\n  val result = when (option) {\n    is Some -> option.value\n    is None -> \"None\"\n  }\n\n  // result는 null이 아님을 보장한다.\n  println(result) // Hello, World!\n}\n```\n\n만약 펑터를 이용하여 `null`을 판단하는 것이 아니라 에러를 판단한다면 어떨까? 이번에는 에러를 판단하는 펑터를 구현해보자.\n\n```kotlin\nsealed class Result<out V, out E> {\n  data class Success<out V>(val value: V): Result<V, Nothing>()\n  data class Failure<out E>(val error: E): Result<Nothing, E>()\n\n  companion object {\n    fun <V> of(f: () -> V): Result<V, Throwable> = try {\n      Success(f())\n    } catch (e: Throwable) {\n      Failure(e)\n    }\n  }\n\n  override fun toString(): String =\n    when (this) {\n      is Success -> \"Success($value)\"\n      is Failure -> \"Failure($error)\"\n    }\n}\n\nfun <V, R, E> Result<V, E>.map(f: (V) -> R): Result<R, E> =\n  when (this) {\n    is Result.Success -> Result.of { f(value) }\n    is Result.Failure -> this\n  }\n```\n\n`Option`과 거의 비슷하다. 다만 `null`을 판단하는 것이 아니라 try-catch를 이용하여 `Throwable`을 판단한다는 것이 다르다. 이를 이용하여 다음과 같이 사용할 수 있다.\n\n```kotlin\nfun main() {\n  val result = Result.of { 1 + 2 }\n    .map { it / 0 }\n  println(result) // Failure(error=java.lang.ArithmeticException: / by zero)\n}\n```\n\n`of` 메서드를 통해 에러가 발생한다면 `Failure` 타입이 반환되고 발생하지 않는다면 `Success` 타입이 반환된다. 마찬가지로 `map`을 이용해 값을 변형할 때 에러가 발생한다면 `Failure`를 반환하고 발생하지 않는다면 `Success`를 반환한다. 이를 통해 에러를 안전하게 처리할 수 있다. 여기서 `Option`때와 마찬가지로 패턴 매칭을 사용한다면 다음과 같이 사용할 수 있다.\n\n```kotlin\nfun main() {\n  val result = Result.of { 1 + 2 }\n    .map { it / 0 }\n    .map { it * 2 }\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  }\n}\n```\n\n여기까지는 아무런 문제가 없지만 다음과 같은 상황이 있을 수 있다.\n\n```kotlin\nfun sum(a: Int, b: Int): Result<Int, Throwable> = Result.of { a + b }\nfun divide(a: Int, b: Int): Result<Int, Throwable> = Result.of { a / b }\n\nfun main() {\n  val result = Result.of { 5 }\n    .map { sum(it, 10) } // Result<Result<Int, Throwable>, Throwable>\n    .map { divide(it, 0) } // 타입이 맞지 않아 컴파일 에러가 발생한다.\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  } // java.lang.ArithmeticException: / by zero\n}\n```\n\n위 코드와 같이 함수마다 에러를 판단하기 위해 Result라는 펑터 타입을 사용한다면 `map`을 이용할 때 **박스를 다시 박스로 감싸는 문제**가 발생하게 된다. 이를 해결하기 위해서는 박스로 다시 감싸지 않고 값을 변형하는 해야한다. 프로그래밍 세계에서 이를 구현하기 위해 **모나드**라는 개념을 이용할 수 있다.\n\n#### Monad\n\n모나드는 굉장히 어렵다라는 소문이 자자한 개념이다. 그러다보니 [모나드 괴담](https://xtendo.org/ko/monad#1)이라는 자료까지 생겨나곤했다. 하지만 이론적인 내용을 배제하고 하나씩 살펴보면 그다지 어렵지 않다는 것을 알 수 있다. \n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/monad-problem.jpeg\" caption=\"일단 수학 용어는 치워보자\" />\n\n앞서 모나드는 펑터의 중첩을 해결 할 수 있다고 말했다. 실제로 프로그래밍 세계의 모나드는 이를 위해 탄생했다. 게다가 심지어 많은 개발자가 이미 모나드를 사용하고 있다. 다음 코드를 살펴보자.\n\n```kotlin\nval list = listOf(1, 2, 3, 4, 5)\nval result = list\n  .flatMap {\n    listOf(it, it + 1) // listOf 함수는 List<T> 타입을 반환한다.\n  }\n```\n\n`flatMap`이라는 함수에 대해 다뤄본적이 있다면 위 코드는 익숙할 것이다. 만약 리스트를 변형하던 중 다시 리스트 타입을 반환해야 한다면 `flatMap`을 사용한다. 만약 `map` 함수였다면 `List<Int>` 타입을 `List<List<Int>>` 타입으로 변형했겠지만 `flatMap`은 `List<Int>` 타입으로 변형할 수 있다. 간단하게 표현하자면 **flatMap 함수가 반환한 것을 값으로 그대로 사용하는 것**이라 볼 수 있다. 이것이 모나드다.\n\n다시 정리하면 모나드는 중첩을 해결한다. 이제 Result 펑터를 이용하여 모나드를 구현해보자.\n\n```kotlin\nsealed class Result<out V, out E> {\n  data class Success<out V>(val value: V): Result<V, Nothing>()\n  data class Failure<out E>(val error: E): Result<Nothing, E>()\n\n  companion object {\n    fun <V> of(f: () -> V): Result<V, Throwable> = try {\n      Success(f())\n    } catch (e: Throwable) {\n      Failure(e)\n    }\n  }\n\n  override fun toString(): String =\n    when (this) {\n      is Success -> \"Success($value)\"\n      is Failure -> \"Failure($error)\"\n    }\n}\n\nfun <V, R, E> Result<V, E>.map(f: (V) -> R): Result<R, E> =\n  when (this) {\n    is Result.Success -> Result.of { f(value) }\n    is Result.Failure -> this\n  }\n\n// flatMap은 결과값을 그대로 사용한다.\nfun <V, R, E> Result<V, E>.flatMap(f: (V) -> Result<R, E>): Result<R, E> =\n  when (this) {\n    is Result.Success -> f(this.value)\n    is Result.Failure -> this\n  }\n```\n\n위 코드는 Result 펑터를 구현한 코드이다. `map` 함수는 펑터의 특징을 그대로 따르고 있고 `flatMap` 함수는 모나드의 특징을 그대로 따르고 있다. `flatMap` 함수는 결과값을 그대로 사용한다는 특징을 가지고 있다. 이제 모나드를 이용하여 펑터 쪽 예제에서 불가능했던 문제를 해결해보자.\n\n```kotlin\nfun sum(a: Int, b: Int): Result<Int, Throwable> = Result.of { a + b }\nfun divide(a: Int, b: Int): Result<Int, Throwable> = Result.of { a / b }\n\nfun main() {\n  val result = Result.of { 5 }\n    .flatMap { sum(it, 10) }\n    .flatMap { divide(it, 0) } // 타입이 일치한다!\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  } // java.lang.ArithmeticException: / by zero\n}\n```\n\n이제 문제가 해결된 것을 볼 수 있다. 모나드에 대해서는 이론적인 내용이 많이 있지만 실용적인 것만 따진다면 이렇게 간단하게 구현할 수 있다. 이제 펑터와 모나드를 이용하면 기존과는 다른 방식으로도 예외 처리를 할 수 있다는 것을 알았을 것이다. 이제 본격적으로 ROP에 대해서 알아보자.\n\n# Railway-Oriented Programming\n\nROP는 사이드 이펙트를 제어하기 위한 함수형 패러다임 기반 방법론이다. ROP라는 방법론은 널리 알려지진 않았지만 Rust는 try-catch 문법을 지원하지 않는대신 ROP 철학을 일부 따르고 있다. 즉, 배워둬서 나쁠건 없다고 생각한다.\n\n```rust\n// Rust 예제\nuse std::fs::File;\n\nfn main() {\n  let f = File::open(\"hello.txt\"); // Result 객체를 반환한다.\n\n  let f = match f {\n    Ok(file) => file, // 파일이 정상적으로 열렸다면 파일 객체를 반환한다.\n    Err(error) => {\n      panic!(\"There was a problem opening the file: {:?}\", error) // 에러를 처리한다.\n    },\n  };\n}\n```\n\n이어서 설명하면 ROP는 굉장히 단순하다. 간단하게 요약하면 **로직은 성공 혹은 실패로 나뉘고 그에 따라 새로운 선로를 설치**해서 신뢰할 수 있는 소프트웨어를 구축한다는 방법론이다.\n\n<Image src=\"/images/2023-07-17-railway-oriented-programming/rail.png\" caption=\"성공 혹은 실패\" />\n\n이를 위해 기본적으로 위에서 구현한 **Result라는 모나드 객체를 사용**하고 에러를 체크하는 것은 어떤 방법을 사용하더라도 상관없다. 중요한 것은 **ROP라는 방법론의 철학을 이해**하는 것이다. ROP는 다음과 같은 철학을 따른다.\n* 모든 기능은 순차적으로 실행된다.\n* 모든 기능은 성공 혹은 실패로 나뉜다.\n* 프로그램은 패닉이 발생하면 안된다.\n\n이렇게 간단한 철학을 따르면서도 ROP는 사고적으로 굉장히 강력한 방법론이다. 우리는 프로그래밍을 할 때 항상 기능에 대한 추상화를 한다. ROP에선 **기능을 선로에 빗대어 추상화**하며 선로를 구성하는 기능들은 모두 성공 혹은 실패로 나눈다. 이렇게 추상화를 하면 **기능의 단위를 성공과 실패로 나눌 수 있는 적절한 크기로 나누게 되므로** 구현과 리팩토링 하는 것이 편해진다.\n\n또한, 모든 기능을 **순차적으로 실행하기 때문에 프로그램의 흐름을 이해하기 쉬워지고 가독성이 좋아진다**. 이러한 장점들을 통해 ROP는 신뢰할 수 있는 소프트웨어를 구축하는데 도움을 준다. 이제 Result에 대한 추가적인 내용에 대해 알아보자.\n\n## 복구 선로\n이미 Result를 구현한 시점에서 ROP의 설명은 거의 끝났다고 볼 수 있다. 하지만 앞서 설명하지 않은 내용 중 **복구**라는 개념이 있다. ROP는 세 가지 선로로 분류된다.\n* 성공 선로\n* 실패 선로\n* 복구 선로\n\n성공 선로는 간단하다. 우리가 생각했던 베스트 케이스대로 로직이 구성되는 것이다. 반면 실패 선로는 각각의 선로를 지나가던 중(함수를 실행하는 도중) 문제가 발생하여 실패하는 경우다. 복구 선로는 실패 선로를 지나가던 중 문제가 발생했지만 복구할 수 있는 경우이다. 그러면 다시 성공 선로로 이동한다. 이미 펑터와 모나드를 설명하며 성공 선로와 실패 선로를 구축하는 것은 Result를 구현하며 보았기 때문에 복구하는 방법을 살펴보자.\n\n복구 선로를 만드는 함수는 `rescue` 혹은 `recover`라는 이름으로 구현된다. 어떤 이름을 사용하던 상관은 없다. 다음 코드를 살펴보자.\n\n```kotlin\nsealed class Result<out V, out E> {\n  data class Success<out V>(val value: V): Result<V, Nothing>()\n  data class Failure<out E>(val error: E): Result<Nothing, E>()\n}\n\n// Other functions...\n\nfun <V, E> Result<V, E>.recover(f: (E) -> V): Result.Success<V> {\n  return when (this) {\n    is Result.Success -> this\n    is Result.Failure -> Result.Success(f(error))\n  }\n}\n\nfun main() {\n  val result = sum(it, 10)\n    .flatMap { divide(it, 0) }\n    .recover { 0 } // 복구 선로 후에는 무조건 Success다.\n\n  println(result.value) // 0\n}\n```\n\n필자는 `recover`라는 함수를 구현하여 실패에 대한 처리를 할 수 있도록 구현했다. 위 코드를 보다시피 매우 간단하다.\n\n## 에러 타입 제한\n\ntry-catch의 경우 어떤 에러가 발생할지 알기 어렵다는 점이 있다. 그래서 사용할 함수 내부를 파악하고 사용하는 쪽 `throw`에서 분기 혹은 타입 패턴 매칭을 사용하는 경우가 많다. 하지만 Result를 사용하면 에러를 구분하여 처리할 수 있다. 다음 코드를 살펴보자.\n\n```kotlin\nsealed class NumberException: RuntimeException() {\n  data class DivideByZero(override val message: String): NumberException()\n  data class TooBig(override val message: String): NumberException()\n  data class TooSmall(override val message: String): NumberException()\n}\n\nfun sum(a: Int, b: Int): Result<Int, NumberException> {\n  val result = a + b\n  if (result > 100) return Result.Failure(NumberException.TooBig(\"Too Big\"))\n  if (result < 0) return Result.Failure(NumberException.TooSmall(\"Too Small\"))\n\n  return Result.Success(result)\n}\n\nfun divide(a: Int, b: Int): Result<Int, NumberException> {\n  if (b == 0) return Result.Failure(NumberException.DivideByZero(\"Divide By Zero\"))\n  return Result.Success(a / b)\n}\n\nfun main() {\n  val result = sum(5, 10)\n    .flatMap { divide(it, 0) }\n    .recover {\n      when (it) {\n        is NumberException.DivideByZero -> -1\n        is NumberException.TooBig -> 100\n        is NumberException.TooSmall -> 0\n      }\n    }\n\n  println(result.value) // -1\n}\n```\n\n위 코드에서 `recover`와 `when` 부분을 보자. `sealed clas`를 통해 제한된 타입을 패턴 매칭을 통해 안전하게 처리하는 것을 볼 수 있다. 이를 통해 더욱 더 안전하게 예외를 관리할 수 있다.\n\n## Monad Comprehension\n\n`flatMap`을 사용하여 박스를 중첩하지 않아도 된다는 것을 앞서 배웠다. 웬만하면 `flatMap`만으로 깔끔하게 코드를 작성하는 것이 가능하지만 다음과 같은 경우가 있을 수 있다.\n\n```kotlin\nfun main() {\n  val result = getUserById(1)\n    .flatMap { user ->\n      getAllPosts()\n        .map { posts ->\n          posts.filter { it.userId == user.id } // user가 필요하다.\n        }\n    }\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  }\n}\n```\n\n위 코드를 보면 `flatMap`을 사용하여도 점점 Nested 되기 때문에 코드가 복잡하다. 위 코드처럼 선행된 값을 알아야하기 때문에 Nested한 코드를 어쩔 수 없이 작성하는 경우가 많다. 이를 해결하기 위해 `Monad Comprehension`이라는 것을 사용할 수 있다. 다만, 이 글에서 예제 코드를 위해 전반적으로 사용하는 Kotlin에선 Monad Comprehension을 지원하지 않는다. 이 기능을 제공하는 언어는 대표적으로 Scala와 Haskell이 있다. 여기서는 Scala 예제를 통해 Monad Comprehension을 살펴보자.\n\n```scala\ndef getUserById(id: Int): Either[Exception, User] = {\n  // ...\n}\n\ndef getAllPosts(): Either[Exception, List[Post]] = {\n  // ...\n}\n\ndef main(args: Array[String]) = {\n  val result = for {\n    user <- getUserById(1)\n    posts <- getAllPosts().map(_.filter(_.userId == user.id))\n  } yield posts.map(_.title)\n\n  result match {\n    case Right(posts) => println(posts)\n    case Left(e) => println(e)\n  }\n}\n```\n\n위 코드에서 `for ~ yield` 부분이 For Comprehension이라 부르는 문법으로 Monad Comprehension을 쉽게 사용할 수 있게 해주는 Syntactic Sugar 문법이다. 이런식으로 Nested를 제거할 수 있다. 참고로 Kotlin에서 이 문법 흉내내기 위해서 Context Receiver라는 것을 사용할 수 있다.\n\n```kotlin\nfun main() {\n  val result: Result<List<String>, Throwable> = binding {\n    val user = getUserById(1).bind()\n    val posts = getAllPosts().bind()\n    posts.filter { it.userId == user.id }.map { it.title }\n  }\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  }\n}\n```\n\n여기서 Context Receiver를 이용한 구현은 이 글의 범위를 벗어나기 때문에 생략한다. 만약 이에 대해 궁금하다면 [ArrowKt 공식 홈페이지](https://arrow-kt.io/learn/design/receivers-flatmap/)를 참고하길 바란다.\n\n## 중첩 컨테이너 문제\n\n만약 Result를 다른 모나드와 함께 사용하고 싶다면 어떻게 해야할까? 예를 들면, 위에서 만든 Option 모나드를 함께 사용하고 싶을 수도 있다. 다음 코드를 살펴보자.\n\n```kotlin\nfun getUserById(id: Int): Result<Option<User>, Throwable> {\n  // ...\n}\n\nfun getPostByUserId(userId: Int): Result<Post, Throwable> {\n  // ...\n}\n\nfun main() {\n  val result = getUserById(1)\n    .flatMap { user ->\n      when (user) { // user는 Option<User> 타입이다.\n        is Option.Some -> {\n          getPostsByUserId(user.value.id)\n            .map { posts -> \n              posts.map { it.title } \n            }\n        }\n        is Option.None -> Result.Failure(Throwable(\"User not found\"))\n      }\n    }\n\n  when (result) {\n    is Result.Success -> println(result.value)\n    is Result.Failure -> println(result.error)\n  }\n}\n```\n\n위 코드를 보면 `getUserById` 함수가 `Result<Option<User>, Throwable>` 타입이기 때문에 중간에 패턴 매칭을 통해 박스를 벗겨내는 것을 볼 수 있다. 여기서는 `Option`을 Nullable로 대체하면 해결할 수 있지만 실제로 여러 모나드를 사용할 경우 점점 코드가 복잡해질 수 있다. 이처럼 이미 다른 모나드를 주력으로 사용하고 있는 상황이라면 문제가 될 수 있다. 예를 들어, Spring 환경에서 Reactive Programming을 위해 Mono, Flux 등을 사용하는 경우 혹은 Rx 계열 라이브러리를 사용하는 경우를 예시로 들 수 있다.\n\n이를 해결하기 위해서는 **Higher-Kinded Type**(이하 HKT)이라는 개념이 필요하다. 다만, 안타깝게도 몇 언어를 제외하면 HKT를 제공하는 언어는 드물기 때문에 이 문제를 해결하기는 쉽지 않다. 이 글 전반적으로 사용되는 Kotlin에선 해당 기능을 제공하지 않는다.\n\nScala에선 HKT를 지원한다. 이를 통해 **Monad Transfomer**이라는 것을 구현할 수 있는데, 이를 통해 문제를 해결할 수 있다.\n\n```scala\ndef getUserById(id: Int): Either[Exception, Option[User]] = {\n  Right(Option(User(1, 30)))\n}\n\ndef getPostsByUserId(userId: Int): Either[Exception, List[Post]] = {\n  Right(List(Post(\"A\"), Post(\"B\")))\n}\n\ndef main(args: Array[String]): Unit = {\n  val result = for {\n    // OptionT 타입은 cats 라이브러리를 통해 사용했다.\n    user <- OptionT(getUserById(1))\n    posts <- OptionT.liftF(getPostsByUserId(user.id))\n  } yield posts.map(_.title)\n\n  result.value match {\n    case Right(posts) => println(posts)\n    case Left(e) => println(e)\n  }\n}\n```\n\n위 코드를 보다시피 Nested한 코드가 제거되어 조금 더 깔끔한 모습을 볼 수 있다. 아쉽게도 이를 지원하지 않는 언어는 사용이 불가능하다. 따라서 ROP를 도입하고 싶은 개발자는 자신의 환경을 고려할 필요가 있다.\n\n# 마치며\n\nROP를 사용한다면 조금 더 안전하고 직관적인 코딩을 할 수 있다. 다만, 환경에 따라 사용하기 힘들 수 있으니 이를 고려하여 사용하도록 하자. 또한, ROP를 사용하더라도 모든 함수에 대해 Result를 사용하는 것은 권장하지 않는다. 이는 코드의 가독성을 떨어뜨릴 수 있기 때문이다. 따라서, 필요한 함수에 대해서만 사용하는 것이 좋다.","tableOfContents":{"items":[{"url":"#사이드-이펙트","title":"사이드 이펙트"},{"url":"#다양한-해결-방법","title":"다양한 해결 방법","items":[{"url":"#lbyl","title":"LBYL","items":[{"url":"#순수-함수","title":"순수 함수"},{"url":"#guard-clause-패턴","title":"Guard Clause 패턴"}]},{"url":"#eafp","title":"EAFP","items":[{"url":"#try-catch-문법","title":"try-catch 문법"},{"url":"#functor와-monad","title":"Functor와 Monad","items":[{"url":"#functor","title":"Functor"},{"url":"#monad","title":"Monad"}]}]}]},{"url":"#railway-oriented-programming","title":"Railway-Oriented Programming","items":[{"url":"#복구-선로","title":"복구 선로"},{"url":"#에러-타입-제한","title":"에러 타입 제한"},{"url":"#monad-comprehension","title":"Monad Comprehension"},{"url":"#중첩-컨테이너-문제","title":"중첩 컨테이너 문제"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"프로그램을 개발함에 있어 에러와 사이드 이펙트(부수 효과)를 처리하는 것은 필연적이다. 아무리 꼼꼼하게 코드를 작성해도 생각하지 못한 문제는 존재하며 특히나 지속해서 발전하는 프로그램은 기술 부채와 함께 끊임없이 새로운 문제가 발생한다. 문제가…","fields":{"slug":"/posts/railway-oriented-programming","date":"2023-07-17"},"frontmatter":{"title":"Railway-Oriented Programming","categories":"article","tags":["functional","error-handling","railway-oriented-programming"],"image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-26","slug":"/posts/living-with-ai"},"frontmatter":{"title":"AI와 더불어 살아가기","image":"/images/2024-04-26-living-with-ai/thumbnail.png"}}},{"node":{"fields":{"date":"2024-06-12","slug":"/posts/log-5"},"frontmatter":{"title":"Log#5 | 삽질을 존중하는 문화","image":null}}},{"node":{"fields":{"date":"2024-06-11","slug":"/posts/log-4"},"frontmatter":{"title":"Log#4 | AI 시대, 결국 내 자리는 없어질까?","image":null}}},{"node":{"fields":{"date":"2024-06-10","slug":"/posts/log-3"},"frontmatter":{"title":"Log#3 | 인간적인 코드","image":null}}},{"node":{"fields":{"date":"2024-06-09","slug":"/posts/log-2"},"frontmatter":{"title":"Log#2 | 잃어버린 집중력 되찾기","image":null}}},{"node":{"fields":{"date":"2024-06-08","slug":"/posts/log-1"},"frontmatter":{"title":"Log#1 | 나를 위한 글쓰기","image":null}}}]}},"pageContext":{"slug":"/posts/railway-oriented-programming","frontmatter":{"title":"Railway-Oriented Programming","categories":"article","tags":["functional","error-handling","railway-oriented-programming"],"image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png","comments":true,"draft":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}