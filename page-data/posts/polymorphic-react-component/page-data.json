{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2022-08-16-polymorphic-react-component-mdx","path":"/posts/polymorphic-react-component/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n들어가기에 앞서 **Polymorphism**은 한국어로 다형성이라고 부르는데, `여러 개의 형태를 가진다`라는 의미를 가진 그리스어에서 유래된 단어다. 그럼 이 글의 제목에 포함된 **Polymorphic**은 `다형의` 혹은 `다양한 형태의` 등으로 표현할 수 있을 것이다. 컴퓨터 과학에서 다형성은 프로그래밍적인 요소가 여러 형태로 표현 될 수 있는 것을 의미하는데 보통은 객체가 여러 자료형으로 나타날 수 있음을 표현할 때 사용한다.\n\n그럼 Polymorphic한 UI 컴포넌트는 `다양한 형태의 UI 컴포넌트`라고 바꿔 말할 수 있을 것이다. 필자는 이 말이 다음과 같은 내용을 담고 있다고 생각한다.\n\n* 다양한 Semantic을 표현할 수 있는 UI 컴포넌트\n* 다양한 속성을 가질 수 있는 UI 컴포넌트\n* 다양한 스타일을 가질 수 있는 UI 컴포넌트\n\n좀 더 풀어서 설명하자면 웹 프론트엔드에서의 Polymorphic 컴포넌트는 코드에 따라 어떠한 요소(Element)도 될 수 있고 그에 따른 속성(Attribute)도 사용할 수 있다. 즉, 상황에 맞는 Semantic을 사용할 수 있고 앵커 태그처럼 특수한 용도로 사용되는 컴포넌트가 될 수도 있다. 결국 **無의 형태**에서 **무엇이든지 될 수 있는 컴포넌트**가 되는 것이 Polymorphic 컴포넌트고 가장 추상화된 형태의 컴포넌트라고 볼 수 있다.\n\n<Image src=\"/images/2022-08-16-polymorphic-react-component/step.png\" caption=\"최종적으로 사용자에게 보이는 컴포넌트는 이러한 구현 과정을 거친다\" />\n\n그래서 Polymorphic 컴포넌트는 React와 관련된 UIKit을 뜯어보면 높은 확률로 사용되고 있는 패턴이다. 예를 들면, MUI의 [Box](https://mui.com/material-ui/react-box/) 컴포넌트나 Mantine의 [Box](https://mantine.dev/core/box/) 컴포넌트를 예시로 들 수 있다. 두 UI 라이브러리는 Box라는 Polymorphic한 컴포넌트를 이용하여 재사용성을 높이고 다양한 컴포넌트를 확장성 있게 구현하고 있다. 굉장히 유용한 컴포넌트기 때문에 필자가 재직 중인 회사에서 만들고 사용하는 [디자인 시스템](https://github.com/cobaltinc/co-design)에도 View 컴포넌트를 구현하여 비슷하게 사용하고 있다.\n\n아쉽게도 Polymorphic 컴포넌트와 관련된 자료는 한국어로 작성된 자료가 거의 없고 영문으로도 구체적인 설명한 자료는 찾기 힘들어 이번 기회에 관련된 내용을 포스팅 해보기로 했다.\n\n# 문제 인식하기\n\n실제 사례를 보지 않는다면 이 컴포넌트가 왜 필요한지 모를 수 있다. 다음 코드를 살펴보자.\n\n```jsx\n/**\n * Button.jsx\n */\nexport const Button = ({ ...props }) => {\n  return (\n    <button \n      style={{ backgroundColor: 'black', color: 'white' }} \n      {...props} \n    />\n  );\n}\n\n/**\n * App.jsx\n */\nimport { Button } from './Button';\n\nconst App = () => {\n  return (\n    <div>\n      <Button onClick={() => alert('Good!')}>Click Me!</Button>\n    </div>\n  );\n}\n```\n\n설명이 필요 없을 정도로 간단한 코드다. 단순하게 표현했지만 위 코드처럼 스타일만 적용한 컴포넌트는 실제로도 많이 사용된다. Button 컴포넌트는 prop으로 넘기는 값을 button 태그의 속성으로 전부 넘기기 때문에 꽤 확장성 있게 사용할 수 있는 컴포넌트라고 생각할 수 있다. 그런데 만약 버튼에 페이지 링크를 추가하고 싶다면 어떻게 해야 할까?\n\n```jsx\nimport { Button } from './Button';\n\nconst App = () => {\n  return (\n    <div>\n      <a href=\"https://kciter.so\">\n        <Button>Click Me!</Button>\n      </a>\n    </div>\n  );\n}\n```\n\n위 처럼 작성할 수도 있겠지만 재사용성 측면에선 그다지 좋은 방법은 아니다. 추후 재사용을 고려하여 새로운 컴포넌트를 만들 수도 있다.\n\n```jsx\n/**\n * Button.jsx\n */\nexport const Button = ({ ...props }) => {\n  return (\n    <button \n      style={{ backgroundColor: 'black', color: 'white' }} \n      {...props} \n    />\n  );\n}\n\n/**\n * LinkButton.jsx\n */\nimport { Button } from './Button';\n\nexport const LinkButton = ({ href, ...props }) => {\n  return (\n    <a href={href}>\n      <Button {...props} />\n    </a>\n  );\n}\n\n/**\n * App.jsx\n */\nimport { LinkButton } from './LinkButton';\n\nconst App = () => {\n  return (\n    <div>\n      <LinkButton href=\"https://kciter.so\">Click Me!</LinkButton>\n    </div>\n  );\n}\n```\n\n위와 같이 작성할 수도 있지만 이 경우 a 태그가 확장되지 않는다는 문제점이 있고 컴포넌트의 의존 관계가 새롭게 추가된다는 문제점이 있다. 그리고 만약 react-router나 Next.js를 사용하여 SPA를 위한 Link 컴포넌트를 사용한다면 또 새로운 컴포넌트를 만들어줄 수 밖에 없다. 이 문제의 해결법으로 Polymorphic 컴포넌트를 사용할 수 있다.\n\n# JavaScript에서 구현하기\n\n사실 JavaScript에선 Type-safe에 자유롭기 때문에 Polymorphic 컴포넌트를 구현하는 것이 어렵지 않다. 이런 부분은 JavaScript 약점이지만 한편으로는 구현의 편리함으로서 강점이 될 수도 있다. 다음과 같이 아주 간단하게 Polymorphic한 컴포넌트를 만들 수 있다.\n\n```jsx\nexport const View = forwardRef(({ as, ...props }, ref) => {\n  const Element = as || \"div\";\n  return <Element ref={ref} {...props} />;\n});\n```\n\n여기서 구현한 View 컴포넌트는 React에서 가장 추상적인 컴포넌트다. `as`를 통해 기본 내장된 컴포넌트를 포함하여 어떠한 컴포넌트로도 될 수 있다. 만약 생략한다면 기본적으로 `div`를 사용하게 된다. 이때, 필요한 속성이 있다면 자유롭게 넘길 수 있도록 컴포넌트를 작성하고 `forwardRef`를 통해 부모 컴포넌트에서 요소에 접근할 수 있도록 만들었다. 이 컴포넌트는 다음과 같이 사용할 수 있다.\n\n```jsx\nimport { View } from './View';\n\nconst App = () => {\n  return (\n    <div>\n      <View as=\"a\" href=\"https://kciter.so\">Click Me!</View>\n    </div>\n  );\n}\n```\n\n코드를 살펴보면 `as`를 통해 View 컴포넌트에 사용되는 요소를 a 태그로 변경하고 `href` 속성을 사용한 것을 볼 수 있다. 그럼 이 코드를 실행하면 [Click Me!](https://kciter.so)라는 링크가 보이게 된다. 사실 이렇게만 사용하면 왜 사용하는지 이해가 안가는 것이 당연하다. 그냥 바로 a 태그를 쓰면 되니 번거롭게 컴포넌트를 만들 필요가 없기 때문이다. 그렇지만 위 코드를 응용하여 다음과 같이 사용하는 것도 가능하다.\n\n```jsx\n/**\n * Button.jsx\n */\nimport View from './View';\n\nexport const Button = ({ as, ...props }) => {\n  return (\n    // 위에서 만들어둔 View 컴포넌트를 이용했다.\n    <View as={as || 'button'}\n      style={{ backgroundColor: 'black', color: 'white' }} \n      {...props} \n    />\n  );\n}\n\n// 혹은 다음과 같이 작성할 수 있다.\nexport const Button = ({ as, ...props }) => {\n  const Element = as || 'button';\n  return (\n    <Element\n      style={{ backgroundColor: 'black', color: 'white' }} \n      {...props} \n    />\n  );\n}\n\n/**\n * App.jsx\n */\nimport { Button } from './Button';\n\nconst App = () => {\n  return (\n    <div>\n      // 마치 앵커 태그처럼 사용할 수 있다.\n      <Button as=\"a\" href=\"https://kciter.so\">Click Me!</Button>\n    </div>\n  );\n}\n```\n\n다시 [문제 인식하기](#문제-인식하기) 부분을 살펴보면 이때는 `LinkButton`이라는 컴포넌트를 만드는 것으로 요구사항을 충족했었다. 만약 위 코드처럼 Polymorphic 하도록 컴포넌트를 작성한다면 중복 코드를 제거하고 조금 더 유연하게 컴포넌트를 사용할 수 있게 된다. 생각보다 이런 사례가 많고 구현이 간단하기 때문에 좋은 컴포넌트 설계라고 볼 수 있다.\n\n# TypeScript에서 구현하기\n\nJavaScript를 쓸 때 아쉬운 점은 IntelliSense[^1]를 사용할 수 없다는 점이다. 어느 정도 자동 완성을 해주긴 하지만 TypeScript의 강력함에 비하면 좀 아쉽다. 위 코드도 `as`를 통해 다른 요소를 사용하도록 변경했지만 어떤 속성을 넘길 수 있을지는 개발자가 잘 판단하여야 한다. 혹은 개발자가 오타를 내어 잘못된 값을 `as`로 전달할 수도 있다. 이런 문제점은 TypeScript를 통해 Type-safe한 Polymorphic 컴포넌트를 구현하면 해결할 수 있다.\n\n## 요소와 속성 표현하기\n\nJavaScript에서 사용한 코드와 똑같이 사용할 수 있도록 만들면서 자동 완성 기능까지 사용하려면 타입 정의가 필요하다. 우선 다음 코드를 확인해보자.\n\n```tsx\n/**\n * View.tsx\n */\ninterface ViewProps<T extends React.ElementType> {\n  as?: T;\n}\n\nexport const View = <T extends React.ElementType = \"div\">({\n  as,\n  ...props\n}: ViewProps<T>) => {\n  const Element = as || \"div\";\n  return <Element {...props} />;\n};\n\n/**\n * App.tsx\n */\nimport { View } from \"./components/View\";\n\nconst App = () => {\n  return (\n    // 컴포넌트 부분에 에러가 발생한다.\n    <View as=\"a\" href=\"https://kciter.so\">\n      Link\n    </View>\n  );\n}\n\nexport default App;\n```\n\n`React.ElementType`은 JSX 내장 컴포넌트 또는 사용자 정의 컴포넌트를 둘 다 받을 수 있는 타입으로 `string | React.ComponentType<any>`로 정의되어있다. 이 타입과 제네릭을 사용하면 위 JavaScript 코드에서 했던 것처럼 `as`를 통해 사용하려는 요소를 바꿀 수 있게 된다.\n\n하지만 위와 같이 View 컴포넌트를 작성하면 `as`를 통해 사용하려한 요소가 어떤 것인지 알 수가 없다. 따라서 다음과 같은 에러가 발생하게 된다.\n\n<Image src=\"/images/2022-08-16-polymorphic-react-component/error-message-1.png\" />\n\n에러 메시지를 살펴보면 prop으로 넘긴 값들이 타입에 맞지 않는다는 것을 알 수 있다. 이를 위해 다음과 같이 View 컴포넌트를 수정할 수 있다.\n\n```tsx\ntype ViewProps<T extends React.ElementType> = {\n  as?: T;\n} & React.ComponentPropsWithoutRef<T>;\n\nexport const View = <T extends React.ElementType = \"div\">({\n  as,\n  ...props\n}: ViewProps<T>) => {\n  const Element = as || \"div\";\n  return <Element {...props} />;\n};\n```\n\n`React.ComponentPropsWithoutRef`은 `ref`를 제외한 나머지 속성을 정의할 수 있게 해주는 타입이다. 이 타입을 이용하면 제네릭을 통해 나머지 속성에 대한 것을 알 수 있게 된다. 하지만 아직 `ref`는 받아올 수 없다.\n\n## ref 받아오기\n\n여기까지는 이해하는 것이 어렵지는 않았을 것이다. 코드 양이 많은 것도 아니기 때문에 생각보다 쉽게 구현할 수 있다. 그렇지만 `ref`까지 사용하게 된다면 조금 복잡해진다. 일단 다음 코드를 살펴보자.\n\n```tsx\ntype ViewProps<T extends React.ElementType> = {\n  as?: T;\n} & React.ComponentPropsWithoutRef<T>;\n\nexport const View = forwardRef(\n  <T extends React.ElementType = \"div\">(\n    { as, ...props }: ViewProps<T>,\n    ref: React.ComponentPropsWithRef<T>[\"ref\"] // ref만 받아오도록\n  ) => {\n    const Element = as || \"div\";\n    return <Element ref={ref} {...props} />;\n  }\n);\n```\n\n만약 위에와 같이 이미 제공되는 `React.ComponentPropsWithRef` 타입을 사용하면 쉽게 해결됐다고 생각할 수 있겠지만 다음과 같이 `unknown`으로 타입을 알 수 없다는 것을 알 수 있다. 이러면 제대로된 타입이 아니어도 에러가 발생하지 않는다.\n\n<Image src=\"/images/2022-08-16-polymorphic-react-component/ref-unknown-type.png\" caption=\"잘못된 타입인 ref가 들어갔음에도 에러가 발생하지 않는다\" />\n\n이런 일이 발생한 이유는 아직 `forwardRef`에 대한 타입이 모호하기 때문이다. 제대로 정의된 것 처럼 보이지만 제네릭은 함수 파라메터에만 적용되었을 뿐 함수 자체엔 적용되지 않았다. 따라서 `forwardRef`에 대한 제네릭 타입 정의가 필요하다. 타입 정의를 위해 `forwardRef` 함수가 어떻게 정의되었는지 확인해보자.\n\n```ts\nfunction forwardRef<T, P = {}>(render: ForwardRefRenderFunction<T, P>): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\n\ninterface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\n  defaultProps?: Partial<P> | undefined;\n  propTypes?: WeakValidationMap<P> | undefined;\n}\n\ninterface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\n  displayName?: string | undefined;\n}\n\ninterface ExoticComponent<P = {}> {\n  (props: P): (ReactElement|null);\n  readonly $$typeof: symbol;\n}\n```\n\n여기서 `forwardRef` 함수의 반환 타입을 살펴보면 `ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>`으로 되어있다. `ForwardRefExoticComponent`는 최종적으로 `ExoticComponent` 인터페이스를 상속받는데 내용을 살펴보면 결국 함수 컴포넌트의 형태가 되는 것을 알 수 있다.\n\n따라서 `PropsWithoutRef<P> & RefAttributes<T>`를 View 컴포넌트의 타입으로 만들어주면 된다. `RefAttributes`는 다음과 같이 정의되어 있다.\n\n```ts\ninterface RefAttributes<T> extends Attributes {\n  ref?: Ref<T> | undefined;\n}\n```\n\n`ComponentPropsWithRef`에는 이미 `RefAttributes`이 결합되어 있기 때문에 다음과 같이 선언하여 View 컴포넌트를 완성할 수 있다.\n\n```tsx\ntype ViewProps<T extends React.ElementType> = {\n  as?: T;\n} & React.ComponentPropsWithoutRef<T>;\n\ntype ViewComponent = <C extends React.ElementType = \"div\">(\n  props: ViewProps<C> & {\n    ref?: React.ComponentPropsWithRef<C>[\"ref\"];\n  }\n) => React.ReactElement | null;\n\nexport const View: ViewComponent = forwardRef(\n  <T extends React.ElementType = \"div\">(\n    { as, ...props }: ViewProps<T>,\n    ref: React.ComponentPropsWithRef<T>[\"ref\"]\n  ) => {\n    const Element = as || \"div\";\n    return <Element ref={ref} {...props} />;\n  }\n);\n```\n\n위 코드를 반영하고나서 다시 App 컴포넌트를 확인하면 ref의 타입을 `HTMLDivElement`로 사용하여 컴포넌트 타입과 일치하지 않기 때문에 에러가 발생하는 것을 확인할 수 있다.\n\n<Image src=\"/images/2022-08-16-polymorphic-react-component/error-message-2.png\" caption=\"잘못된 ref가 들어가 에러가 발생한다\" />\n\n이제 `useRef`의 제네릭 타입을 `HTMLAnchorElement`로 변경해주면 정상적으로 실행되는 것을 볼 수 있다.\n\n## 범용성 있게 사용하기\n\n여기까지 왔으면 대체로 복잡한 내용은 끝난 셈이다. 지금까지는 View 컴포넌트만을 위하여 타입을 정의했는데 타입을 한 단계 더 추상화하여 조금 더 범용적으로 쓸 수 있게 만들어보자.\n\n```ts\n// 기존 작성한 ViewProps에서 as를 분리한다.\ntype AsProp<T extends React.ElementType> = {\n  as?: T;\n};\n\n// 직관적인 이름을 붙여서 타입으로 만들어준다.\nexport type PolymorphicRef<T extends React.ElementType> =\n  React.ComponentPropsWithRef<T>[\"ref\"];\n\n// 결합 타입을 만든다.\nexport type PolymorphicComponentProps<\n  T extends React.ElementType,\n  Props = {}\n> = AsProp<T> & React.ComponentPropsWithoutRef<T> & Props & {\n  ref?: PolymorphicRef<T>;\n};\n```\n\n기존 `ViewProps` 타입을 분해하고 `PolymorphicComponentProps`라는 제네릭 타입을 만들어서 필요한 속성을 추가할 수 있도록 만들었다. 이렇게 만든 타입을 통해 새로운 컴포넌트를 만들어보자.\n\n```tsx\ntype _TextProps = {\n  size: number;\n  color: string;\n};\n\nexport type TextProps<T extends React.ElementType> = \n  PolymorphicComponentProps<T, _TextProps>;\n\ntype TextComponent = <T extends React.ElementType = \"span\">(\n  props: TextProps<T>\n) => React.ReactElement | null;\n\nexport const Text: TextComponent = forwardRef(\n  <T extends React.ElementType = \"span\">(\n    { as, size, color, ...props }: TextProps<T>,\n    ref: PolymorphicRef<T>[\"ref\"]\n  ) => {\n    const Element = as || \"span\";\n    // size와 color를 style로 적용\n    return <Element ref={ref} {...props} style={{ fontSize: size, color }} />;\n  }\n);\n```\n\n`PolymorphicComponentProps`를 통해 속성 확장 가능한 Polymorphic 컴포넌트를 아주 쉽게 만들어냈다. 여기서는 `size`와 `color`를 새롭게 추가했다. 다음과 같이 사용할 수 있다.\n\n```tsx\nconst App = () => {\n  return (\n    <View>\n      <View as=\"a\" href=\"https://kciter.so\">\n        Link\n      </View>\n      <Text as=\"div\" color=\"red\" size={50}>\n        Text\n      </Text>\n    </View>\n  );\n};\n```\n\n결과 화면을 살펴보면 다음과 같이 제대로 적용된 것을 확인할 수 있다.\n\n<Image src=\"/images/2022-08-16-polymorphic-react-component/result.png\" caption=\"업데이트가 거슬리는 분께는 심심한 사과를 드린다\" />\n\n# 마치며\n이렇게 꽤 다양한 곳에서 활용 가능한 Polymorphic 컴포넌트를 구현할 수 있다. 이런 컴포넌트를 만드는 패턴은 요즘 유행하는 UI 라이브러리에선 대부분 사용하고 있기 때문에 알아두면 도움이 될 것이다. 이 포스팅을 통해 만들어진 최종적인 코드는 [GitHub 저장소](https://github.com/kciter/polymorphic-react-component-sample)에서 확인할 수 있다.\n\n아직 글 서두에서 소개한 MUI의 [Box](https://mui.com/material-ui/react-box/) 컴포넌트나 Mantine의 [Box](https://mantine.dev/core/box/) 컴포넌트처럼 **스타일 확장 가능한 컴포넌트**까지는 다루지 못했다. 원래 이 부분까지 다루는 것이 필자의 목표였으나 너무 길어져서 완성하는데 오래걸릴 것 같아 쓰지 못했지만 빠른 시일 내에 추가로 글을 작성할 예정이다.\n\n[^1]: Visual Studio 계열 IDE에서 제공하는 자동 완성 기능","tableOfContents":{"items":[{"url":"#문제-인식하기","title":"문제 인식하기"},{"url":"#javascript에서-구현하기","title":"JavaScript에서 구현하기"},{"url":"#typescript에서-구현하기","title":"TypeScript에서 구현하기","items":[{"url":"#요소와-속성-표현하기","title":"요소와 속성 표현하기"},{"url":"#ref-받아오기","title":"ref 받아오기"},{"url":"#범용성-있게-사용하기","title":"범용성 있게 사용하기"}]},{"url":"#마치며","title":"마치며"}]},"excerpt":"들어가기에 앞서 Polymorphism은 한국어로 다형성이라고 부르는데, 라는 의미를 가진 그리스어에서 유래된 단어다. 그럼 이 글의 제목에 포함된 Polymorphic은  혹은  등으로 표현할 수 있을 것이다. 컴퓨터 과학에서 다형성은…","fields":{"slug":"/posts/polymorphic-react-component","date":"2022-08-16"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","categories":"dev","tags":["react","ui","component","frontend"],"image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"Deep Dive into DateTime","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/polymorphic-react-component","series":{"title":"리액트 컴포넌트 시리즈","items":[{"title":"Polymorphic한 React 컴포넌트 만들기","url":"/posts/polymorphic-react-component"},{"title":"Render Delegation하는 React 컴포넌트 만들기","url":"/posts/render-delegation-react-component"}]},"frontmatter":{"series":"리액트 컴포넌트 시리즈","title":"Polymorphic한 React 컴포넌트 만들기","categories":"dev","tags":["react","ui","component","frontend"],"image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png","comments":true,"draft":false}}},"staticQueryHashes":["63159454"],"slicesMap":{}}