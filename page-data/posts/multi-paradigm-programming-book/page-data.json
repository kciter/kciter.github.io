{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-04-25-multi-paradigm-programming-book-mdx","path":"/posts/multi-paradigm-programming-book/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n> 우리는 함수형, 객체지향, 명령형 패러다임을 제공하는 멀티패러다임 언어를 효율적으로 활용하는 법을 배워야 한다. - 마이크 루키데스\n\n좋은 계기로 마플코퍼레이션 CTO 유인동님이 집필하신 [멀티패러다임 프로그래밍](https://product.kyobobook.co.kr/detail/S000216318962)을 먼저 읽어보고 추천사까지 남길 수 있었습니다. 좋은 책에 추천사까지 남길 수 있어 영광이라 생각합니다.\n\n이번 글에서는 이 책을 읽고 간단한 요약과 제 개인적인 소감도 남겨보려 합니다.\n\n# 멀티패러다임 프로그래밍은 왜 등장했는가?\n\n개발자는 소프트웨어로 문제를 해결하는 사람입니다. 그리고 비즈니스 관점에선 소프트웨어를 통해 가치를 창출하는 사람입니다. 사실, 오늘날의 소프트웨어는 과도한 경쟁으로 인해 빠른 생산성이 없다면 금방 다른 소프트웨어에 대체될 수 있습니다. 그렇기에 소프트웨어는 비즈니스 관점에서 생산성을 높이는 것이 중요합니다.\n\n생산성이 중요해지며 DX(개발자 경험)라는 관점이 부각되기 시작했습니다. 더이상 철학만을 따질 수 없는 상황이 되었고 좋은건 빠르게 도입해야 하는 시대가 온 것입니다. 멀티패러다임은 그런 관점에서 탄생했다고 생각합니다. 가장 많이 언급되는 패러다임인 객체지향과 함수형은 각각 장단점이 존재합니다. 객체지향의 모델링⋅캡슐화⋅메시지, 함수형의 불변성⋅순수성은 대표적인 장점입니다.\n\n멀티패러다임 프로그래밍은 각 패러다임의 장점만을 사용할 수 있게 해줍니다. 예를 들면, 데이터를 모델링하거나 관련한 것을 모아 캡슐화 할 때는 객체지향 관점, 로직의 안정성을 위해 순수 함수, 불변 데이터를 사용할 때는 함수형을 사용하는 방식으로 멀티패러다임 프로그래밍을 할 수 있습니다.\n\n즉, 정리하자면 멀티패러다임 프로그래밍은 생산성이 중요한 시대의 요구에 따라 등장했다고 생각합니다.\n\n# 멀티패러다임 프로그래밍이 뭘까?\n\n사실 프로그래밍 패러다임이라는 것은 매우 모호합니다. 큰 틀은 있지만 명확한 규칙은 없습니다. 예를 들어, 객체지향 프로그래밍은 캡슐화 관점으로 보느냐, 메시징 관점으로 보느냐에 따라 다르게 해석될 수 있습니다. 개인적으로는 멀티패러다임도 여러 해석이 존재할 수 있다고 생각합니다.\n\n패러다임의 철학을 중요하게 생각하지 않는다면 단순히 일급 함수가 존재하며 `map`, `filter`, `reduce`을 사용할 수 있다면 함수형 프로그래밍이라 여길 수도 있습니다. 거기에 클래스를 한 스푼 끼얹으면 멀티패러다임 프로그래밍의 완성이라 생각할 수도 있습니다. 물론 이렇게 말하면 많은 분들께 혼나겠죠.\n\n제가 말하고 싶었던 것은 결국 여러 해석이 존재한다는 것입니다. 그리고 그 해석은 각자 중요하게 여기는 것이 무엇이냐에 따라 다릅니다.\n\n예를 들어, 이 글을 통해 리뷰 중인 '멀티패러다임 프로그래밍'은 객체지향, 함수형, 명령형 패러다임의 교차점에 대해 주목합니다. 객체지향의 캡슐화, 함수형의 불변성과 순수성, 명령형의 제너레이터가 조합되어 더욱 고도화된 코드를 작성할 수 있다고 주장합니다. 조금 더 구체적으로 [반복자 패턴](https://refactoring.guru/ko/design-patterns/iterator)과 일급 함수, 제너레이터의 조합을 통해 좀 더 효과적인 리스트 프로세싱을 할 수 있습니다. 그래서 이러한 방법은 멀티패러다임 프로그래밍이라고 할 수 있습니다.\n\n반면, 최근에 읽었던 [데이터 지향 프로그래밍](https://kciter.so/posts/data-oriented-programming/)에서는 데이터와 코드를 분리하면서 시작합니다. 이 과정에서 데이터 파이프라인을 구성하여 각 단계마다 검증하는 방식으로 안정성을 보장합니다. 제가 느낀점으로, 각 단계에 대한 절차를 만든다는 점에서 프로시저적 프로그래밍 사고가 포함되고 불변으로 처리한다는 관점에서 함수형 프로그래밍 사고가 포함된다고 생각합니다. 따라서 이 방법론 또한 멀티패러다임 프로그래밍이라 할 수 있습니다.\n\n재밌게도 이 두 책은 모두 생산성을 강조합니다. 결국 실용을 추구하며 각자의 방식으로 생산성을 올리는 것, 그것이 멀티패러다임 프로그래밍의 본질이라 생각합니다.\n\n# 리스트 프로세싱\n\n저는 아직도 패러다임엔 우열이 없다고 생각합니다. 사람들이 좋아하지 않는 언어에도 아름다움은 존재하며 언어와 그 언어의 철학적인 맛이 존재합니다. 개발을 사랑하는 사람으로서 그 맛을 느끼는 것은 행복한 일입니다. 그리고 이번 책을 읽으면서 새로운 행복을 얻을 수 있었습니다.\n\n이번에 느낄 수 있는 맛은 바로 리스트 프로세싱입니다. 리스트 프로세싱은 제가 주구장창 주장하는 [좋은 코드](https://kciter.so/posts/what-is-beautiful-code/)를 생산할 수 있는 방법입니다. 다음 코드를 살펴봅시다.\n\n```js\n// JavaScript\nconst numbers = [1, 2, 3, 4, 5];\nreduce(\n  map(\n    filter(numbers, x => x % 2 === 0),\n    x => x * x\n  ),\n  (acc, x) => acc + x,\n  0\n);\n```\n\n위 코드는 주어진 숫자 중 짝수만 필터링하고 제곱을 한 후 모두 더하는 코드입니다. 만약 함수만을 이용해서 로직을 처리하고 싶다면 위와 같이 작성할 수 있습니다. 하지만 이 코드는 가독성이 떨어집니다. 그래서 별도로 다음과 같이 `pipe`와 같은 함수를 만들어 가독성을 높일 수 있습니다.\n\n```js\n// JavaScript\npipe(\n  [1, 2, 3, 4, 5],\n  filter(x => x % 2 === 0),\n  map(x => x * x),\n  reduce((acc, x) => acc + x, 0)\n);\n```\n\n파이프 함수는 커링 함수를 받아 값을 연쇄적으로 처리하는 방식입니다. 이런 방식을 통해 가독성을 더 좋게 만들 수 있습니다. 이러한 파이프 함수 유용하므로 특정 언어에선 별도 연산자로 제공할 때도 있습니다.\n\n```elixir\n# Elixir\n1..5\n|> Enum.filter(fn x -> rem(x, 2) == 0 end)\n|> Enum.map(fn x -> x * x end)\n|> Enum.reduce(0, fn acc, x -> acc + x end)\n```\n\n다만, 커링을 사용해야 한다는 점과 자동 완성 측면에서 불리한 점이 있습니다. 따라서 요즘 언어는 객체를 통한 메서드 체인을 통해 리스트 프로세싱을 지원합니다.\n\n```js\n// JavaScript\nconst result = [1, 2, 3, 4, 5]\n  .filter(x => x % 2 === 0)\n  .map(x => x * x)\n  .reduce((acc, x) => acc + x, 0);\n\nconsole.log(result); // 20\n```\n\n요즘은 대부분의 언어가 이러한 방식을 지원합니다. 많은 개발자들에게 친근하고 자동 완성이 잘되므로 사용하기 쉬운 방법입니다. 이 방식은 객체와 함수의 순수성을 이용하므로 멀티패러다임 프로그래밍의 장점을 잘 살린 방법입니다. (물론 고차 함수의 순수성은 개발자가 보장해야 합니다)\n\n그러나 이렇게 매 함수마다 리스트를 처리하면 성능 이슈가 있을 수 있습니다. 따라서 지연 평가를 사용하여 최적화를 할 수 있습니다. 예를 들어, 책에서 소개하는 [FxTS](https://fxts.dev)를 사용하면 손쉽게 지연 평가를 리스트 프로세싱에 적용할 수 있습니다.\n\n```js\n// JavaScript\n[1, 2, 3, 4, 5, ..., 100]\n  .filter(x => x % 2 === 0)  // [2, 4, 6, ..., 100]\n  .map(x => x * x) // [4, 16, 36, ..., 10000]\n  .take(2) // [4, 16]\n\nconst result = fx([1, 2, 3, ..., 100])\n  .filter(x => x % 2 === 0) // [2, 4]\n  .map(x => x * x) // [4, 16]\n  .take(2) // [4, 16]\n```\n\n이처럼 리스트 프로세싱을 통해 가독성을 높이고 성능을 최적화할 수 있습니다.\n\n조금 색다른 관점으로 보면 [Yegor Bugayenko](https://www.yegor256.com/)라는 개발자는 객체지향에서 리스트 프로세싱을 위한 Composable Decorator라는 개념을 제시하기도 했습니다.\n\n```java\n// Java\nnew Reduced(\n  (acc, x) -> acc + x,\n  new Mapped(\n    x -> x * x,\n    new Filtered(\n      x -> x % 2 == 0,\n      new IterableOf<>(1, 2, 3, 4, 5)\n    )\n  )\n);\n```\n\n해당 방식은 각 기능에 대한 불변 객체를 만들어 조합하는 방식입니다. 객체기 때문에 스스로 상태를 가지고 있을 수 있고, 불변을 보장하도록 만들면 안전하게 사용하는 것도 가능합니다.\n\n다만, 오른쪽 아래에서 위로 올라가는 방향으로 읽기 때문에 가독성엔 좋지 않아보입니다. 이런 문제로 비판점도 있습니다만, 새로운 방식을 제시했다는 점에서 의미가 있다고 생각합니다.\n\n언어의 한계로 중간 변수 없이 위에서 아래로 읽도록 구현하는 것이 불가능하지만, 만약 가능하다면 진정한 객체지향과 함수형의 조합이 아닐까 생각합니다. 상상 코드를 작성해보면 다음과 같겠네요.\n\n```java\n// Java\nvar result = new Pipe(\n  new IterableOf<>(1, 2, 3, 4, 5),\n  new Filtered(x -> x % 2 == 0),\n  new Mapped(x -> x * x),\n  new Reduced((acc, x) -> acc + x)\n);\n\nSystem.out.println(result.value); // 20\n```\n\n# 마치며\n\n멀티패러다임 프로그래밍은 유연합니다. 리스트 프로세싱은 선언적, 선형적, 신뢰적인 코드를 만들기 좋은 방법이지만 필수적으로 사용해야 하는 것은 아닙니다. 상태가 필요하다면 불변성을 과감히 깨는 것도 좋습니다.\n\n자신의 팀에 맞는 방법을 찾아보세요. 그리고 그 방법이 효율적인 멀티패러다임 프로그래밍이라면 더욱 좋겠죠.\n\n마지막으로 멀티패러다임 프로그래밍의 모든 저자 수익은 서울아산병원 어린이병원에 기부됩니다. 좋은 내용과 의도를 가진 책이니 한 번 읽어보시길 추천드립니다.\n\n<Image src=\"/images/2025-04-25-multi-paradigm-programming-book/donate.png\" maxWidth=\"440px\" />","tableOfContents":{"items":[{"url":"#멀티패러다임-프로그래밍은-왜-등장했는가","title":"멀티패러다임 프로그래밍은 왜 등장했는가?"},{"url":"#멀티패러다임-프로그래밍이-뭘까","title":"멀티패러다임 프로그래밍이 뭘까?"},{"url":"#리스트-프로세싱","title":"리스트 프로세싱"},{"url":"#마치며","title":"마치며"}]},"excerpt":"우리는 함수형, 객체지향, 명령형 패러다임을 제공하는 멀티패러다임 언어를 효율적으로 활용하는 법을 배워야 한다. - 마이크 루키데스 좋은 계기로 마플코퍼레이션 CTO 유인동님이 집필하신 멀티패러다임 프로그래밍을 먼저 읽어보고 추천사까지 남길 수…","fields":{"slug":"/posts/multi-paradigm-programming-book","date":"2025-04-25"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","categories":"book-report","tags":[],"image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/multi-paradigm-programming-book","frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","categories":"book-report","tags":[],"image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png","cover":"/images/2025-04-25-multi-paradigm-programming-book/cover.jpg","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}