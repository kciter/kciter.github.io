{"componentChunkName":"component---src-templates-post-tsx-content-file-path-src-posts-2025-04-23-modeling-series-conditional-tree-mdx","path":"/posts/modeling-series-conditional-tree/","result":{"data":{"site":{"siteMetadata":{"title":"kciter.so | devlog"}},"mdx":{"body":"\nimport Image from '@components/Image';\n\n# 들어가며\n\n> 고객이 장바구니에 상품 X를 담고 있을 때 첫 구매자거나 최근 한 달 내 구매 금액이 10만 원 이상이면서 등급이 VIP라면 쿠폰을 노출해주세요\n\n위와 같이 복잡한 조건을 평가해야 한다면 어떻게 구현 해야할까? 요구사항이 많지 않을 때는 간단히 `if`를 사용하여 빠르게 구현할 수 있지만, 제품이 성숙해질수록 요구사항이 복잡해지기 마련이다.\n\n* 다양한 상황에 대한 조건을 평가해야 한다.\n* 관리자가 개발자에 의존하지 않고 편집할 수 있길 원한다.\n* 런타임 도중에 조건을 변경할 수 있어야 한다.\n* 평가 데이터는 실시간으로 변할 수 있다.\n\n이런 요구사항을 충족하기 위해선 단순히 `if` 문을 사용해 조건을 평가하는 것만으로는 부족하다. 이를 해결하기 위한 강력한 패턴 중 하나가 바로 조건 트리(Condition Tree)라고 할 수 있다.\n\n이번 글에서는 조건 트리가 무엇인지, 어떻게 설계하고 구현할 수 있는지에 대해 설명할 것이다. 조건 트리는 마케팅, 개인화, 권한 관리 등 다양한 곳에서 사용될 수 있다.\n\n예를 들어, 마케팅에서는 특정 조건을 만족하는 사용자에게만 쿠폰을 발급하거나, 개인화된 추천 상품을 제공하는 데 사용될 수 있다. 또한, 권한 관리에서는 특정 조건을 만족하는 사용자에게만 특정 기능이나 리소스에 대한 접근 권한을 부여하는 데 사용될 수 있다.\n\n# 조건을 추상화 하는 방법\n\n언뜻 복잡한 조건을 추상화한다는 것이 매우 복잡하고 어려운 일처럼 보일 수 있다. 하지만 침착하게 접근하면 생각보다 간단하다. 모든 추상화는 **필요한 것을 찾아 필요한 것을 뽑아내는 것**부터 시작한다. 다음 조건이 있다고 가정해보자.\n\n> 나이가 18세 이상이면서 첫 구매거나 VIP인 경우\n\n위 조건은 복잡해 보이지만, 사실 '조건식'과 '조건 연산자' 두 가지 요소로 나눌 수 있다. 문장에서 조건식만 추상화 한다면 다음과 같다.\n\n> [나이가 18세 이상]<span style={{color: '#999'}}>이면서</span> [첫 구매]<span style={{color: '#999'}}>거나</span> [VIP]<span style={{color: '#999'}}>인 경우</span>\n>  * 나이가 18세 이상 (age >= 18)\n>  * 첫 구매 (purchaseCount == 0)\n>  * VIP (level == VIP)\n\n그럼 이번에는 조건 연산자만 추상화 해보자.\n\n> <span style={{color: '#999'}}>나이가 18세 이상</span>이면서(AND) <span style={{color: '#999'}}>첫 구매</span>거나(OR) <span style={{color: '#999'}}>VIP인 경우</span>\n> * AND\n> * OR\n\n두 관점을 결합하여 문장을 추상화하면 다음과 같다\n\n> age >= 18 AND (purchaseCount == 0 OR level == VIP)\n\n이제 조건을 평가하기만 하면 된다. 하지만 조건 연산자엔 우선 순위가 있을 수 있다. 이런 경우 어떻게 처리할까?\n\n알고리즘을 열심히 공부했다면 수식을 트리 형태로 표현하고 재귀 호출로 계산하는 방법을 본적이 있을 것이다. 이와 비슷한 방법으로 조건을 트리 형태로 표현할 수 있다.\n\n```\n        AND\n    ┌────┴─────────┐\n(age ≥ 18)        OR\n          ┌────────┴─────────┐\n  (purchaseCount == 0) (level == VIP)\n```\n\n위와 같이 트리를 만들었다면 재귀적으로 평가할 수 있다. 트리의 각 노드는 조건식과 조건 연산자로 구성되어 있으며, 자식 노드를 가질 수 있다. 자식 노드가 없을 경우 Leaf 노드라고 부르며, 자식 노드가 있을 경우 Composite 노드라고 부른다.\n\n* **Composite 노드**<br />AND, OR, NOT과 같은 복합 조건을 나타내며 자식 노드를 가질 수 있다.\n* **Leaf 노드**<br />단일 조건을 나타내며 자식 노드를 가지지 않는다. 특정 속성(attribute)과 연산자(operator), 값(value)이 결합된 식을 포함한다. 예를 들어 \"사용자의 나이 >= 18\"과 같은 조건을 표현할 수 있다.\n\n이러한 구조는 [Composite 패턴](https://refactoring.guru/design-patterns/composite)을 활용한 것으로, 단순한 조건부터 복잡한 조건까지 일관된 방식으로 표현하는 것이 가능하다.\n\n앞서 문장을 추상화하고 트리라는 구조로 표현한 것처럼 추상적, 구조적인 사고는 다양한 곳에 활용할 수 있다. 이러한 감각을 익혀나가면 복잡한 문제를 해결하는 데 큰 도움이 되므로 기회가 된다면 연습해보길 권장한다.\n\n# 모델 설계\n\n조건 트리에 대해 이해했다면 모델 설계와 구현은 어렵지 않다. 조건 트리는 Composite 패턴을 활용했기 때문에 거의 그대로 설계할 수 있다. 다만, Leaf 노드에서 속성과 식을 어떻게 표현할지만 고민하면 된다. 그리고 조건 트리를 평가하기 위한 로직도 필요하다.\n\n먼저 조건 트리에 대한 도식을 그려보자.\n\n<Image src=\"/images/2025-04-23-modeling-series-conditional-tree/conditional-tree-uml.png\" caption=\"조건 트리 도식\" expandable />\n\n위 도식은 조건 트리의 기본 구조를 나타낸다. 각 모델이 어떤 역할을 하는지 살펴보자.\n\n* `ConditionNode`: 조건 트리의 기본 노드로, Leaf 노드와 Composite 노드에 대한 인터페이스다.\n* `LeafCondition`: Leaf 노드로, 단일 조건을 나타낸다. 속성(attribute), 연산자(operator), 값(value)을 포함한다.\n* `CompositeCondition`: Composite 노드로, 복합 조건을 나타낸다. 자식 노드를 가질 수 있으며, AND, OR, NOT과 같은 논리 연산자를 포함한다.\n\n위와 같이 조건 트리 모델을 설계할 수 있다. 하지만 해당 모델은 데이터베이스 환경이 고려되지 않았다. 만약 RDB를 사용한다면 [객체-관계 불일치](https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch)[^1]로 인해 별도로 엔티티 모델을 설계해야 한다.[^2] 다음은 조건 트리 모델을 데이터베이스에 저장하기 위한 엔티티 모델이다.\n\n<Image src=\"/images/2025-04-23-modeling-series-conditional-tree/conditional-tree-entity-uml.png\" caption=\"조건 트리 엔티티 도식\" expandable />\n\n조건 트리 자체가 크게 복잡하지 않으므로 `ConditionNodeEntity` 하나로 모든 노드를 표현할 수 있다. Leaf 노드와 Composite 노드를 구분하기 위해 `NodeType`을 추가했고 `parent_id`를 통해 부모 노드를 참조할 수 있도록 했다. 이를 통해 트리 구조를 표현할 수 있다.\n\n# 구현\n\n설계는 일종의 계획이다. 계획을 세웠으니 이제 실제 구현을 해보자. 이 글에서는 Kotlin을 사용하여 조건 트리를 구현할 것이다. 그리고 특정 프레임워크를 고려하지 않으므로 일종의 의사 코드라고 생각하고 보는 것을 추천한다. 실제 구현은 사용하는 프레임워크에 맞게 조정해야 한다.\n\n## 모델 구현\n\n앞서 소개한 예시처럼 사용자 정보에 대한 속성을 기반으로 조건 트리 모델을 만들어보자.\n\n```kotlin\nsealed interface ConditionalNode{\n  val id: Long?\n}\n\ndata class LeafCondition(\n  override val id: Long?,\n  val attribute: String,\n  val operator: ConditionOperator,\n  val value: String,\n  val valueType: String\n) : ConditionalNode {\n  enum class ConditionOperator {\n    EQ,\n    NEQ,\n    GT,\n    GTE,\n    LT,\n    LTE\n  }\n}\n\ndata class CompositeCondition(\n  override val id: Long?,\n  val logic: LogicalOperator,\n  val children: List<ConditionalNode>\n) : ConditionalNode {\n  enum class LogicalOperator {\n    AND,\n    OR,\n    NOT\n  }\n}\n```\n\n위 코드는 조건 트리의 기본 구조를 나타낸다. `ConditionalNode`를 인터페이스로 정의하여 `LeafCondition`과 `CompositeCondition`을 구현했다. 앞서 설계한 내용과 크게 다르지 않다.\n\n## Evaluator 구현\n\n이어서 조건 트리를 평가하기 위한 `ConditionEvaluator`를 구현해보자.\n\n```kotlin\nfun interface AttributeResolver {\n  fun resolve(attribute: String): Any?\n}\n\nclass ConditionEvaluator {\n  fun evaluate(condition: ConditionalNode, resolver: AttributeResolver): Boolean {\n    return when (condition) {\n      is LeafCondition -> evaluateLeaf(condition, resolver)\n      is CompositeCondition -> {\n        val results = condition.children.map { evaluate(it, resolver) }\n        when (condition.logic) {\n          CompositeCondition.LogicalOperator.AND -> results.all { it }\n          CompositeCondition.LogicalOperator.OR -> results.any { it }\n          CompositeCondition.LogicalOperator.NOT -> results.singleOrNull()?.not() ?: false\n        }\n      }\n    }\n  }\n\n  // ...\n}\n```\n\n`ConditionEvaluator`는 조건 트리를 평가하는 역할을 한다. `evaluate` 메서드는 조건 노드의 타입에 따라 적절한 평가 로직을 호출한다. Leaf 노드인 경우 `evaluateLeaf` 메서드를 호출하여 조건식을 평가하고, Composite 노드인 경우 자식 노드를 재귀적으로 평가한다.\n\n여기서 `AttributeResolver`는 평가할 속성에 대한 값을 제공하는 인터페이스다. 이를 통해 조건 트리에서 사용되는 속성(attribute)을 동적으로 제공할 수 있다. `evaluateLeaf` 메서드는 다음과 같이 구현할 수 있다.\n\n```kotlin\nclass ConditionEvaluator {\n  // ...\n\n  @Suppress(\"UNCHECKED_CAST\")\n  private fun evaluateLeaf(leaf: LeafCondition, resolver: AttributeResolver): Boolean {\n    // 1. 평가할 속성 값을 조회하고 속성이 없다면 조건을 만족하지 않음\n    val actual = resolver.resolve(leaf.attribute) ?: return false\n\n    // 2. String 타입인 조건 값을 변환\n    val expected: Any? = try {\n      convertValue(leaf.value, leaf.valueType)\n    } catch (e: Exception) {\n      return false\n    }\n\n    // 3. 변환된 조건 값과 실제 속성 값을 비교 평가\n    return when (leaf.operator) {\n      LeafCondition.ConditionOperator.EQ -> actual == expected\n      LeafCondition.ConditionOperator.NEQ -> actual != expected\n\n      LeafCondition.ConditionOperator.GT,\n      LeafCondition.ConditionOperator.GTE,\n      LeafCondition.ConditionOperator.LT,\n      LeafCondition.ConditionOperator.LTE -> {\n        if (actual !is Comparable<*> || expected !is Comparable<*>) return false\n        if (actual::class != expected::class) return false\n\n        val left = actual as Comparable<Any>\n        val right = expected as Comparable<Any>\n        when (leaf.operator) {\n          LeafCondition.ConditionOperator.GT -> left > right\n          LeafCondition.ConditionOperator.GTE -> left >= right\n          LeafCondition.ConditionOperator.LT -> left < right\n          LeafCondition.ConditionOperator.LTE -> left <= right\n          else -> false\n        }\n      }\n    }\n  }\n\n  // String 타입인 조건 값을 변환하는 메서드\n  private fun convertValue(value: String, type: String): Any? {\n    if (value == null || type == null) return null\n\n    return when (type) {\n      \"Long\"   -> value.toLongOrNull()\n      \"Int\"    -> value.toIntOrNull()\n      \"Boolean\" -> value.toBooleanStrictOrNull()\n      \"Double\" -> value.toDoubleOrNull()\n      \"String\" -> value\n      else     -> throw IllegalArgumentException(\"Unsupported type: $type\")\n    }\n  }\n}\n```\n\n내용이 장황하지만 하나씩 살펴보면 어렵지 않다. `evaluateLeaf` 메서드는 다음과 같은 순서로 진행된다.\n\n1. `AttributeResolver`를 통해 평가할 속성 값을 조회한다. 만약 속성이 없다면 조건을 만족하지 않는 것으로 간주한다.\n2. 조건 값을 `String` 타입으로 사용하므로 `convertValue` 메서드를 통해 변환한다. 변환할 수 없다면 조건을 만족하지 않는 것으로 간주한다.\n3. 변환된 조건 값과 실제 속성 값을 비교하여 평가한다.\n\n여기까지 구현했다면 조건 트리를 평가할 수 있는 기본적인 구조는 완성됐다. 하지만 아직 부족한 점이 있다. 바로 조건 트리를 데이터베이스에 저장하고 불러오는 기능이다.\n\n## 엔티티 모델 구현\n\n조건 트리를 RDB 데이터베이스에 저장하기 위해서는 엔티티 모델을 구현해야 한다. 앞서 설계한 도식에 따라 `ConditionNodeEntity`를 구현해보자.\n\n```kotlin\n@Table(name = \"condition_nodes\")\ndata class ConditionNodeEntity(\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  val id: Long? = null,\n  val targetId: Long? = null, // 조건이 적용되는 대상 ID\n  val parentId: Long? = null,\n  val type: NodeType,\n\n  // LEAF\n  val attribute: String? = null,\n  val operator: LeafCondition.ConditionOperator? = null,\n  val value: String? = null,\n  val valueType: String? = null,\n\n  // COMPOSITE\n  val logic: CompositeCondition.LogicalOperator? = null\n) {\n  enum class NodeType {\n    LEAF,\n    COMPOSITE\n  }\n}\n```\n\n모델 자체가 간단하므로 쉽게 구현할 수 있다. 이제 이어서 데이터베이스에 저장된 조건 트리를 불러와 실제 조건 트리로 변환하는 로직을 구현해보자.\n\n## Tree Loader 구현\n\n조건 트리를 데이터베이스에서 불러와 트리를 구성하기 위해 `ConditionTreeLoader`를 구현해보자.\n\n```kotlin\nclass ConditionTreeLoader(\n  private val conditionNodeRepository: ConditionNodeRepository\n) {\n  fun load(targetId: Long): ConditionalNode? {\n    // 1. 대상에 걸린 모든 조건 노드를 조회\n    val allNodes = conditionNodeRepository.findByTargetId(targetId)\n    val nodeMap = allNodes.associateBy { it.id }\n    // 2. 부모 노드가 없는 조건 노드를 찾는다.\n    val root = allNodes.firstOrNull { it.parentId == null } ?: return null\n    // 3. 조건 트리를 구성하여 반환\n    return buildTree(root, nodeMap)\n  }\n\n  // 재귀적으로 트리를 구성하는 메서드\n  private fun buildTree(root: ConditionNodeEntity, nodeMap: Map<Long, ConditionNodeEntity>): ConditionalNode {\n    return when (root.type) {\n      ConditionNodeEntity.NodeType.LEAF -> {\n        LeafCondition(\n          id = root.id,\n          attribute = root.attribute!!,\n          operator = root.operator!!,\n          value = root.value!!,\n          valueType = root.valueType!!.let {\n            when (it) {\n              \"Long\" -> Long::class\n              \"Int\" -> Int::class\n              \"Boolean\" -> Boolean::class\n              \"Double\" -> Double::class\n              \"String\" -> String::class\n              else -> throw IllegalArgumentException(\"Unsupported type: $it\")\n            }\n          }\n        )\n      }\n      ConditionNodeEntity.NodeType.COMPOSITE -> {\n        val children = nodeMap.values.filter { it.parentId == root.id }\n        CompositeCondition(\n          id = root.id,\n          logic = root.logic!!,\n          // 재귀적으로 자식 노드를 구성\n          children = children.map { buildTree(it, nodeMap) }\n        )\n      }\n    }\n  }\n}\n```\n\n먼저 루트 노드를 찾고, 그 노드의 자식 노드를 재귀적으로 구성하여 트리를 만든다. 이때, 성능 최적화를 위해 `nodeMap`을 구성하면 부모 노드에 대한 자식 노드를 쉽게 찾을 수 있다.\n\n## 사용 예시\n\n이제 실제로 데이터베이스에서 조건 트리를 불러와 평가하는 예시를 살펴보자. 다음은 데이터베이스 없이 조건 트리를 평가하는 예시다.\n\n```kotlin\nfun main() {\n  // 1. 먼저 조건 트리를 구성한다.\n  val condition = CompositeCondition(\n    id = null,\n    logic = CompositeCondition.LogicalOperator.AND,\n    children = listOf(\n      LeafCondition(\n        id = null,\n        attribute = \"age\",\n        operator = LeafCondition.ConditionOperator.GTE,\n        value = \"18\",\n        valueType = Long::class\n      ),\n      LeafCondition(\n        id = null,\n        attribute = \"purchaseCount\",\n        operator = LeafCondition.ConditionOperator.GT,\n        value = \"5\",\n        valueType = Long::class\n      )\n    )\n  )\n\n  // 2. 평가할 속성 값을 제공하는 AttributeResolver를 생성한다.\n  val resolver = AttributeResolver { attr ->\n    when (attr) {\n      \"age\"           -> 20\n      \"purchaseCount\" -> 10\n      \"level\"         -> \"VIP\"\n      else            -> null\n    }\n  }\n\n  // 3. 조건 트리를 평가한다.\n  val evaluator = ConditionEvaluator()\n  val result = evaluator.evaluate(condition, resolver)\n\n  // 4. 평가 결과를 출력한다.\n  println(\"Evaluation Result: $result\") // true\n}\n```\n\n다음으로 데이터베이스를 사용하여 조건 트리를 평가하는 예시를 살펴보자. 만약 Spring을 사용한다면 `ConditionTreeLoader`와 `ConditionEvaluator`를 Bean으로 등록하여 DI를 통해 사용할 수 있다. 다음 코드는 Spring을 사용한 예시다.\n\n```kotlin\n@Service\nclass CouponConditionService(\n  private val conditionTreeLoader: ConditionTreeLoader,\n  private val conditionEvaluator: ConditionEvaluator\n) {\n  fun canExpose(targetId: Long): Boolean {\n    // 1. 조건 트리 로더를 통해 조건 트리를 불러온다.\n    val conditionTree = conditionTreeLoader.load(targetId)\n\n    // 2. 평가할 속성 값을 제공하는 AttributeResolver 구현\n    val attributeResolver = AttributeResolver { attribute ->\n      when (attribute) {\n        \"age\" -> 20\n        \"purchaseCount\" -> 3\n        \"level\" -> \"SILVER\"\n        else -> null\n      }\n    }\n\n    // 2. 조건 트리를 평가한다.\n    return conditionEvaluator.evaluate(conditionTree, attributeResolver)\n  }\n}\n```\n\n# Rule Engine과 차이점\n\n조건 트리는 얼핏 보면 Rule Engine과 유사해 보일 수 있다. 둘 다 어떤 조건을 평가하고, 그 결과를 바탕으로 후속 동작을 수행한다. 하지만 실제로는 구조도, 역할도, 활용 범위도 전혀 다르다.\n\n조건 트리는 하나의 조건 트리만을 평가한다. 즉, 하나의 조건 트리는 하나의 Boolean 결과값(true 또는 false)을 반환한다. 반면, Rule Engine은 수십 개에서 수천 개의 규칙을 동시에 평가한다. Rule Engine은 여러 개의 규칙이 동시에 만족될 수 있기 때문에, 어떤 규칙을 우선 실행할지 결정하기 위한 우선순위, 충돌 해소 전략 등의 개념이 필요하다.\n\n그리고 조건 트리는 단순히 조건을 평가하는 데 중점을 두지만, Rule Engine IF 조건이 만족되면 THEN에 해당하는 액션을 실행한다는 형식을 따르며, Rule Engine은 이 조건들을 모두 탐색하고 실행 순서를 조율한다.\n\n정리하자면 조건 트리는 주로 다음과 같은 상황에서 사용된다.\n* 단일 조건식으로 판단해야 할 때\n* 복잡한 조건을 관리자 화면에서 간단히 조정하고 싶을 때\n* 특정 시점에만 평가되며, 즉시 결과를 얻고 싶을 때\n\n반면, Rule Engine은 다음과 같은 상황에서 유용하다.\n* 수백 개 이상의 규칙을 동시에 평가해야 할 때\n* 규칙 간의 의존성이나 추론(Chaining)이 필요한 경우\n* IF-THEN 구조로 규칙에 기반한 복잡한 비즈니스 로직을 구현해야 할 때\n\n# 마치며\n\n이번 글에서는 조건이라는 요구사항을 추상화하는 방법과 조건 트리 모델을 설계하는 방법에 대해 설명했다. 조건 트리는 복잡한 조건을 평가하기 위한 강력한 도구로, 다양한 분야에서 활용될 수 있다.\n\n또한 조건 트리는 관리자가 직접 조건을 편집할 수 있는 유연성을 제공한다. 또한, 런타임 도중에 조건을 변경할 수 있어 다양한 상황에 대응할 수 있다.\n\n이처럼 잘 설계된 모델은 제품을 좀 더 유연하고 확장 가능하게 만들어준다.\n\n\n[^1]: 임피던스 불일치라고도 하며, 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 불일치를 의미한다. 객체 지향 프로그래밍 언어는 객체를 중심으로 설계되지만, 관계형 데이터베이스는 테이블을 중심으로 설계된다. 이로 인해 두 시스템 간의 데이터 표현 방식이 다르기 때문에 발생하는 문제를 의미한다.\n[^2]: 만약 MongoDB와 같은 Document 기반 DB를 사용한다면 별도로 엔티티 모델을 만들 필요 없이 그대로 사용할 수 있다.\n","tableOfContents":{"items":[{"url":"#들어가며","title":"들어가며"},{"url":"#조건을-추상화-하는-방법","title":"조건을 추상화 하는 방법"},{"url":"#모델-설계","title":"모델 설계"},{"url":"#구현","title":"구현","items":[{"url":"#모델-구현","title":"모델 구현"},{"url":"#evaluator-구현","title":"Evaluator 구현"},{"url":"#엔티티-모델-구현","title":"엔티티 모델 구현"},{"url":"#tree-loader-구현","title":"Tree Loader 구현"},{"url":"#사용-예시","title":"사용 예시"}]},{"url":"#rule-engine과-차이점","title":"Rule Engine과 차이점"},{"url":"#마치며","title":"마치며"}]},"excerpt":"고객이 장바구니에 상품 X를 담고 있을 때 첫 구매자거나 최근 한 달 내 구매 금액이 10만 원 이상이면서 등급이 VIP라면 쿠폰을 노출해주세요 위와 같이 복잡한 조건을 평가해야 한다면 어떻게 구현 해야할까? 요구사항이 많지 않을 때는 간단히…","fields":{"slug":"/posts/modeling-series-conditional-tree","date":"2025-04-23"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","categories":"article","tags":["modeling"],"image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png","comments":true,"draft":false}},"allMdx":{"edges":[{"node":{"fields":{"date":"2021-02-25","slug":"/posts/about-mongodb"},"frontmatter":{"title":"MongoDB 이해하기","image":"/images/2021-02-25-about-mongodb/thumbnail.png"}}},{"node":{"fields":{"date":"2021-02-23","slug":"/posts/first-post"},"frontmatter":{"title":"첫 포스트를 작성하며","image":"/images/2021-02-23-first-post/mountains.jpg"}}},{"node":{"fields":{"date":"2021-02-28","slug":"/posts/basic-web-hacking"},"frontmatter":{"title":"웹 개발을 위해 꼭 알아야하는 보안 공격","image":"/images/2021-02-28-basic-web-hacking/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-14","slug":"/posts/effective-atomic-design"},"frontmatter":{"title":"Effective Atomic Design","image":"/images/2021-03-14-effective-atomic-design/thumbnail.png"}}},{"node":{"fields":{"date":"2021-03-20","slug":"/posts/deep-dive-into-datetime"},"frontmatter":{"title":"시간에 대해 탐구하기","image":"/images/2021-03-20-deep-dive-into-datetime/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-05","slug":"/posts/programmers-brain-book-report"},"frontmatter":{"title":"올바른 코드를 위한 끝없는 고찰","image":"/images/2022-08-05-programmers-brain-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-16","slug":"/posts/polymorphic-react-component"},"frontmatter":{"title":"Polymorphic한 React 컴포넌트 만들기","image":"/images/2022-08-16-polymorphic-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2022-08-31","slug":"/posts/the-nature-of-software-development-book-report"},"frontmatter":{"title":"우리 팀은 어떻게 일 해야할까?","image":"/images/2022-08-31-the-nature-of-software-development-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-08","slug":"/posts/software-master-book-report"},"frontmatter":{"title":"나는 프로답게 일했는가?","image":"/images/2022-09-08-software-master-book-report/thumbnail.png"}}},{"node":{"fields":{"date":"2022-09-18","slug":"/posts/crafting-esolang"},"frontmatter":{"title":"난해한 프로그래밍 언어 만들어보기","image":"/images/2022-09-18-crafting-esolang/thumbnail.png"}}},{"node":{"fields":{"date":"2023-05-03","slug":"/posts/spring-multi-module-architecture"},"frontmatter":{"title":"IoC와 DI를 이용한 Spring 멀티 모듈 아키텍처","image":"/images/2023-05-03-spring-multi-module-architecture/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-10","slug":"/posts/effective-work"},"frontmatter":{"title":"갓생사는 방법론","image":"/images/2023-07-10-effective-work/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-17","slug":"/posts/railway-oriented-programming"},"frontmatter":{"title":"Railway-Oriented Programming","image":"/images/2023-07-17-railway-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2023-07-24","slug":"/posts/functional-data-structure"},"frontmatter":{"title":"함수형 자료구조","image":"/images/2023-07-24-functional-data-structure/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-05","slug":"/posts/what-is-beautiful-code"},"frontmatter":{"title":"아름다운 코드에 대하여","image":"/images/2023-12-05-what-is-beautiful-code/thumbnail.png"}}},{"node":{"fields":{"date":"2023-12-24","slug":"/posts/developers-learning-and-growth"},"frontmatter":{"title":"개발자의 학습과 성장","image":"/images/2023-12-24-developers-learning-and-growth/thumbnail.png"}}},{"node":{"fields":{"date":"2024-01-21","slug":"/posts/type-driven-development"},"frontmatter":{"title":"Type-Driven Development","image":"/images/2024-01-21-type-driven-development/thumbnail.png"}}},{"node":{"fields":{"date":"2024-02-18","slug":"/posts/render-delegation-react-component"},"frontmatter":{"title":"Render Delegation하는 React 컴포넌트 만들기","image":"/images/2024-02-18-render-delegation-react-component/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-03","slug":"/posts/ascii-3d-renderer"},"frontmatter":{"title":"ASCII 3D 렌더러 만들기","image":"/images/2024-03-03-ascii-3d-renderer/thumbnail.png"}}},{"node":{"fields":{"date":"2024-03-16","slug":"/posts/principles-of-debugging"},"frontmatter":{"title":"디버깅 원칙","image":"/images/2024-03-16-principles-of-debugging/thumbnail.png"}}},{"node":{"fields":{"date":"2024-04-14","slug":"/posts/encrypted-vault-system"},"frontmatter":{"title":"비밀 관리를 위한 금고 시스템 만들기","image":"/images/2024-04-14-encrypted-vault-system/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-10","slug":"/posts/the-shortcut"},"frontmatter":{"title":"기계의 반칙","image":"/images/2024-05-10-the-shortcut/thumbnail.png"}}},{"node":{"fields":{"date":"2024-05-17","slug":"/posts/warp-and-weft"},"frontmatter":{"title":"씨줄과 날줄","image":"/images/2024-05-17-warp-and-weft/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-09","slug":"/posts/best-prompt-engineering-lesson"},"frontmatter":{"title":"프롬프트 엔지니어링을 시작한다면","image":"/images/2024-07-09-best-prompt-engineering-lesson/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-27","slug":"/posts/tidy-first"},"frontmatter":{"title":"정리부터 먼저 하라구요?","image":"/images/2024-07-27-tidy-first/thumbnail.png"}}},{"node":{"fields":{"date":"2024-07-29","slug":"/posts/copybook"},"frontmatter":{"title":"카피책을 카피하다","image":"/images/2024-07-29-copybook/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-12","slug":"/posts/the-aesthetics-of-destroying-software"},"frontmatter":{"title":"소프트웨어 파괴의 미학","image":"/images/2024-10-12-the-aesthetics-of-destroying-software/thumbnail.png"}}},{"node":{"fields":{"date":"2024-11-10","slug":"/posts/developers-abstraction-structural-thinking"},"frontmatter":{"title":"개발자의 추상적, 구조적 사고","image":"/images/2024-11-10-developers-abstraction-structural-thinking/thumbnail.png"}}},{"node":{"fields":{"date":"2024-10-27","slug":"/posts/music-recognition-system"},"frontmatter":{"title":"음악 검색 시스템 만들기","image":"/images/2024-10-27-music-recognition-system/thumbnail.png"}}},{"node":{"fields":{"date":"2025-01-19","slug":"/posts/using-kotlin-script"},"frontmatter":{"title":"Kotlin Script 활용하기","image":"/images/2025-01-19-using-kotlin-script/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-06","slug":"/posts/data-oriented-programming"},"frontmatter":{"title":"데이터 지향 프로그래밍","image":"/images/2025-02-06-data-oriented-programming/thumbnail.png"}}},{"node":{"fields":{"date":"2025-02-19","slug":"/posts/coding-test-story"},"frontmatter":{"title":"코딩 테스트 이모저모","image":"/images/2025-02-19-coding-test-story/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-09","slug":"/posts/new-kind-of-hallucination"},"frontmatter":{"title":"새로운 종류의 AI 환각","image":"/images/2025-04-09-new-kind-of-hallucination/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-16","slug":"/posts/modeling-series-foreword"},"frontmatter":{"title":"모델링 시리즈: 서문","image":"/images/2025-04-16-modeling-series-foreword/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-18","slug":"/posts/modeling-series-view-model"},"frontmatter":{"title":"모델링 시리즈: 뷰모델","image":"/images/2025-04-18-modeling-series-view-model/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-10","slug":"/posts/mcp-from-ux-perspective"},"frontmatter":{"title":"UX 관점에서 바라보는 MCP","image":"/images/2025-04-10-mcp-from-ux-perspective/thumbnail.jpg"}}},{"node":{"fields":{"date":"2025-04-23","slug":"/posts/modeling-series-conditional-tree"},"frontmatter":{"title":"모델링 시리즈: 조건 트리","image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png"}}},{"node":{"fields":{"date":"2025-03-12","slug":"/posts/build-large-scale-react-web-apps"},"frontmatter":{"title":"대규모 리액트 웹 앱 개발","image":"/images/2025-03-12-build-large-scale-react-web-apps/thumbnail.png"}}},{"node":{"fields":{"date":"2025-04-25","slug":"/posts/multi-paradigm-programming-book"},"frontmatter":{"title":"멀티패러다임 프로그래밍과 리스트 프로세싱","image":"/images/2025-04-25-multi-paradigm-programming-book/thumbnail.png"}}}]}},"pageContext":{"slug":"/posts/modeling-series-conditional-tree","series":{"title":"모델링 시리즈","items":[{"title":"모델링 시리즈: 서문","url":"/posts/modeling-series-foreword"},{"title":"모델링 시리즈: 뷰모델","url":"/posts/modeling-series-view-model"},{"title":"모델링 시리즈: 조건 트리","url":"/posts/modeling-series-conditional-tree"}]},"frontmatter":{"series":"모델링 시리즈","title":"모델링 시리즈: 조건 트리","categories":"article","tags":["modeling"],"image":"/images/2025-04-23-modeling-series-conditional-tree/thumbnail.png","comments":true,"draft":false,"hide":false}}},"staticQueryHashes":["595849736","63159454"],"slicesMap":{}}